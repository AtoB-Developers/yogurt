# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
end

module AST
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

module Base64Bp
end

module Base64Bp
  extend ::Base64
  def self.urlsafe_encode64(bin, padding:); end
end

class BasicObject
  def __binding__(); end

  def as_null_object(); end

  def null_object?(); end

  def received_message?(message, *args, &block); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not_receive(message, &block); end

  def should_receive(message, opts=T.unsafe(nil), &block); end

  def stub(message_or_hash, opts=T.unsafe(nil), &block); end

  def stub_chain(*chain, &blk); end

  def unstub(message); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def global_path_appends_ruby_scope?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def backport_ext_builder_monitor(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BasenameSetting
end

class Byebug::BreakCommand
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(_, _1, _2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
end

class Byebug::CatchCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(); end

  def help(*args, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def processor(); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  include ::Enumerable
  def each(&blk); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandList
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandNotFound
end

class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, &block); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, &block); end

  def puts(*args, &block); end

  def repl(); end
end

class Byebug::CommandProcessor
  extend ::Forwardable
end

class Byebug::ConditionCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*_); end

  def frame_class(*_); end

  def frame_file(*_); end

  def frame_line(*_); end

  def frame_method(*_); end

  def frame_self(*_); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*_); end

  def step_out(*_); end

  def step_over(*_); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::ControlProcessor
end

class Byebug::DebugCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
  def self.inherited(); end
end

class Byebug::DeleteCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  include ::Byebug::Subcommands
end

class Byebug::DisableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  include ::Byebug::Subcommands
end

class Byebug::EnableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  include ::Byebug::Helpers::FileHelper
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::Frame
end

class Byebug::FrameCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::FullpathSetting
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::BinHelper
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::EvalHelper
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FileHelper
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::FrameHelper
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::ParseHelper
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::PathHelper
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::ReflectionHelper
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::StringHelper
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ThreadHelper
end

module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::ToggleHelper
end

module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

module Byebug::Helpers::VarHelper
end

module Byebug::Helpers
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::History
end

class Byebug::HistoryCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
end

class Byebug::InfoCommand
  include ::Byebug::Subcommands
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  include ::Byebug::Helpers::FileHelper
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::Interface
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::LinetraceSetting
end

class Byebug::ListCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def amend_final(*args, &block); end

  def execute(); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end

  def without_readline_completion(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
end

class Byebug::MethodCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemProcessor
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::PostMortemSetting
end

module Byebug::Printers
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::Printers::Plain
end

module Byebug::Printers
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PryProcessor
  def at_breakpoint(breakpoint); end

  def at_return(_return_value); end

  def bold(*args, &block); end

  def output(*args, &block); end

  def perform(action, options=T.unsafe(nil)); end

  def pry(); end

  def pry=(pry); end

  def run(&_block); end
end

class Byebug::PryProcessor
  def self.start(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Remote
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Client
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::Remote::Server
end

module Byebug::Remote
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RemoteInterface
end

class Byebug::RestartCommand
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end
end

class Byebug::ScriptInterface
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::ScriptProcessor
end

class Byebug::SetCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SkipCommand
  include ::Byebug::Helpers::ParseHelper
  def auto_run(); end

  def execute(); end

  def initialize_attributes(); end

  def keep_execution(); end

  def reset_attributes(); end
end

class Byebug::SkipCommand
  def self.description(); end

  def self.file_line(); end

  def self.file_line=(file_line); end

  def self.file_path(); end

  def self.file_path=(file_path); end

  def self.previous_autolist(); end

  def self.regexp(); end

  def self.restore_autolist(); end

  def self.setup_autolist(value); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::SourceFileFormatter
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StackOnErrorSetting
end

class Byebug::StepCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, &block); end
end

module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands::ClassMethods
end

module Byebug::Subcommands
  extend ::Forwardable
  def self.included(command); end
end

class Byebug::ThreadCommand
  include ::Byebug::Subcommands
end

class Byebug::ThreadCommand::CurrentCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  include ::Byebug::Subcommands
end

class Byebug::VarCommand::AllCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  include ::Byebug::Helpers::FrameHelper
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::WidthSetting
end

module Byebug
  extend ::Byebug
  extend ::Byebug::Helpers::ReflectionHelper
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.attach(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.spawn(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def any_instance(); end

  def json_creatable?(); end
end

module CodeRay
  CODERAY_PATH = ::T.let(nil, ::T.untyped)
  TokenKinds = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class CodeRay::Duo
  def call(code, options=T.unsafe(nil)); end

  def encode(code, options=T.unsafe(nil)); end

  def encoder(); end

  def format(); end

  def format=(format); end

  def highlight(code, options=T.unsafe(nil)); end

  def initialize(lang=T.unsafe(nil), format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def lang=(lang); end

  def options(); end

  def options=(options); end

  def scanner(); end
end

class CodeRay::Duo
  def self.[](*_); end
end

module CodeRay::Encoders
end

class CodeRay::Encoders::Encoder
  def <<(token); end

  def begin_group(kind); end

  def begin_line(kind); end

  def compile(tokens, options=T.unsafe(nil)); end

  def encode(code, lang, options=T.unsafe(nil)); end

  def encode_tokens(tokens, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def file_extension(); end

  def finish(options); end

  def get_output(options); end

  def highlight(code, lang, options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def output(data); end

  def scanner(); end

  def scanner=(scanner); end

  def setup(options); end

  def text_token(text, kind); end

  def token(content, kind); end

  def tokens(tokens, options=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Encoders::Encoder::PLUGIN_HOST = CodeRay::Encoders

class CodeRay::Encoders::Encoder
  extend ::CodeRay::Plugin
  def self.const_missing(sym); end

  def self.file_extension(); end
end

class CodeRay::Encoders::HTML
  def break_lines(text, style); end

  def check_group_nesting(name, kind); end

  def check_options!(options); end

  def close_span(); end

  def css(); end

  def css_class_for_kinds(kinds); end

  def make_span_for_kinds(method, hint); end

  def style_for_kinds(kinds); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  FILE_EXTENSION = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_PATTERN = ::T.let(nil, ::T.untyped)
  TOKEN_KIND_TO_INFO = ::T.let(nil, ::T.untyped)
  TRANSPARENT_TOKEN_KINDS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def get_style_for_css_classes(css_classes); end

  def initialize(style=T.unsafe(nil)); end

  def stylesheet(); end
  CSS_CLASS_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::CSS
  def self.load_stylesheet(style=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Numbering
end

module CodeRay::Encoders::HTML::Numbering
  def self.number!(output, mode=T.unsafe(nil), options=T.unsafe(nil)); end
end

module CodeRay::Encoders::HTML::Output
  def apply_title!(title); end

  def css(); end

  def css=(css); end

  def stylesheet(in_tag=T.unsafe(nil)); end

  def wrap!(element, *args); end

  def wrap_in!(template); end

  def wrapped_in(); end

  def wrapped_in=(wrapped_in); end

  def wrapped_in?(element); end
  DIV = ::T.let(nil, ::T.untyped)
  PAGE = ::T.let(nil, ::T.untyped)
  SPAN = ::T.let(nil, ::T.untyped)
  TABLE = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::HTML::Output::Template
  def apply(target, replacement); end
end

class CodeRay::Encoders::HTML::Output::Template
  def self.wrap!(str, template, target); end
end

module CodeRay::Encoders::HTML::Output
  def self.extended(o); end

  def self.make_stylesheet(css, in_tag=T.unsafe(nil)); end

  def self.page_template_for_css(css); end
end

class CodeRay::Encoders::HTML
  def self.make_html_escape_hash(); end

  def self.token_path_to_hint(hint, kinds); end
end

class CodeRay::Encoders::Terminal
  TOKEN_COLORS = ::T.let(nil, ::T.untyped)
end

class CodeRay::Encoders::Terminal
end

module CodeRay::Encoders
  extend ::CodeRay::PluginHost
end

module CodeRay::FileType
  TypeFromExt = ::T.let(nil, ::T.untyped)
  TypeFromName = ::T.let(nil, ::T.untyped)
  TypeFromShebang = ::T.let(nil, ::T.untyped)
end

class CodeRay::FileType::UnknownFileType
end

class CodeRay::FileType::UnknownFileType
end

module CodeRay::FileType
  def self.[](filename, read_shebang=T.unsafe(nil)); end

  def self.fetch(filename, default=T.unsafe(nil), read_shebang=T.unsafe(nil)); end

  def self.type_from_shebang(filename); end
end

module CodeRay::Plugin
  def aliases(); end

  def plugin_host(host=T.unsafe(nil)); end

  def plugin_id(); end

  def register_for(id); end

  def title(title=T.unsafe(nil)); end
end

module CodeRay::Plugin
end

module CodeRay::PluginHost
  def [](id, *args, &blk); end

  def all_plugins(); end

  def const_missing(const); end

  def default(id=T.unsafe(nil)); end

  def list(); end

  def load(id, *args, &blk); end

  def load_all(); end

  def load_plugin_map(); end

  def make_plugin_hash(); end

  def map(hash); end

  def path_to(plugin_id); end

  def plugin_hash(); end

  def plugin_path(*args); end

  def register(plugin, id); end

  def validate_id(id); end
  PLUGIN_HOSTS = ::T.let(nil, ::T.untyped)
  PLUGIN_HOSTS_BY_ID = ::T.let(nil, ::T.untyped)
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::HostNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

class CodeRay::PluginHost::PluginNotFound
end

module CodeRay::PluginHost
  def self.extended(mod); end
end

module CodeRay::Scanners
end

class CodeRay::Scanners::Java
  def scan_tokens(encoder, options); end
  CONSTANTS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MAGIC_VARIABLES = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  STRING_CONTENT_PATTERN = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  UNICODE_ESCAPE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
  List = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Java::BuiltinTypes
end

class CodeRay::Scanners::Java
end

class CodeRay::Scanners::Ruby
  def interpreted_string_state(); end

  def scan_tokens(encoder, options); end
end

module CodeRay::Scanners::Ruby::Patterns
  BINARY = ::T.let(nil, ::T.untyped)
  CHARACTER = ::T.let(nil, ::T.untyped)
  CLASS_VARIABLE = ::T.let(nil, ::T.untyped)
  CONTROL_META_ESCAPE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
  DECIMAL = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  EXPONENT = ::T.let(nil, ::T.untyped)
  FANCY_STRING_INTERPRETED = ::T.let(nil, ::T.untyped)
  FANCY_STRING_KIND = ::T.let(nil, ::T.untyped)
  FANCY_STRING_START = ::T.let(nil, ::T.untyped)
  FLOAT_OR_INT = ::T.let(nil, ::T.untyped)
  FLOAT_SUFFIX = ::T.let(nil, ::T.untyped)
  GLOBAL_VARIABLE = ::T.let(nil, ::T.untyped)
  HEREDOC_OPEN = ::T.let(nil, ::T.untyped)
  HEXADECIMAL = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_KIND = ::T.let(nil, ::T.untyped)
  INSTANCE_VARIABLE = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_EXPECTING_VALUE = ::T.let(nil, ::T.untyped)
  KEYWORD_NEW_STATE = ::T.let(nil, ::T.untyped)
  METHOD_AFTER_DOT = ::T.let(nil, ::T.untyped)
  METHOD_NAME = ::T.let(nil, ::T.untyped)
  METHOD_NAME_EX = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OPERATOR = ::T.let(nil, ::T.untyped)
  METHOD_NAME_OR_SYMBOL = ::T.let(nil, ::T.untyped)
  METHOD_SUFFIX = ::T.let(nil, ::T.untyped)
  NUMERIC = ::T.let(nil, ::T.untyped)
  OBJECT_VARIABLE = ::T.let(nil, ::T.untyped)
  OCTAL = ::T.let(nil, ::T.untyped)
  PREDEFINED_CONSTANTS = ::T.let(nil, ::T.untyped)
  PREFIX_VARIABLE = ::T.let(nil, ::T.untyped)
  QUOTE_TO_TYPE = ::T.let(nil, ::T.untyped)
  REGEXP_MODIFIERS = ::T.let(nil, ::T.untyped)
  RUBYDOC = ::T.let(nil, ::T.untyped)
  RUBYDOC_OR_DATA = ::T.let(nil, ::T.untyped)
  SIMPLE_ESCAPE = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
  VALUE_FOLLOWS = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
end

module CodeRay::Scanners::Ruby::Patterns
end

class CodeRay::Scanners::Ruby::StringState
  def heredoc_pattern(delim, interpreted, indented); end

  def initialize(kind, interpreted, delim, heredoc=T.unsafe(nil)); end
  CLOSING_PAREN = ::T.let(nil, ::T.untyped)
  STRING_PATTERN = ::T.let(nil, ::T.untyped)
end

class CodeRay::Scanners::Ruby::StringState
  def self.simple_key_pattern(delim); end
end

class CodeRay::Scanners::Ruby
end

class CodeRay::Scanners::Scanner
  include ::Enumerable
  def binary_string(); end

  def column(pos=T.unsafe(nil)); end

  def each(&block); end

  def file_extension(); end

  def initialize(code=T.unsafe(nil), options=T.unsafe(nil)); end

  def lang(); end

  def line(pos=T.unsafe(nil)); end

  def raise_inspect(message, tokens, state=T.unsafe(nil), ambit=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def raise_inspect_arguments(message, tokens, state, ambit); end

  def reset_instance(); end

  def scan_rest(); end

  def scan_tokens(tokens, options); end

  def scanner_state_info(state); end

  def set_string_from_source(source); end

  def set_tokens_from_options(options); end

  def setup(); end

  def state(); end

  def state=(state); end

  def string=(code); end

  def tokenize(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def tokens(); end

  def tokens_last(tokens, n); end

  def tokens_size(tokens); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  KINDS_NOT_LOC = ::T.let(nil, ::T.untyped)
  SCANNER_STATE_INFO = ::T.let(nil, ::T.untyped)
  SCAN_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

CodeRay::Scanners::Scanner::PLUGIN_HOST = CodeRay::Scanners

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner::ScanError
end

class CodeRay::Scanners::Scanner
  extend ::CodeRay::Plugin
  def self.encode_with_encoding(code, target_encoding); end

  def self.encoding(name=T.unsafe(nil)); end

  def self.file_extension(extension=T.unsafe(nil)); end

  def self.guess_encoding(s); end

  def self.lang(); end

  def self.normalize(code); end

  def self.to_unix(code); end
end

module CodeRay::Scanners
  extend ::CodeRay::PluginHost
end

module CodeRay::Styles
end

class CodeRay::Styles::Style
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

CodeRay::Styles::Style::PLUGIN_HOST = CodeRay::Styles

class CodeRay::Styles::Style
  extend ::CodeRay::Plugin
end

module CodeRay::Styles
  extend ::CodeRay::PluginHost
end

class CodeRay::Tokens
  def begin_group(kind); end

  def begin_line(kind); end

  def count(); end

  def encode(encoder, options=T.unsafe(nil)); end

  def end_group(kind); end

  def end_line(kind); end

  def method_missing(meth, options=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def split_into_parts(*sizes); end

  def text_token(*_); end

  def tokens(*_); end
end

class CodeRay::Tokens
end

class CodeRay::TokensProxy
  def block(); end

  def block=(block); end

  def each(*args, &blk); end

  def encode(encoder, options=T.unsafe(nil)); end

  def initialize(input, lang, options=T.unsafe(nil), block=T.unsafe(nil)); end

  def input(); end

  def input=(input); end

  def lang(); end

  def lang=(lang); end

  def method_missing(method, *args, &blk); end

  def options(); end

  def options=(options); end

  def scanner(); end

  def tokens(); end
end

class CodeRay::TokensProxy
end

class CodeRay::WordList
  def add(words, value=T.unsafe(nil)); end

  def initialize(default=T.unsafe(nil)); end
end

class CodeRay::WordList::CaseIgnoring
  def [](key); end

  def []=(key, value); end
end

class CodeRay::WordList::CaseIgnoring
end

class CodeRay::WordList
end

module CodeRay
  def self.coderay_path(*path); end

  def self.encode(code, lang, format, options=T.unsafe(nil)); end

  def self.encode_file(filename, format, options=T.unsafe(nil)); end

  def self.encode_tokens(tokens, format, options=T.unsafe(nil)); end

  def self.encoder(format, options=T.unsafe(nil)); end

  def self.get_scanner_options(options); end

  def self.highlight(code, lang, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.highlight_file(filename, options=T.unsafe(nil), format=T.unsafe(nil)); end

  def self.scan(code, lang, options=T.unsafe(nil), &block); end

  def self.scan_file(filename, lang=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.scanner(lang, options=T.unsafe(nil), &block); end
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(_); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def chain(*_); end

  def sum(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Exception
  def __bb_context(); end
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class File
  def self.exists?(_); end
end

FileList = Rake::FileList

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, &block); end

  def safe_ln(*args); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
  def _deprecated_add_found_dependencies(to_do, dependency_list); end

  def _deprecated_gather_dependencies(); end

  def add_found_dependencies(*args, &block); end

  def gather_dependencies(*args, &block); end
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  def self.redirector(); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Resolver::ActivationRequest
  def others_possible?(); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def to_ruby(); end
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.remove_spec(spec); end
end

class Gem::SpecificationPolicy
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.default_gems_use_full_paths?(); end

  def self.remove_unresolved_default_spec(spec); end
end

module GraphQL
  BOOLEAN_TYPE = ::T.let(nil, ::T.untyped)
  FLOAT_TYPE = ::T.let(nil, ::T.untyped)
  ID_TYPE = ::T.let(nil, ::T.untyped)
  INT_TYPE = ::T.let(nil, ::T.untyped)
  STRING_TYPE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module GraphQL::Analysis
end

module GraphQL::Analysis::AST
end

class GraphQL::Analysis::AST::Analyzer
  def analyze?(); end

  def initialize(subject); end

  def multiplex(); end

  def on_enter_abstract_node(node, parent, visitor); end

  def on_enter_argument(node, parent, visitor); end

  def on_enter_directive(node, parent, visitor); end

  def on_enter_document(node, parent, visitor); end

  def on_enter_enum(node, parent, visitor); end

  def on_enter_field(node, parent, visitor); end

  def on_enter_fragment_spread(node, parent, visitor); end

  def on_enter_inline_fragment(node, parent, visitor); end

  def on_enter_input_object(node, parent, visitor); end

  def on_enter_list_type(node, parent, visitor); end

  def on_enter_non_null_type(node, parent, visitor); end

  def on_enter_null_value(node, parent, visitor); end

  def on_enter_operation_definition(node, parent, visitor); end

  def on_enter_type_name(node, parent, visitor); end

  def on_enter_variable_definition(node, parent, visitor); end

  def on_enter_variable_identifier(node, parent, visitor); end

  def on_leave_abstract_node(node, parent, visitor); end

  def on_leave_argument(node, parent, visitor); end

  def on_leave_directive(node, parent, visitor); end

  def on_leave_document(node, parent, visitor); end

  def on_leave_enum(node, parent, visitor); end

  def on_leave_field(node, parent, visitor); end

  def on_leave_fragment_spread(node, parent, visitor); end

  def on_leave_inline_fragment(node, parent, visitor); end

  def on_leave_input_object(node, parent, visitor); end

  def on_leave_list_type(node, parent, visitor); end

  def on_leave_non_null_type(node, parent, visitor); end

  def on_leave_null_value(node, parent, visitor); end

  def on_leave_operation_definition(node, parent, visitor); end

  def on_leave_type_name(node, parent, visitor); end

  def on_leave_variable_definition(node, parent, visitor); end

  def on_leave_variable_identifier(node, parent, visitor); end

  def query(); end

  def result(); end

  def subject(); end
end

class GraphQL::Analysis::AST::Analyzer
end

class GraphQL::Analysis::AST::FieldUsage
  def initialize(query); end
end

class GraphQL::Analysis::AST::FieldUsage
end

class GraphQL::Analysis::AST::MaxQueryComplexity
end

class GraphQL::Analysis::AST::MaxQueryComplexity
end

class GraphQL::Analysis::AST::MaxQueryDepth
end

class GraphQL::Analysis::AST::MaxQueryDepth
end

class GraphQL::Analysis::AST::QueryComplexity
  def initialize(query); end
end

class GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity
  def field_definition(); end

  def initialize(node, field_definition, query, response_path); end

  def own_complexity(child_complexity); end

  def query(); end

  def response_path(); end

  def scoped_children(); end

  def terminal?(); end
  HASH_CHILDREN = ::T.let(nil, ::T.untyped)
end

class GraphQL::Analysis::AST::QueryComplexity::ScopedTypeComplexity
end

class GraphQL::Analysis::AST::QueryComplexity
end

class GraphQL::Analysis::AST::QueryDepth
  def initialize(query); end
end

class GraphQL::Analysis::AST::QueryDepth
end

class GraphQL::Analysis::AST::Visitor
  def argument_definition(); end

  def arguments_for(ast_node, field_definition); end

  def directive_definition(); end

  def field_definition(); end

  def initialize(query:, analyzers:); end

  def object_types(); end

  def parent_type_definition(); end

  def previous_argument_definition(); end

  def previous_field_definition(); end

  def query(); end

  def response_path(); end

  def skipping?(); end

  def type_definition(); end

  def visiting_fragment_definition?(); end
end

class GraphQL::Analysis::AST::Visitor
end

module GraphQL::Analysis::AST
  def self.analysis_errors(results); end

  def self.analyze_multiplex(multiplex, analyzers); end

  def self.analyze_query(query, analyzers, multiplex_analyzers: T.unsafe(nil)); end

  def self.use(schema_class); end
end

class GraphQL::Analysis::FieldUsage
  def call(memo, visit_type, irep_node); end

  def final_value(memo); end

  def initial_value(query); end

  def initialize(&block); end
end

class GraphQL::Analysis::FieldUsage
end

class GraphQL::Analysis::MaxQueryComplexity
  def initialize(max_complexity); end
end

class GraphQL::Analysis::MaxQueryComplexity
end

class GraphQL::Analysis::MaxQueryDepth
  def initialize(max_depth); end
end

class GraphQL::Analysis::MaxQueryDepth
end

class GraphQL::Analysis::QueryComplexity
  def call(memo, visit_type, irep_node); end

  def final_value(reduced_value); end

  def initial_value(target); end

  def initialize(&block); end
end

class GraphQL::Analysis::QueryComplexity::TypeComplexity
  def max_possible_complexity(); end

  def merge(type_defn, complexity); end
end

class GraphQL::Analysis::QueryComplexity::TypeComplexity
end

class GraphQL::Analysis::QueryComplexity
end

class GraphQL::Analysis::QueryDepth
  def call(memo, visit_type, irep_node); end

  def final_value(memo); end

  def initial_value(query); end

  def initialize(&block); end
end

class GraphQL::Analysis::QueryDepth
end

class GraphQL::Analysis::ReducerState
  def call(visit_type, irep_node); end

  def errors(); end

  def errors=(errors); end

  def finalize_reducer(); end

  def initialize(reducer, query); end

  def memo(); end

  def memo=(memo); end

  def reducer(); end
end

class GraphQL::Analysis::ReducerState
end

module GraphQL::Analysis
  def self.analysis_errors(results); end

  def self.analyze_multiplex(multiplex, analyzers); end

  def self.analyze_query(query, analyzers, multiplex_states: T.unsafe(nil)); end

  def self.reduce_node(irep_node, reducer_states); end

  def self.visit_analyzers(visit_type, irep_node, reducer_states); end
end

class GraphQL::AnalysisError
end

class GraphQL::AnalysisError
end

class GraphQL::Argument
  include ::GraphQL::Define::InstanceDefinable
  def as(); end

  def as=(as); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def default_value(); end

  def default_value=(new_default_value); end

  def default_value?(); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def expose_as(); end

  def graphql_name(); end

  def keyword(); end

  def method_access(); end

  def method_access=(method_access); end

  def method_access?(); end

  def name(); end

  def name=(name); end

  def prepare(value, ctx); end

  def prepare=(prepare_proc); end

  def type(); end

  def type=(new_input_type); end

  def type_class(); end
  NO_DEFAULT_VALUE = ::T.let(nil, ::T.untyped)
end

module GraphQL::Argument::DefaultPrepare
end

module GraphQL::Argument::DefaultPrepare
  def self.call(value, ctx); end
end

class GraphQL::Argument
  def self.deep_stringify(val); end

  def self.from_dsl(name, type_or_argument=T.unsafe(nil), description=T.unsafe(nil), default_value: T.unsafe(nil), as: T.unsafe(nil), prepare: T.unsafe(nil), **kwargs, &block); end
end

module GraphQL::Authorization
end

module GraphQL::Authorization::Analyzer
end

module GraphQL::Authorization::Analyzer
  def self.call(memo, visit_type, irep_node); end

  def self.final_value(memo); end

  def self.initial_value(query); end
end

class GraphQL::Authorization::InaccessibleFieldsError
  def context(); end

  def fields(); end

  def initialize(fields:, irep_nodes:, context:); end

  def irep_nodes(); end
end

class GraphQL::Authorization::InaccessibleFieldsError
end

module GraphQL::Authorization
end

class GraphQL::Backtrace
  include ::Enumerable
  def [](*args, &block); end

  def each(*args, &block); end

  def initialize(context, value: T.unsafe(nil)); end

  def to_a(); end
end

module GraphQL::Backtrace::InspectResult
end

module GraphQL::Backtrace::InspectResult
  def self.inspect_result(obj); end

  def self.inspect_truncated(obj); end
end

class GraphQL::Backtrace::Table
  def initialize(context, value:); end

  def to_backtrace(); end

  def to_table(); end
  HEADERS = ::T.let(nil, ::T.untyped)
  MAX_COL_WIDTH = ::T.let(nil, ::T.untyped)
  MIN_COL_WIDTH = ::T.let(nil, ::T.untyped)
end

class GraphQL::Backtrace::Table
end

class GraphQL::Backtrace::TracedError
  def context(); end

  def graphql_backtrace(); end

  def initialize(err, current_ctx); end
  CAUSE_BACKTRACE_PREVIEW_LENGTH = ::T.let(nil, ::T.untyped)
  MESSAGE_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Backtrace::TracedError
end

module GraphQL::Backtrace::Tracer
end

module GraphQL::Backtrace::Tracer
  def self.trace(key, metadata); end
end

class GraphQL::Backtrace
  extend ::Forwardable
  def self.disable(); end

  def self.enable(); end

  def self.use(schema_defn); end
end

module GraphQL::BackwardsCompatibility
end

class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  def call(*args); end

  def initialize(callable, old_arity); end
end

class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
end

class GraphQL::BackwardsCompatibility::LastArgumentsWrapper
end

class GraphQL::BackwardsCompatibility::LastArgumentsWrapper
end

module GraphQL::BackwardsCompatibility
  def self.get_arity(callable); end

  def self.wrap_arity(callable, from:, to:, name:, last: T.unsafe(nil)); end
end

class GraphQL::BaseType
  include ::GraphQL::Define::NonNullWithBang
  include ::GraphQL::Define::InstanceDefinable
  include ::GraphQL::Relay::TypeExtensions
  def ==(other); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def coerce_input(value, ctx=T.unsafe(nil)); end

  def coerce_isolated_input(value); end

  def coerce_isolated_result(value); end

  def coerce_result(value, ctx); end

  def default_relay=(default_relay); end

  def default_relay?(); end

  def default_scalar=(default_scalar); end

  def default_scalar?(); end

  def description(); end

  def description=(description); end

  def get_field(name); end

  def graphql_definition(); end

  def graphql_name(); end

  def introspection=(introspection); end

  def introspection?(); end

  def list?(); end

  def name(); end

  def name=(name); end

  def non_null?(); end

  def resolve_type(value, ctx); end

  def to_definition(schema, printer: T.unsafe(nil), **args); end

  def to_list_type(); end

  def to_non_null_type(); end

  def to_type_signature(); end

  def type_class(); end

  def unwrap(); end

  def valid_input?(value, ctx=T.unsafe(nil)); end

  def valid_isolated_input?(value); end

  def validate_input(value, ctx=T.unsafe(nil)); end

  def validate_isolated_input(value); end
end

module GraphQL::BaseType::ModifiesAnotherType
  def ==(other); end

  def unwrap(); end
end

module GraphQL::BaseType::ModifiesAnotherType
end

class GraphQL::BaseType
  def self.resolve_related_type(type_arg); end
end

class GraphQL::CoercionError
  def extensions(); end

  def extensions=(extensions); end

  def initialize(message, extensions: T.unsafe(nil)); end
end

class GraphQL::CoercionError
end

module GraphQL::Compatibility
end

module GraphQL::Compatibility::ExecutionSpecification
end

module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
end

module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  BOGUS_NODE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
end

class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
  def each(&block); end

  def initialize(storage); end
end

class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
  def self.call(parent_type, parent_object, field_definition, field_args, query_context, &next_middleware); end
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::ExecutionSpecification
  def self.build_suite(execution_strategy); end
end

module GraphQL::Compatibility::LazyExecutionSpecification
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
  def self.instrument(type, field); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
  def initialize(ctx, value); end

  def push(); end

  def value(); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
  def initialize(ctx, values); end

  def push(); end

  def value(); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::LazyExecutionSpecification
  def self.build_suite(execution_strategy); end
end

module GraphQL::Compatibility::QueryParserSpecification
  QUERY_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
  def assert_raises_parse_error(query_string); end

  def assert_rejects_character(char); end

  def test_it_includes_line_and_column(); end

  def test_it_rejects_bad_unicode(); end

  def test_it_rejects_blank_queries(); end

  def test_it_rejects_empty_inline_fragments(); end

  def test_it_rejects_invalid_characters(); end

  def test_it_rejects_unexpected_ends(); end

  def test_it_rejects_unterminated_strings(); end

  def test_it_restricts_on(); end
end

module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
end

module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
  def assert_valid_directive(directive); end

  def assert_valid_field(field); end

  def assert_valid_fragment(fragment_def); end

  def assert_valid_fragment_spread(fragment_spread); end

  def assert_valid_literal_argument(argument); end

  def assert_valid_query(query); end

  def assert_valid_typed_inline_fragment(inline_fragment); end

  def assert_valid_typeless_inline_fragment(inline_fragment); end

  def assert_valid_variable(variable); end

  def assert_valid_variable_argument(argument); end
end

module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
end

module GraphQL::Compatibility::QueryParserSpecification
  def self.build_suite(&block); end
end

module GraphQL::Compatibility::SchemaParserSpecification
  SCHEMA_DEFINITION_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Compatibility::SchemaParserSpecification
  def self.build_suite(&block); end
end

module GraphQL::Compatibility
end

module GraphQL::Define
end

module GraphQL::Define::AssignArgument
end

module GraphQL::Define::AssignArgument
  def self.call(target, *args, **kwargs, &block); end
end

module GraphQL::Define::AssignConnection
end

module GraphQL::Define::AssignConnection
  def self.call(type_defn, *field_args, max_page_size: T.unsafe(nil), **field_kwargs, &field_block); end
end

module GraphQL::Define::AssignEnumValue
end

module GraphQL::Define::AssignEnumValue
  def self.call(enum_type, name, desc=T.unsafe(nil), deprecation_reason: T.unsafe(nil), value: T.unsafe(nil), &block); end
end

module GraphQL::Define::AssignGlobalIdField
end

module GraphQL::Define::AssignGlobalIdField
  def self.call(type_defn, field_name, **field_kwargs); end
end

module GraphQL::Define::AssignMutationFunction
end

class GraphQL::Define::AssignMutationFunction::ResultProxy
  def client_mutation_id(); end

  def initialize(target, client_mutation_id); end
end

class GraphQL::Define::AssignMutationFunction::ResultProxy
end

module GraphQL::Define::AssignMutationFunction
  def self.call(target, function); end
end

module GraphQL::Define::AssignObjectField
end

module GraphQL::Define::AssignObjectField
  def self.call(owner_type, name, type_or_field=T.unsafe(nil), desc=T.unsafe(nil), function: T.unsafe(nil), field: T.unsafe(nil), relay_mutation_function: T.unsafe(nil), **kwargs, &block); end
end

class GraphQL::Define::DefinedObjectProxy
  def initialize(target); end

  def method_missing(name, *args, &block); end

  def target(); end

  def types(); end

  def use(plugin, **kwargs); end
end

class GraphQL::Define::DefinedObjectProxy
  extend ::GraphQL::Ruby2Keywords
end

module GraphQL::Define::InstanceDefinable
  def define(**kwargs, &block); end

  def metadata(); end

  def redefine(**kwargs, &block); end
end

module GraphQL::Define::InstanceDefinable
  def self.included(base); end
end

class GraphQL::Define::NoDefinitionError
end

class GraphQL::Define::NoDefinitionError
end

module GraphQL::Define::NonNullWithBang
  def !(); end
end

module GraphQL::Define::NonNullWithBang
end

class GraphQL::Define::TypeDefiner
  include ::Singleton
  def Boolean(); end

  def Float(); end

  def ID(); end

  def Int(); end

  def String(); end

  def [](type); end
end

class GraphQL::Define::TypeDefiner
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module GraphQL::Define
  def self.assign_metadata_key(key); end
end

module GraphQL::DeprecatedDSL
  TYPE_CLASSES = ::T.let(nil, ::T.untyped)
end

module GraphQL::DeprecatedDSL::Methods
  def !(); end
end

module GraphQL::DeprecatedDSL::Methods
end

module GraphQL::DeprecatedDSL
  def self.activate(); end
end

module GraphQL::Dig
  def dig(own_key, *rest_keys); end
end

module GraphQL::Dig
end

class GraphQL::Directive
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def default_directive=(default_directive); end

  def default_directive?(); end

  def description(); end

  def description=(description); end

  def get_argument(argument_name); end

  def graphql_definition(); end

  def graphql_name(); end

  def locations(); end

  def locations=(locations); end

  def name(); end

  def name=(name); end

  def on_field?(); end

  def on_fragment?(); end

  def on_operation?(); end

  def type_class(); end
  ARGUMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  DeprecatedDirective = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_VALUE = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_SPREAD = ::T.let(nil, ::T.untyped)
  INLINE_FRAGMENT = ::T.let(nil, ::T.untyped)
  INPUT_FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  INPUT_OBJECT = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  IncludeDirective = ::T.let(nil, ::T.untyped)
  LOCATIONS = ::T.let(nil, ::T.untyped)
  LOCATION_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  MUTATION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCALAR = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  SUBSCRIPTION = ::T.let(nil, ::T.untyped)
  SkipDirective = ::T.let(nil, ::T.untyped)
  UNION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Directive
end

class GraphQL::EnumType
  def add_value(enum_value); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def kind(); end

  def values(); end

  def values=(new_values); end
end

class GraphQL::EnumType::EnumValue
  include ::GraphQL::Define::InstanceDefinable
  def ast_node(); end

  def ast_node=(ast_node); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def graphql_name(); end

  def name(); end

  def name=(new_name); end

  def type_class(); end

  def value(); end

  def value=(value); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class GraphQL::EnumType::EnumValue
end

class GraphQL::EnumType::UnresolvedValueError
end

class GraphQL::EnumType::UnresolvedValueError
end

class GraphQL::EnumType
end

class GraphQL::Error
end

class GraphQL::Error
end

module GraphQL::Execution
end

module GraphQL::Execution::DirectiveChecks
  INCLUDE = ::T.let(nil, ::T.untyped)
  SKIP = ::T.let(nil, ::T.untyped)
end

module GraphQL::Execution::DirectiveChecks
  def self.include?(directive_ast_nodes, query); end
end

class GraphQL::Execution::Errors
  def initialize(schema); end

  def with_error_handling(ctx); end
end

class GraphQL::Execution::Errors::NullErrorHandler
end

class GraphQL::Execution::Errors::NullErrorHandler
  def self.with_error_handling(_ctx); end
end

class GraphQL::Execution::Errors
  def self.use(schema); end
end

class GraphQL::Execution::Execute
  include ::GraphQL::Execution::Execute::ExecutionFunctions
  def execute(ast_operation, root_type, query); end
  PROPAGATE_NULL = ::T.let(nil, ::T.untyped)
  SKIP = ::T.let(nil, ::T.untyped)
end

module GraphQL::Execution::Execute::ExecutionFunctions
end

module GraphQL::Execution::Execute::ExecutionFunctions
  def self.continue_or_wait(raw_value, field_type, field_ctx); end

  def self.continue_resolve_field(raw_value, field_type, field_ctx); end

  def self.lazy_resolve_root_selection(result, query: T.unsafe(nil), multiplex: T.unsafe(nil)); end

  def self.resolve_field(object, field_ctx); end

  def self.resolve_root_selection(query); end

  def self.resolve_selection(object, current_type, current_ctx, mutation: T.unsafe(nil)); end

  def self.resolve_value(value, field_type, field_ctx); end
end

module GraphQL::Execution::Execute::FieldResolveStep
end

module GraphQL::Execution::Execute::FieldResolveStep
  def self.call(_parent_type, parent_object, field_definition, field_args, context, _next=T.unsafe(nil)); end
end

class GraphQL::Execution::Execute::PropagateNull
end

class GraphQL::Execution::Execute::PropagateNull
end

class GraphQL::Execution::Execute::Skip
end

class GraphQL::Execution::Execute::Skip
end

class GraphQL::Execution::Execute
  def self.begin_multiplex(_multiplex); end

  def self.begin_query(query, _multiplex); end

  def self.finish_multiplex(results, multiplex); end

  def self.finish_query(query, _multiplex); end
end

module GraphQL::Execution::Flatten
end

module GraphQL::Execution::Flatten
  def self.call(ctx); end
end

module GraphQL::Execution::Instrumentation
end

module GraphQL::Execution::Instrumentation
  def self.apply_instrumenters(multiplex); end
end

class GraphQL::Execution::Interpreter
  def evaluate(query); end

  def execute(_operation, _root_type, query); end

  def sync_lazies(query: T.unsafe(nil), multiplex: T.unsafe(nil)); end
end

class GraphQL::Execution::Interpreter::ArgumentValue
  def default_used?(); end

  def definition(); end

  def initialize(definition:, value:, default_used:); end

  def value(); end
end

class GraphQL::Execution::Interpreter::ArgumentValue
end

class GraphQL::Execution::Interpreter::Arguments
  include ::GraphQL::Dig
  def [](*args, &block); end

  def argument_values(); end

  def each(*args, &block); end

  def each_value(*args, &block); end

  def fetch(*args, &block); end

  def initialize(keyword_arguments:, argument_values:); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def keyword_arguments(); end

  def values(*args, &block); end
end

class GraphQL::Execution::Interpreter::Arguments
  extend ::Forwardable
end

class GraphQL::Execution::Interpreter::ArgumentsCache
  def fetch(ast_node, argument_owner, parent_object); end

  def initialize(query); end
  NO_VALUE_GIVEN = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Interpreter::ArgumentsCache
end

class GraphQL::Execution::Interpreter::ExecutionErrors
  def add(err_or_msg); end

  def initialize(ctx, ast_node, path); end
end

class GraphQL::Execution::Interpreter::ExecutionErrors
end

module GraphQL::Execution::Interpreter::HandlesRawValue
  def raw_value(obj); end
end

module GraphQL::Execution::Interpreter::HandlesRawValue
end

class GraphQL::Execution::Interpreter::HashResponse
  def final_value(); end

  def write(path, value); end
end

class GraphQL::Execution::Interpreter::HashResponse
end

class GraphQL::Execution::Interpreter::ListResultFailedError
  def initialize(value:, path:, field:); end
end

class GraphQL::Execution::Interpreter::ListResultFailedError
end

class GraphQL::Execution::Interpreter::RawValue
  def initialize(obj=T.unsafe(nil)); end

  def resolve(); end
end

class GraphQL::Execution::Interpreter::RawValue
end

module GraphQL::Execution::Interpreter::Resolve
end

module GraphQL::Execution::Interpreter::Resolve
  def self.resolve(results); end

  def self.resolve_all(results); end
end

class GraphQL::Execution::Interpreter::Runtime
  def add_dead_path(path); end

  def after_lazy(lazy_obj, owner:, field:, path:, scoped_context:, owner_object:, arguments:, eager: T.unsafe(nil), trace: T.unsafe(nil), &block); end

  def arguments(graphql_object, arg_owner, ast_node); end

  def authorized_new(type, value, context, path); end

  def context(); end

  def continue_field(path, value, owner_type, field, current_type, ast_node, next_selections, is_non_null, owner_object, arguments); end

  def continue_value(path, value, parent_type, field, is_non_null, ast_node); end

  def dead_path?(path); end

  def delete_interpreter_context(key); end

  def directives_include?(node, graphql_object, parent_type); end

  def evaluate_selections(path, scoped_context, owner_object, owner_type, selections, root_operation_type: T.unsafe(nil)); end

  def final_value(); end

  def gather_selections(owner_object, owner_type, selections, selections_by_name); end

  def initialize(query:, response:); end

  def query(); end

  def resolve_type(type, value, path); end

  def resolve_with_directives(object, ast_node, &block); end

  def run_directive(object, ast_node, idx, &block); end

  def run_eager(); end

  def schema(); end

  def set_interpreter_context(key, value); end

  def set_type_at_path(path, type); end

  def type_at(path); end

  def write_execution_errors_in_response(path, errors); end

  def write_in_response(path, value); end

  def write_invalid_null_in_response(path, invalid_null_error); end
  HALT = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Interpreter::Runtime
end

class GraphQL::Execution::Interpreter
  def self.begin_multiplex(multiplex); end

  def self.begin_query(query, multiplex); end

  def self.finish_multiplex(_results, multiplex); end

  def self.finish_query(query, _multiplex); end

  def self.use(schema_class); end
end

class GraphQL::Execution::Lazy
  def field(); end

  def initialize(path: T.unsafe(nil), field: T.unsafe(nil), &get_value_func); end

  def path(); end

  def value(); end
  NullResult = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Lazy::LazyMethodMap
  def each(&blk); end

  def get(value); end

  def initialize(use_concurrent: T.unsafe(nil)); end

  def set(lazy_class, lazy_value_method); end

  def storage(); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  def []=(key, value); end

  def compute_if_absent(key); end

  def copy_storage(); end

  def each_pair(*args, &block); end

  def size(*args, &block); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  extend ::Forwardable
end

class GraphQL::Execution::Lazy::LazyMethodMap
end

module GraphQL::Execution::Lazy::Resolve
end

module GraphQL::Execution::Lazy::Resolve::NullAccumulator
end

module GraphQL::Execution::Lazy::Resolve::NullAccumulator
  def self.<<(item); end

  def self.empty?(); end
end

module GraphQL::Execution::Lazy::Resolve
  def self.deep_sync(val); end

  def self.each_lazy(acc, value); end

  def self.resolve(value); end

  def self.resolve_in_place(value); end
end

class GraphQL::Execution::Lazy
  def self.all(lazies); end

  def self.resolve(val); end
end

class GraphQL::Execution::Lookahead
  def arguments(); end

  def ast_nodes(); end

  def field(); end

  def initialize(query:, ast_nodes:, field: T.unsafe(nil), root_type: T.unsafe(nil), owner_type: T.unsafe(nil)); end

  def name(); end

  def owner_type(); end

  def selected?(); end

  def selection(field_name, selected_type: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def selections(arguments: T.unsafe(nil)); end

  def selects?(field_name, arguments: T.unsafe(nil)); end
  NULL_LOOKAHEAD = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Lookahead::NullLookahead
  def initialize(); end

  def selection(*_); end

  def selections(*_); end

  def selects?(*_); end
end

class GraphQL::Execution::Lookahead::NullLookahead
end

class GraphQL::Execution::Lookahead
end

class GraphQL::Execution::Multiplex
  include ::GraphQL::Tracing::Traceable
  def context(); end

  def initialize(schema:, queries:, context:, max_complexity:); end

  def max_complexity(); end

  def queries(); end

  def schema(); end
  NO_OPERATION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Multiplex
  def self.run_all(schema, query_options, **kwargs); end

  def self.run_queries(schema, queries, context: T.unsafe(nil), max_complexity: T.unsafe(nil)); end
end

module GraphQL::Execution::Typecast
end

module GraphQL::Execution::Typecast
  def self.subtype?(parent_type, child_type); end
end

module GraphQL::Execution
end

class GraphQL::ExecutionError
  def ast_node(); end

  def ast_node=(ast_node); end

  def extensions(); end

  def extensions=(extensions); end

  def initialize(message, ast_node: T.unsafe(nil), options: T.unsafe(nil), extensions: T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def path(); end

  def path=(path); end

  def to_h(); end
end

class GraphQL::ExecutionError
end

class GraphQL::Field
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def complexity(); end

  def complexity=(complexity); end

  def connection=(connection); end

  def connection?(); end

  def connection_max_page_size(); end

  def connection_max_page_size=(connection_max_page_size); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def edge_class(); end

  def edge_class=(edge_class); end

  def edges?(); end

  def function(); end

  def function=(function); end

  def get_argument(argument_name); end

  def graphql_definition(); end

  def graphql_name(); end

  def hash_key(); end

  def hash_key=(new_hash_key); end

  def introspection=(introspection); end

  def introspection?(); end

  def lazy_resolve(obj, args, ctx); end

  def lazy_resolve=(new_lazy_resolve_proc); end

  def lazy_resolve_proc(); end

  def mutation(); end

  def mutation=(mutation); end

  def name(); end

  def name=(new_name); end

  def prepare_lazy(obj, args, ctx); end

  def property(); end

  def property=(new_property); end

  def relay_node_field(); end

  def relay_node_field=(relay_node_field); end

  def relay_nodes_field(); end

  def relay_nodes_field=(relay_nodes_field); end

  def resolve(object, arguments, context); end

  def resolve=(new_resolve_proc); end

  def resolve_proc(); end

  def subscription_scope(); end

  def subscription_scope=(subscription_scope); end

  def trace(); end

  def trace=(trace); end

  def type(); end

  def type=(new_return_type); end

  def type_class(); end
end

module GraphQL::Field::DefaultLazyResolve
end

module GraphQL::Field::DefaultLazyResolve
  def self.call(obj, args, ctx); end
end

module GraphQL::Field::Resolve
end

class GraphQL::Field::Resolve::BuiltInResolve
end

class GraphQL::Field::Resolve::BuiltInResolve
end

class GraphQL::Field::Resolve::HashKeyResolve
  def call(obj, args, ctx); end

  def initialize(hash_key); end
end

class GraphQL::Field::Resolve::HashKeyResolve
end

class GraphQL::Field::Resolve::MethodResolve
  def call(obj, args, ctx); end

  def initialize(field); end
end

class GraphQL::Field::Resolve::MethodResolve
end

class GraphQL::Field::Resolve::NameResolve
  def call(obj, args, ctx); end

  def initialize(field); end
end

class GraphQL::Field::Resolve::NameResolve
end

module GraphQL::Field::Resolve
  def self.create_proc(field); end
end

class GraphQL::Field
end

class GraphQL::Filter
  def call(member, ctx); end

  def initialize(only: T.unsafe(nil), except: T.unsafe(nil)); end

  def merge(only: T.unsafe(nil), except: T.unsafe(nil)); end
end

class GraphQL::Filter::MergedExcept
end

class GraphQL::Filter::MergedExcept
end

class GraphQL::Filter::MergedOnly
  def call(member, ctx); end

  def initialize(first, second); end
end

class GraphQL::Filter::MergedOnly
  def self.build(onlies); end
end

class GraphQL::Filter
end

class GraphQL::Function
  def arguments(); end

  def call(obj, args, ctx); end

  def complexity(); end

  def deprecation_reason(); end

  def description(); end

  def type(); end
end

class GraphQL::Function
  def self.argument(*args, **kwargs, &block); end

  def self.arguments(); end

  def self.build_field(function); end

  def self.complexity(new_value=T.unsafe(nil)); end

  def self.deprecation_reason(new_value=T.unsafe(nil)); end

  def self.description(new_value=T.unsafe(nil)); end

  def self.type(premade_type=T.unsafe(nil), &block); end

  def self.types(); end
end

class GraphQL::InputObjectType
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def get_argument(argument_name); end

  def input_fields(); end

  def kind(); end

  def mutation(); end

  def mutation=(mutation); end
  INVALID_OBJECT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class GraphQL::InputObjectType
end

class GraphQL::IntegerEncodingError
  def initialize(value); end

  def integer_value(); end
end

class GraphQL::IntegerEncodingError
end

class GraphQL::InterfaceType
  def all_fields(); end

  def fields(); end

  def fields=(fields); end

  def get_field(field_name); end

  def get_possible_type(type_name, ctx); end

  def kind(); end

  def orphan_types(); end

  def orphan_types=(orphan_types); end

  def possible_type?(type, ctx); end

  def resolve_type=(resolve_type_callable); end

  def resolve_type_proc(); end

  def resolve_type_proc=(resolve_type_proc); end

  def type_membership_class(); end

  def type_membership_class=(type_membership_class); end
end

class GraphQL::InterfaceType
end

module GraphQL::InternalRepresentation
end

class GraphQL::InternalRepresentation::Document
  def [](key); end

  def each(&block); end

  def fragment_definitions(); end

  def operation_definitions(); end
end

class GraphQL::InternalRepresentation::Document
end

class GraphQL::InternalRepresentation::Node
  def ==(other); end

  def arguments(); end

  def ast_node(); end

  def ast_nodes(); end

  def deep_merge_node(new_parent, scope: T.unsafe(nil), merge_self: T.unsafe(nil)); end

  def definition(); end

  def definition_name(); end

  def definitions(); end

  def initialize(name:, owner_type:, query:, return_type:, parent:, ast_nodes: T.unsafe(nil), definitions: T.unsafe(nil)); end

  def name(); end

  def owner_type(); end

  def owner_type=(owner_type); end

  def parent(); end

  def parent=(parent); end

  def query(); end

  def return_type(); end

  def scoped_children(); end

  def subscription_topic(); end

  def typed_children(); end
  DEFAULT_TYPED_CHILDREN = ::T.let(nil, ::T.untyped)
  NO_TYPED_CHILDREN = ::T.let(nil, ::T.untyped)
end

class GraphQL::InternalRepresentation::Node
end

module GraphQL::InternalRepresentation::Print
end

module GraphQL::InternalRepresentation::Print
  def self.print(schema, query_string); end

  def self.print_node(node, indent: T.unsafe(nil)); end
end

module GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language
  def initialize(*_); end

  def on_field(ast_node, ast_parent); end

  def on_fragment_definition(ast_node, parent); end

  def on_fragment_spread(ast_node, ast_parent); end

  def on_inline_fragment(node, parent); end

  def on_operation_definition(ast_node, parent); end

  def operations(); end

  def push_root_node(ast_node, definitions); end

  def rewrite_document(); end

  def skip?(ast_node); end
  NO_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

module GraphQL::InternalRepresentation::Rewrite
end

class GraphQL::InternalRepresentation::Scope
  def each(&block); end

  def enter(other_type_defn); end

  def initialize(query, type_defn); end
  NO_TYPES = ::T.let(nil, ::T.untyped)
end

class GraphQL::InternalRepresentation::Scope
end

module GraphQL::InternalRepresentation::Visit
end

module GraphQL::InternalRepresentation::Visit
  def self.each_node(node, &block); end

  def self.visit_each_node(operations, handlers); end
end

module GraphQL::InternalRepresentation
end

module GraphQL::Introspection
  INTROSPECTION_QUERY = ::T.let(nil, ::T.untyped)
end

class GraphQL::Introspection::BaseObject
end

class GraphQL::Introspection::BaseObject::InvalidNullError
end

class GraphQL::Introspection::BaseObject::InvalidNullError
end

class GraphQL::Introspection::BaseObject
end

class GraphQL::Introspection::DirectiveLocationEnum
end

class GraphQL::Introspection::DirectiveLocationEnum::UnresolvedValueError
end

class GraphQL::Introspection::DirectiveLocationEnum::UnresolvedValueError
end

class GraphQL::Introspection::DirectiveLocationEnum
end

class GraphQL::Introspection::DirectiveType
  def args(); end
end

class GraphQL::Introspection::DirectiveType::InvalidNullError
end

class GraphQL::Introspection::DirectiveType::InvalidNullError
end

class GraphQL::Introspection::DirectiveType
end

class GraphQL::Introspection::DynamicFields
  def __typename(irep_node: T.unsafe(nil)); end
end

class GraphQL::Introspection::DynamicFields::InvalidNullError
end

class GraphQL::Introspection::DynamicFields::InvalidNullError
end

class GraphQL::Introspection::DynamicFields
end

class GraphQL::Introspection::EntryPoints
  def __schema(); end

  def __type(name:); end
end

class GraphQL::Introspection::EntryPoints::InvalidNullError
end

class GraphQL::Introspection::EntryPoints::InvalidNullError
end

class GraphQL::Introspection::EntryPoints
end

class GraphQL::Introspection::EnumValueType
  def is_deprecated(); end

  def name(); end
end

class GraphQL::Introspection::EnumValueType::InvalidNullError
end

class GraphQL::Introspection::EnumValueType::InvalidNullError
end

class GraphQL::Introspection::EnumValueType
end

class GraphQL::Introspection::FieldType
  def args(include_deprecated:); end

  def is_deprecated(); end
end

class GraphQL::Introspection::FieldType::InvalidNullError
end

class GraphQL::Introspection::FieldType::InvalidNullError
end

class GraphQL::Introspection::FieldType
end

class GraphQL::Introspection::InputValueType
  def default_value(); end

  def is_deprecated(); end
end

class GraphQL::Introspection::InputValueType::InvalidNullError
end

class GraphQL::Introspection::InputValueType::InvalidNullError
end

class GraphQL::Introspection::InputValueType
end

class GraphQL::Introspection::SchemaType
  def directives(); end

  def mutation_type(); end

  def query_type(); end

  def subscription_type(); end

  def types(); end
end

class GraphQL::Introspection::SchemaType::InvalidNullError
end

class GraphQL::Introspection::SchemaType::InvalidNullError
end

class GraphQL::Introspection::SchemaType
end

class GraphQL::Introspection::TypeKindEnum
end

class GraphQL::Introspection::TypeKindEnum::UnresolvedValueError
end

class GraphQL::Introspection::TypeKindEnum::UnresolvedValueError
end

class GraphQL::Introspection::TypeKindEnum
end

class GraphQL::Introspection::TypeType
  def enum_values(include_deprecated:); end

  def fields(include_deprecated:); end

  def input_fields(include_deprecated:); end

  def interfaces(); end

  def kind(); end

  def name(); end

  def of_type(); end

  def possible_types(); end
end

class GraphQL::Introspection::TypeType::InvalidNullError
end

class GraphQL::Introspection::TypeType::InvalidNullError
end

class GraphQL::Introspection::TypeType
end

module GraphQL::Introspection
  def self.query(include_deprecated_args: T.unsafe(nil)); end
end

class GraphQL::InvalidNameError
  def initialize(name, valid_regex); end

  def name(); end

  def valid_regex(); end
end

class GraphQL::InvalidNameError
end

class GraphQL::InvalidNullError
  def field(); end

  def initialize(parent_type, field, value); end

  def parent_error?(); end

  def parent_type(); end

  def to_h(); end

  def value(); end
end

class GraphQL::InvalidNullError
  def self.parent_class(); end

  def self.parent_class=(parent_class); end

  def self.subclass_for(parent_class); end
end

module GraphQL::Language
end

module GraphQL::Language::BlockString
end

module GraphQL::Language::BlockString
  def self.break_line(line, length); end

  def self.print(str, indent: T.unsafe(nil)); end

  def self.trim_whitespace(str); end
end

module GraphQL::Language::DefinitionSlice
  def slice(document, name); end
end

class GraphQL::Language::DefinitionSlice::DependencyVisitor
  def initialize(doc, definitions, names); end
end

class GraphQL::Language::DefinitionSlice::DependencyVisitor
  def self.find_definition_dependencies(definitions, name, names); end
end

module GraphQL::Language::DefinitionSlice
  extend ::GraphQL::Language::DefinitionSlice
end

class GraphQL::Language::DocumentFromSchemaDefinition
  def build_argument_node(argument); end

  def build_argument_nodes(arguments); end

  def build_default_value(default_value, type); end

  def build_definition_nodes(); end

  def build_directive_location_node(location); end

  def build_directive_location_nodes(locations); end

  def build_directive_node(directive); end

  def build_directive_nodes(directives); end

  def build_enum_type_node(enum_type); end

  def build_enum_value_node(enum_value); end

  def build_field_node(field); end

  def build_field_nodes(fields); end

  def build_input_object_node(input_object); end

  def build_interface_type_node(interface_type); end

  def build_object_type_node(object_type); end

  def build_scalar_type_node(scalar_type); end

  def build_schema_node(); end

  def build_type_definition_node(type); end

  def build_type_definition_nodes(types); end

  def build_type_name_node(type); end

  def build_union_type_node(union_type); end

  def document(); end

  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), include_introspection_types: T.unsafe(nil), include_built_in_directives: T.unsafe(nil), include_built_in_scalars: T.unsafe(nil), always_include_schema: T.unsafe(nil)); end
end

class GraphQL::Language::DocumentFromSchemaDefinition
end

module GraphQL::Language::Generation
  def generate(node, indent: T.unsafe(nil), printer: T.unsafe(nil)); end
end

module GraphQL::Language::Generation
  extend ::GraphQL::Language::Generation
end

module GraphQL::Language::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPES_REPLACE = ::T.let(nil, ::T.untyped)
  PACK_DIRECTIVE = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
  UTF_8_ENCODING = ::T.let(nil, ::T.untyped)
  UTF_8_REPLACE = ::T.let(nil, ::T.untyped)
  VALID_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Language::Lexer
  def self.emit(token_name, ts, te, meta, token_value=T.unsafe(nil)); end

  def self.emit_string(ts, te, meta, block:); end

  def self.graphql_lexer_en_main(); end

  def self.graphql_lexer_en_main=(graphql_lexer_en_main); end

  def self.graphql_lexer_en_str(); end

  def self.graphql_lexer_en_str=(graphql_lexer_en_str); end

  def self.graphql_lexer_error(); end

  def self.graphql_lexer_error=(graphql_lexer_error); end

  def self.graphql_lexer_first_final(); end

  def self.graphql_lexer_first_final=(graphql_lexer_first_final); end

  def self.graphql_lexer_start(); end

  def self.graphql_lexer_start=(graphql_lexer_start); end

  def self.record_comment(ts, te, meta); end

  def self.replace_escaped_characters_in_place(raw_string); end

  def self.run_lexer(query_string); end

  def self.tokenize(query_string); end
end

module GraphQL::Language::Nodes
end

class GraphQL::Language::Nodes::AbstractNode
  def ==(other); end

  def children(); end

  def children_method_name(); end

  def col(); end

  def delete_child(previous_child); end

  def filename(); end

  def initialize(options=T.unsafe(nil)); end

  def line(); end

  def merge(new_options); end

  def merge!(new_options); end

  def position(); end

  def replace_child(previous_child, new_child); end

  def scalars(); end

  def to_query_string(printer: T.unsafe(nil)); end
  NO_CHILDREN = ::T.let(nil, ::T.untyped)
end

module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def definition_line(); end

  def initialize(options=T.unsafe(nil)); end
end

module GraphQL::Language::Nodes::AbstractNode::DefinitionNode
end

class GraphQL::Language::Nodes::AbstractNode
  def self.inherited(child_class); end
end

class GraphQL::Language::Nodes::Argument
  def initialize_node(name: T.unsafe(nil), value: T.unsafe(nil)); end

  def name(); end

  def value(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Argument
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Directive
  def arguments(); end

  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Directive
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::DirectiveDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def arguments(); end

  def description(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), locations: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def locations(); end

  def merge_argument(node_opts); end

  def merge_location(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::DirectiveDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::DirectiveLocation
end

class GraphQL::Language::Nodes::DirectiveLocation
end

class GraphQL::Language::Nodes::Document
  def definitions(); end

  def initialize_node(definitions: T.unsafe(nil)); end

  def slice_definition(name); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Document
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Enum
end

class GraphQL::Language::Nodes::Enum
end

class GraphQL::Language::Nodes::EnumTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_value(node_opts); end

  def name(); end

  def values(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::EnumTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_value(node_opts); end

  def name(); end

  def values(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::EnumValueDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumValueDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Field
  def alias(); end

  def arguments(); end

  def directives(); end

  def initialize_node(attributes); end

  def merge_argument(node_opts); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def name(); end

  def selections(); end

  def visit_method(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Nodes::Field
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FieldDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def arguments(); end

  def description(); end

  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def merge_directive(node_opts); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FieldDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FragmentDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def name(); end

  def selections(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FragmentDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FragmentSpread
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FragmentSpread
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InlineFragment
  def directives(); end

  def initialize_node(type: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def selections(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InlineFragment
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObject
  def arguments(); end

  def initialize_node(arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def to_h(options=T.unsafe(nil)); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObject
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputValueDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def default_value(); end

  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputValueDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ListType
end

class GraphQL::Language::Nodes::ListType
end

class GraphQL::Language::Nodes::NameOnlyNode
  def initialize_node(name: T.unsafe(nil)); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::NameOnlyNode
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::NonNullType
end

class GraphQL::Language::Nodes::NonNullType
end

class GraphQL::Language::Nodes::NullValue
end

class GraphQL::Language::Nodes::NullValue
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def interfaces(); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ObjectTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def interfaces(); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ObjectTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::OperationDefinition
  def directives(); end

  def initialize_node(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def merge_variable(node_opts); end

  def name(); end

  def operation_type(); end

  def selections(); end

  def variables(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::OperationDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ScalarTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ScalarTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::SchemaDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def directives(); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def mutation(); end

  def query(); end

  def subscription(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::SchemaDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::SchemaExtension
  def directives(); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def mutation(); end

  def query(); end

  def subscription(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::SchemaExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::TypeName
end

class GraphQL::Language::Nodes::TypeName
end

class GraphQL::Language::Nodes::UnionTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::DefinitionNode
  def description(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def types(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::UnionTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::UnionTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def types(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::UnionTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::VariableDefinition
  def default_value(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil)); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::VariableDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::VariableIdentifier
end

class GraphQL::Language::Nodes::VariableIdentifier
end

class GraphQL::Language::Nodes::WrapperType
  def initialize_node(of_type: T.unsafe(nil)); end

  def of_type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::WrapperType
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

module GraphQL::Language::Nodes
end

class GraphQL::Language::Parser
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_132(val, _values, result); end

  def _reduce_133(val, _values, result); end

  def _reduce_134(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_137(val, _values, result); end

  def _reduce_138(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_140(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_142(val, _values, result); end

  def _reduce_143(val, _values, result); end

  def _reduce_144(val, _values, result); end

  def _reduce_148(val, _values, result); end

  def _reduce_149(val, _values, result); end

  def _reduce_150(val, _values, result); end

  def _reduce_152(val, _values, result); end

  def _reduce_153(val, _values, result); end

  def _reduce_154(val, _values, result); end

  def _reduce_155(val, _values, result); end

  def _reduce_156(val, _values, result); end

  def _reduce_157(val, _values, result); end

  def _reduce_158(val, _values, result); end

  def _reduce_159(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_160(val, _values, result); end

  def _reduce_161(val, _values, result); end

  def _reduce_162(val, _values, result); end

  def _reduce_163(val, _values, result); end

  def _reduce_164(val, _values, result); end

  def _reduce_165(val, _values, result); end

  def _reduce_166(val, _values, result); end

  def _reduce_167(val, _values, result); end

  def _reduce_168(val, _values, result); end

  def _reduce_169(val, _values, result); end

  def _reduce_170(val, _values, result); end

  def _reduce_171(val, _values, result); end

  def _reduce_172(val, _values, result); end

  def _reduce_173(val, _values, result); end

  def _reduce_174(val, _values, result); end

  def _reduce_175(val, _values, result); end

  def _reduce_176(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(query_string, filename:, tracer: T.unsafe(nil)); end

  def parse_document(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Parser
  def self.parse(query_string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end

  def self.parse_file(filename, tracer: T.unsafe(nil)); end
end

class GraphQL::Language::Printer
  def print(node, indent: T.unsafe(nil)); end

  def print_argument(argument); end

  def print_arguments(arguments, indent: T.unsafe(nil)); end

  def print_description(node, indent: T.unsafe(nil), first_in_block: T.unsafe(nil)); end

  def print_directive(directive); end

  def print_directive_definition(directive); end

  def print_directives(directives); end

  def print_document(document); end

  def print_enum(enum); end

  def print_enum_type_definition(enum_type); end

  def print_enum_value_definition(enum_value); end

  def print_field(field, indent: T.unsafe(nil)); end

  def print_field_definition(field); end

  def print_field_definitions(fields); end

  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end

  def print_fragment_spread(fragment_spread, indent: T.unsafe(nil)); end

  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end

  def print_input_object(input_object); end

  def print_input_object_type_definition(input_object_type); end

  def print_input_value_definition(input_value); end

  def print_interface_type_definition(interface_type); end

  def print_list_type(list_type); end

  def print_node(node, indent: T.unsafe(nil)); end

  def print_non_null_type(non_null_type); end

  def print_null_value(); end

  def print_object_type_definition(object_type); end

  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end

  def print_scalar_type_definition(scalar_type); end

  def print_schema_definition(schema); end

  def print_selections(selections, indent: T.unsafe(nil)); end

  def print_type_name(type_name); end

  def print_union_type_definition(union_type); end

  def print_variable_definition(variable_definition); end

  def print_variable_identifier(variable_identifier); end
end

class GraphQL::Language::Printer
end

class GraphQL::Language::SanitizedPrinter
  def coerce_argument_value_to_list?(type, value); end

  def initialize(query, inline_variables: T.unsafe(nil)); end

  def print_variable_identifier(variable_id); end

  def redact_argument_value?(argument, value); end

  def redacted_argument_value(argument); end

  def sanitized_query_string(); end
  REDACTED = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::SanitizedPrinter
end

class GraphQL::Language::Token
  def col(); end

  def initialize(name, value, line, col, prev_token); end

  def line(); end

  def line_and_column(); end

  def name(); end

  def prev_token(); end

  def to_f(); end

  def to_i(); end

  def value(); end
end

class GraphQL::Language::Token
end

class GraphQL::Language::Visitor
  def [](node_class); end

  def initialize(document); end

  def on_abstract_node(node, parent); end

  def on_argument(node, parent); end

  def on_directive(node, parent); end

  def on_directive_definition(node, parent); end

  def on_directive_location(node, parent); end

  def on_document(node, parent); end

  def on_enum(node, parent); end

  def on_enum_type_definition(node, parent); end

  def on_enum_type_extension(node, parent); end

  def on_enum_value_definition(node, parent); end

  def on_field(node, parent); end

  def on_field_definition(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_object_type_extension(node, parent); end

  def on_input_value_definition(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_interface_type_extension(node, parent); end

  def on_list_type(node, parent); end

  def on_non_null_type(node, parent); end

  def on_null_value(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_object_type_extension(node, parent); end

  def on_operation_definition(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_scalar_type_extension(node, parent); end

  def on_schema_definition(node, parent); end

  def on_schema_extension(node, parent); end

  def on_type_name(node, parent); end

  def on_union_type_definition(node, parent); end

  def on_union_type_extension(node, parent); end

  def on_variable_definition(node, parent); end

  def on_variable_identifier(node, parent); end

  def result(); end

  def visit(); end

  def visit_node(node, parent); end
  DELETE_NODE = ::T.let(nil, ::T.untyped)
  SKIP = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Visitor
  def self.apply_hooks(hooks, node, parent); end

  def self.make_visit_method(node_method); end
end

module GraphQL::Language
  def self.serialize(value); end
end

class GraphQL::ListType
  include ::GraphQL::BaseType::ModifiesAnotherType
  def coerce_result(value, ctx=T.unsafe(nil)); end

  def initialize(of_type:); end

  def kind(); end

  def of_type(); end
end

class GraphQL::ListType
end

class GraphQL::LoadApplicationObjectFailedError
  def argument(); end

  def id(); end

  def initialize(argument:, id:, object:); end

  def object(); end
end

class GraphQL::LoadApplicationObjectFailedError
end

class GraphQL::NameValidator
  VALID_NAME_REGEX = ::T.let(nil, ::T.untyped)
end

class GraphQL::NameValidator
  def self.validate!(name); end
end

class GraphQL::NonNullType
  include ::GraphQL::BaseType::ModifiesAnotherType
  def coerce_input(*args, &block); end

  def coerce_result(*args, &block); end

  def initialize(of_type:); end

  def kind(); end

  def list?(*args, &block); end

  def of_type(); end

  def valid_input?(value, ctx); end

  def validate_input(value, ctx); end
end

class GraphQL::NonNullType
  extend ::Forwardable
end

class GraphQL::ObjectType
  def all_fields(); end

  def fields(); end

  def fields=(fields); end

  def get_field(field_name); end

  def implements(interfaces, inherit: T.unsafe(nil), **options); end

  def inherited_interface_type_memberships(); end

  def interfaces(ctx=T.unsafe(nil)); end

  def interfaces=(new_interfaces); end

  def kind(); end

  def mutation(); end

  def mutation=(mutation); end

  def relay_node_type(); end

  def relay_node_type=(relay_node_type); end

  def resolve_type_proc(); end

  def structural_interface_type_memberships(); end

  def structural_interface_type_memberships=(structural_interface_type_memberships); end
end

class GraphQL::ObjectType
end

module GraphQL::Pagination
end

class GraphQL::Pagination::ActiveRecordRelationConnection
end

class GraphQL::Pagination::ActiveRecordRelationConnection
end

class GraphQL::Pagination::ArrayConnection
end

class GraphQL::Pagination::ArrayConnection
end

class GraphQL::Pagination::Connection
  def after(); end

  def after_value(); end

  def after_value=(after_value); end

  def before(); end

  def before_value(); end

  def before_value=(before_value); end

  def context(); end

  def context=(context); end

  def cursor_for(item); end

  def edge_class(); end

  def edge_class=(edge_class); end

  def edge_nodes(); end

  def edges(); end

  def end_cursor(); end

  def first(); end

  def first=(first); end

  def first_value(); end

  def first_value=(first_value); end

  def has_max_page_size_override?(); end

  def has_next_page(); end

  def has_previous_page(); end

  def initialize(items, parent: T.unsafe(nil), context: T.unsafe(nil), first: T.unsafe(nil), after: T.unsafe(nil), max_page_size: T.unsafe(nil), last: T.unsafe(nil), before: T.unsafe(nil), edge_class: T.unsafe(nil)); end

  def items(); end

  def last(); end

  def last=(last); end

  def last_value(); end

  def last_value=(last_value); end

  def max_page_size(); end

  def max_page_size=(new_value); end

  def nodes(); end

  def page_info(); end

  def parent(); end

  def parent=(parent); end

  def start_cursor(); end
end

class GraphQL::Pagination::Connection::Edge
  def cursor(); end

  def initialize(node, connection); end

  def node(); end

  def parent(); end
end

class GraphQL::Pagination::Connection::Edge
end

class GraphQL::Pagination::Connection::PaginationImplementationMissingError
end

class GraphQL::Pagination::Connection::PaginationImplementationMissingError
end

class GraphQL::Pagination::Connection
end

class GraphQL::Pagination::Connections
  def add(nodes_class, implementation); end

  def all_wrappers(); end

  def delete(nodes_class); end

  def edge_class_for_field(field); end

  def initialize(schema:); end

  def wrap(field, parent, items, arguments, context, wrappers: T.unsafe(nil)); end

  def wrapper_for(items, wrappers: T.unsafe(nil)); end

  def wrappers(); end
end

class GraphQL::Pagination::Connections::ImplementationMissingError
end

class GraphQL::Pagination::Connections::ImplementationMissingError
end

class GraphQL::Pagination::Connections
  def self.use(schema_defn); end
end

class GraphQL::Pagination::MongoidRelationConnection
end

class GraphQL::Pagination::MongoidRelationConnection
end

class GraphQL::Pagination::RelationConnection
end

class GraphQL::Pagination::RelationConnection
end

class GraphQL::Pagination::SequelDatasetConnection
end

class GraphQL::Pagination::SequelDatasetConnection
end

module GraphQL::Pagination
end

class GraphQL::ParseError
  def col(); end

  def initialize(message, line, col, query, filename: T.unsafe(nil)); end

  def line(); end

  def query(); end

  def to_h(); end
end

class GraphQL::ParseError
end

class GraphQL::Query
  include ::GraphQL::Tracing::Traceable
  def analysis_errors(); end

  def analysis_errors=(analysis_errors); end

  def analyzers(*args, &block); end

  def arguments_for(ast_node, definition, parent_object: T.unsafe(nil)); end

  def ast_analyzers(*args, &block); end

  def context(); end

  def document(); end

  def executed?(); end

  def fingerprint(); end

  def fragments(); end

  def get_field(*args, &block); end

  def get_type(*args, &block); end

  def initialize(schema, query_string=T.unsafe(nil), query: T.unsafe(nil), document: T.unsafe(nil), context: T.unsafe(nil), variables: T.unsafe(nil), validate: T.unsafe(nil), subscription_topic: T.unsafe(nil), operation_name: T.unsafe(nil), root_value: T.unsafe(nil), max_depth: T.unsafe(nil), max_complexity: T.unsafe(nil), except: T.unsafe(nil), only: T.unsafe(nil), warden: T.unsafe(nil)); end

  def internal_representation(*args, &block); end

  def interpreter?(*args, &block); end

  def irep_selection(); end

  def lookahead(); end

  def max_complexity(*args, &block); end

  def max_depth(*args, &block); end

  def merge_filters(only: T.unsafe(nil), except: T.unsafe(nil)); end

  def mutation?(); end

  def operation_fingerprint(); end

  def operation_name(); end

  def operation_name=(operation_name); end

  def operations(); end

  def possible_types(*args, &block); end

  def provided_variables(); end

  def query?(); end

  def query_string(); end

  def query_string=(query_string); end

  def resolve_type(abstract_type, value=T.unsafe(nil)); end

  def result(); end

  def result_values(); end

  def result_values=(result_hash); end

  def root_type_for_operation(*args, &block); end

  def root_value(); end

  def root_value=(root_value); end

  def sanitized_query_string(inline_variables: T.unsafe(nil)); end

  def schema(); end

  def selected_operation(); end

  def selected_operation_name(); end

  def static_errors(); end

  def subscription?(); end

  def subscription_topic(); end

  def subscription_update?(); end

  def tracers(); end

  def valid?(); end

  def validate(); end

  def validate=(validate); end

  def validation_errors(*args, &block); end

  def validation_pipeline(); end

  def variables(); end

  def variables_fingerprint(); end

  def warden(); end

  def with_error_handling(); end
end

class GraphQL::Query::Arguments
  include ::GraphQL::Dig
  def [](key); end

  def any?(*args, &block); end

  def argument_values(); end

  def default_used?(key); end

  def each(*args, &block); end

  def each_value(); end

  def initialize(values, context:, defaults_used:); end

  def key?(key); end

  def keys(*args, &block); end

  def prepare(); end

  def to_h(); end

  def to_hash(); end

  def to_kwargs(); end

  def values(*args, &block); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
  NULL_ARGUMENT_VALUE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Query::Arguments::ArgumentValue
  def default_used=(default_used); end

  def default_used?(); end

  def definition(); end

  def initialize(key, value, definition, default_used); end

  def key(); end

  def value(); end
end

class GraphQL::Query::Arguments::ArgumentValue
end

class GraphQL::Query::Arguments::NoArguments
end

class GraphQL::Query::Arguments::NoArguments
end

class GraphQL::Query::Arguments
  extend ::Forwardable
  def self.argument_definitions(); end

  def self.argument_definitions=(argument_definitions); end

  def self.argument_owner(); end

  def self.argument_owner=(argument_owner); end

  def self.construct_arguments_class(argument_owner); end
end

module GraphQL::Query::ArgumentsCache
end

module GraphQL::Query::ArgumentsCache
  def self.build(query); end
end

class GraphQL::Query::Context
  include ::GraphQL::Query::Context::SharedMethods
  def [](key); end

  def []=(*args, &block); end

  def ast_node(); end

  def delete(key); end

  def dig(key, *other_keys); end

  def errors(); end

  def execution_strategy(); end

  def execution_strategy=(new_strategy); end

  def fetch(key, default=T.unsafe(nil)); end

  def initialize(query:, values:, object:, schema: T.unsafe(nil)); end

  def interpreter=(interpreter); end

  def interpreter?(*args, &block); end

  def irep_node(); end

  def key?(key); end

  def namespace(ns); end

  def path(); end

  def query(); end

  def received_null_child(); end

  def schema(); end

  def scoped_context(); end

  def scoped_context=(scoped_context); end

  def scoped_merge!(hash); end

  def scoped_set!(key, value); end

  def strategy(); end

  def to_h(); end

  def to_hash(); end

  def trace(*args, &block); end

  def value=(value); end

  def warden(); end
  UNSPECIFIED_FETCH_DEFAULT = ::T.let(nil, ::T.untyped)
end

class GraphQL::Query::Context::ExecutionErrors
  def >>(err_or_msg); end

  def add(err_or_msg); end

  def initialize(ctx); end

  def push(err_or_msg); end
end

class GraphQL::Query::Context::ExecutionErrors
end

class GraphQL::Query::Context::FieldResolutionContext
  include ::GraphQL::Query::Context::SharedMethods
  include ::GraphQL::Tracing::Traceable
  def [](*args, &block); end

  def []=(*args, &block); end

  def ast_node(); end

  def dig(*args, &block); end

  def errors(*args, &block); end

  def execution_strategy(*args, &block); end

  def fetch(*args, &block); end

  def field(); end

  def initialize(context, key, irep_node, parent, object); end

  def interpreter?(*args, &block); end

  def irep_node(); end

  def key(); end

  def key?(*args, &block); end

  def namespace(*args, &block); end

  def parent(); end

  def parent_type(); end

  def path(); end

  def query(); end

  def received_null_child(); end

  def schema(); end

  def selection(); end

  def spawn(*args, &block); end

  def strategy(*args, &block); end

  def to_h(*args, &block); end

  def type(); end

  def value=(new_value); end

  def warden(*args, &block); end

  def wrapped_connection(); end

  def wrapped_connection=(wrapped_connection); end

  def wrapped_object(); end

  def wrapped_object=(wrapped_object); end
end

class GraphQL::Query::Context::FieldResolutionContext
  extend ::Forwardable
end

module GraphQL::Query::Context::SharedMethods
  def add_error(error); end

  def backtrace(); end

  def delete_child(child_ctx); end

  def execution_errors(); end

  def invalid_null?(); end

  def lookahead(); end

  def object(); end

  def object=(object); end

  def skip(); end

  def skipped(); end

  def skipped=(skipped); end

  def skipped?(); end

  def spawn_child(key:, irep_node:, object:); end

  def value(); end
end

module GraphQL::Query::Context::SharedMethods
end

class GraphQL::Query::Context
  extend ::Forwardable
end

class GraphQL::Query::Executor
  def initialize(query); end

  def query(); end

  def result(); end
end

class GraphQL::Query::Executor::PropagateNull
end

class GraphQL::Query::Executor::PropagateNull
end

class GraphQL::Query::Executor
end

module GraphQL::Query::Fingerprint
end

module GraphQL::Query::Fingerprint
  def self.generate(input_str); end
end

class GraphQL::Query::InputValidationResult
  def add_problem(explanation, path=T.unsafe(nil), extensions: T.unsafe(nil), message: T.unsafe(nil)); end

  def initialize(valid: T.unsafe(nil), problems: T.unsafe(nil)); end

  def merge_result!(path, inner_result); end

  def problems(); end

  def problems=(problems); end

  def valid?(); end
end

class GraphQL::Query::InputValidationResult
end

class GraphQL::Query::LiteralInput
end

class GraphQL::Query::LiteralInput
  def self.coerce(type, ast_node, variables); end

  def self.from_arguments(ast_arguments, argument_owner, variables); end
end

class GraphQL::Query::NullContext
  def [](key); end

  def interpreter?(); end

  def query(); end

  def schema(); end

  def warden(); end
end

class GraphQL::Query::NullContext::NullWarden
  def visible?(t); end

  def visible_field?(t); end

  def visible_type?(t); end
end

class GraphQL::Query::NullContext::NullWarden
end

class GraphQL::Query::NullContext
  def self.[](key); end

  def self.instance(); end

  def self.interpreter?(*args, &block); end

  def self.query(*args, &block); end

  def self.schema(*args, &block); end

  def self.warden(*args, &block); end
end

class GraphQL::Query::OperationNameMissingError
  def initialize(name); end
end

class GraphQL::Query::OperationNameMissingError
end

class GraphQL::Query::Result
  def ==(other); end

  def [](*args, &block); end

  def as_json(*args, &block); end

  def context(*args, &block); end

  def initialize(query:, values:); end

  def keys(*args, &block); end

  def method_missing(method_name, *args, &block); end

  def mutation?(*args, &block); end

  def query(); end

  def query?(*args, &block); end

  def subscription?(*args, &block); end

  def to_h(); end

  def to_json(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Query::Result
  extend ::Forwardable
end

class GraphQL::Query::SerialExecution
  def execute(ast_operation, root_type, query_object); end

  def field_resolution(); end

  def operation_resolution(); end

  def selection_resolution(); end
end

class GraphQL::Query::SerialExecution::FieldResolution
  def arguments(); end

  def execution_context(); end

  def field(); end

  def initialize(selection, parent_type, target, query_ctx); end

  def irep_node(); end

  def parent_type(); end

  def query(); end

  def result(); end

  def target(); end
end

class GraphQL::Query::SerialExecution::FieldResolution
end

module GraphQL::Query::SerialExecution::OperationResolution
end

module GraphQL::Query::SerialExecution::OperationResolution
  def self.resolve(selection, target, query); end
end

module GraphQL::Query::SerialExecution::SelectionResolution
end

module GraphQL::Query::SerialExecution::SelectionResolution
  def self.resolve(target, current_type, selection, query_ctx); end
end

module GraphQL::Query::SerialExecution::ValueResolution
end

module GraphQL::Query::SerialExecution::ValueResolution
  def self.resolve(parent_type, field_defn, field_type, value, selection, query_ctx); end
end

class GraphQL::Query::SerialExecution
end

class GraphQL::Query::ValidationPipeline
  def analyzers(); end

  def initialize(query:, validate:, parse_error:, operation_name_error:, max_depth:, max_complexity:); end

  def internal_representation(); end

  def max_complexity(); end

  def max_depth(); end

  def valid?(); end

  def validation_errors(); end
end

class GraphQL::Query::ValidationPipeline
end

class GraphQL::Query::VariableValidationError
  def initialize(variable_ast, type, value, validation_result); end

  def validation_result(); end

  def validation_result=(validation_result); end

  def value(); end

  def value=(value); end
end

class GraphQL::Query::VariableValidationError
end

class GraphQL::Query::Variables
  def [](*args, &block); end

  def context(); end

  def errors(); end

  def fetch(*args, &block); end

  def initialize(ctx, ast_variables, provided_variables); end

  def key?(*args, &block); end

  def length(*args, &block); end

  def to_h(*args, &block); end
end

class GraphQL::Query::Variables
  extend ::Forwardable
end

class GraphQL::Query
  extend ::Forwardable
end

module GraphQL::Relay
  PageInfo = ::T.let(nil, ::T.untyped)
end

class GraphQL::Relay::ArrayConnection
  def cursor_from_node(item); end
end

class GraphQL::Relay::ArrayConnection
end

class GraphQL::Relay::BaseConnection
  def after(); end

  def arguments(); end

  def before(); end

  def context(); end

  def cursor_from_node(object); end

  def decode(data); end

  def edge_nodes(); end

  def encode(data); end

  def end_cursor(); end

  def field(); end

  def first(); end

  def has_next_page(); end

  def has_previous_page(); end

  def initialize(nodes, arguments, field: T.unsafe(nil), max_page_size: T.unsafe(nil), parent: T.unsafe(nil), context: T.unsafe(nil)); end

  def last(); end

  def max_page_size(); end

  def nodes(); end

  def page_info(); end

  def parent(); end

  def start_cursor(); end
  CONNECTION_IMPLEMENTATIONS = ::T.let(nil, ::T.untyped)
  CURSOR_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class GraphQL::Relay::BaseConnection
  def self.connection_for_nodes(nodes); end

  def self.register_connection_implementation(nodes_class, connection_class); end
end

module GraphQL::Relay::ConnectionInstrumentation
end

module GraphQL::Relay::ConnectionInstrumentation
  def self.default_arguments(); end

  def self.instrument(type, field); end
end

class GraphQL::Relay::ConnectionResolve
  def call(obj, args, ctx); end

  def initialize(field, underlying_resolve); end
end

class GraphQL::Relay::ConnectionResolve
end

module GraphQL::Relay::ConnectionType
end

module GraphQL::Relay::ConnectionType
  def self.bidirectional_pagination(); end

  def self.bidirectional_pagination=(bidirectional_pagination); end

  def self.create_type(wrapped_type, edge_type: T.unsafe(nil), edge_class: T.unsafe(nil), nodes_field: T.unsafe(nil), &block); end

  def self.default_nodes_field(); end

  def self.default_nodes_field=(default_nodes_field); end
end

class GraphQL::Relay::Edge
  def connection(); end

  def cursor(); end

  def initialize(node, connection); end

  def node(); end

  def parent(); end
end

class GraphQL::Relay::Edge
end

module GraphQL::Relay::EdgeType
end

module GraphQL::Relay::EdgeType
  def self.create_type(wrapped_type, name: T.unsafe(nil), &block); end
end

module GraphQL::Relay::EdgesInstrumentation
end

class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
  def call(obj, args, ctx); end

  def initialize(edge_class:, resolve:); end
end

class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
end

module GraphQL::Relay::EdgesInstrumentation
  def self.instrument(type, field); end
end

class GraphQL::Relay::GlobalIdResolve
  def call(obj, args, ctx); end

  def initialize(type:); end
end

class GraphQL::Relay::GlobalIdResolve
end

class GraphQL::Relay::MongoRelationConnection
end

class GraphQL::Relay::MongoRelationConnection
end

class GraphQL::Relay::Mutation
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def description(); end

  def description=(description); end

  def field(); end

  def fields(); end

  def fields=(fields); end

  def has_generated_return_type?(); end

  def input_fields(); end

  def input_type(); end

  def name(); end

  def name=(name); end

  def resolve=(new_resolve_proc); end

  def result_class(); end

  def return_fields(); end

  def return_interfaces(); end

  def return_interfaces=(return_interfaces); end

  def return_type(); end

  def return_type=(return_type); end
end

module GraphQL::Relay::Mutation::Instrumentation
end

module GraphQL::Relay::Mutation::Instrumentation
  def self.instrument(type, field); end
end

class GraphQL::Relay::Mutation::Resolve
  def call(obj, args, ctx); end

  def initialize(mutation, resolve); end
end

class GraphQL::Relay::Mutation::Resolve
end

class GraphQL::Relay::Mutation::Result
  def client_mutation_id(); end

  def initialize(client_mutation_id:, result:); end
end

class GraphQL::Relay::Mutation::Result
  def self.define_subclass(mutation_defn); end

  def self.mutation(); end

  def self.mutation=(mutation); end
end

class GraphQL::Relay::Mutation
end

module GraphQL::Relay::Node
end

module GraphQL::Relay::Node
  def self.field(**kwargs, &block); end

  def self.interface(); end

  def self.plural_field(**kwargs, &block); end
end

class GraphQL::Relay::RangeAdd
  def connection(); end

  def edge(); end

  def initialize(collection:, item:, parent: T.unsafe(nil), context: T.unsafe(nil), edge_class: T.unsafe(nil)); end

  def parent(); end
end

class GraphQL::Relay::RangeAdd
end

class GraphQL::Relay::RelationConnection
  def cursor_from_node(item); end
end

class GraphQL::Relay::RelationConnection
end

module GraphQL::Relay::TypeExtensions
  def connection_type(); end

  def define_connection(**kwargs, &block); end

  def define_edge(**kwargs, &block); end

  def edge_type(); end
end

module GraphQL::Relay::TypeExtensions
end

module GraphQL::Relay
end

class GraphQL::RequiredImplementationMissingError
end

class GraphQL::RequiredImplementationMissingError
end

module GraphQL::Ruby2Keywords
  def ruby2_keywords(*_); end
end

module GraphQL::Ruby2Keywords
end

class GraphQL::RuntimeTypeError
end

class GraphQL::RuntimeTypeError
end

class GraphQL::ScalarType
  def coerce=(proc); end

  def coerce_input=(coerce_input_fn); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def coerce_result=(coerce_result_fn); end

  def kind(); end
end

module GraphQL::ScalarType::NoOpCoerce
end

module GraphQL::ScalarType::NoOpCoerce
  def self.call(val, ctx); end
end

class GraphQL::ScalarType
end

class GraphQL::Schema
  include ::GraphQL::Define::InstanceDefinable
  include ::GraphQL::Schema::LazyHandlingMethods
  def _schema_class(); end

  def accessible?(member, context); end

  def analysis_engine(); end

  def analysis_engine=(analysis_engine); end

  def as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def call_on_type_class(member, method_name, context, default:); end

  def check_resolved_type(type, object, ctx=T.unsafe(nil)); end

  def connections(); end

  def connections=(connections); end

  def context_class(); end

  def context_class=(context_class); end

  def cursor_encoder(); end

  def cursor_encoder=(cursor_encoder); end

  def default_filter(); end

  def default_mask(); end

  def default_mask=(default_mask); end

  def default_max_page_size(); end

  def default_max_page_size=(default_max_page_size); end

  def directive(*args, &block); end

  def directives(); end

  def directives=(directives); end

  def disable_introspection_entry_points(); end

  def disable_introspection_entry_points=(disable_introspection_entry_points); end

  def disable_introspection_entry_points?(); end

  def disable_schema_introspection_entry_point(); end

  def disable_schema_introspection_entry_point=(disable_schema_introspection_entry_point); end

  def disable_schema_introspection_entry_point?(); end

  def disable_type_introspection_entry_point(); end

  def disable_type_introspection_entry_point=(disable_type_introspection_entry_point); end

  def disable_type_introspection_entry_point?(); end

  def error_bubbling(); end

  def error_bubbling=(error_bubbling); end

  def error_handler(*args, &block); end

  def execute(query_str=T.unsafe(nil), **kwargs); end

  def execution_strategy_for_operation(operation); end

  def find(path); end

  def get_field(parent_type, field_name); end

  def get_fields(type); end

  def get_type(type_name); end

  def graphql_definition(); end

  def id_from_object(object, type, ctx); end

  def id_from_object=(new_proc); end

  def id_from_object_proc(); end

  def inaccessible_fields(*args, &block); end

  def instrument(instrumentation_type, instrumenter); end

  def instrumenters(); end

  def instrumenters=(instrumenters); end

  def interpreter=(interpreter); end

  def interpreter?(); end

  def introspection_namespace(); end

  def introspection_namespace=(introspection_namespace); end

  def introspection_system(); end

  def lazy_methods(); end

  def lazy_methods=(lazy_methods); end

  def max_complexity(); end

  def max_complexity=(max_complexity); end

  def max_depth(); end

  def max_depth=(max_depth); end

  def middleware(); end

  def middleware=(middleware); end

  def multiplex(queries, **kwargs); end

  def multiplex_analyzers(); end

  def multiplex_analyzers=(multiplex_analyzers); end

  def mutation(); end

  def mutation=(mutation); end

  def mutation_execution_strategy(); end

  def mutation_execution_strategy=(mutation_execution_strategy); end

  def new_connections?(); end

  def object_from_id(id, ctx); end

  def object_from_id=(new_proc); end

  def object_from_id_proc(); end

  def orphan_types(); end

  def orphan_types=(orphan_types); end

  def parse_error(err, ctx); end

  def parse_error=(new_proc); end

  def possible_types(type_defn, context=T.unsafe(nil)); end

  def query(); end

  def query=(query); end

  def query_analyzers(); end

  def query_analyzers=(query_analyzers); end

  def query_execution_strategy(); end

  def query_execution_strategy=(query_execution_strategy); end

  def raise_definition_error(); end

  def raise_definition_error=(raise_definition_error); end

  def references_to(type_name=T.unsafe(nil)); end

  def remove_handler(*args, &block); end

  def rescue_from(*args, &block); end

  def rescue_middleware(); end

  def rescues?(); end

  def resolve_type(type, object, ctx=T.unsafe(nil)); end

  def resolve_type=(new_resolve_type_proc); end

  def resolve_type_proc(); end

  def root_type_for_operation(operation); end

  def root_types(); end

  def static_validator(); end

  def subscription(); end

  def subscription=(subscription); end

  def subscription_execution_strategy(); end

  def subscription_execution_strategy=(subscription_execution_strategy); end

  def subscriptions(); end

  def subscriptions=(subscriptions); end

  def to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def to_document(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def to_json(*args); end

  def tracers(); end

  def type_error(err, ctx); end

  def type_error=(new_proc); end

  def type_from_ast(ast_node, context:); end

  def types(); end

  def unauthorized_field(*args, &block); end

  def unauthorized_object(*args, &block); end

  def union_memberships(type); end

  def using_ast_analysis?(); end

  def validate(string_or_document, rules: T.unsafe(nil), context: T.unsafe(nil)); end

  def visible?(member, context); end
  BUILT_IN_TYPES = ::T.let(nil, ::T.untyped)
  DYNAMIC_FIELDS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Argument
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accessible?(context); end

  def authorized?(obj, value, ctx); end

  def authorized_as_type?(obj, value, ctx, as_type:); end

  def default_value(); end

  def default_value?(); end

  def deprecation_reason(text=T.unsafe(nil)); end

  def deprecation_reason=(text=T.unsafe(nil)); end

  def description(text=T.unsafe(nil)); end

  def description=(description); end

  def from_resolver?(); end

  def graphql_name(); end

  def keyword(); end

  def loads(); end

  def name(); end

  def owner(); end

  def prepare(); end

  def prepare_value(obj, value, context: T.unsafe(nil)); end

  def statically_coercible?(); end

  def type(); end

  def type=(new_type); end

  def visible?(context); end
  NO_DEFAULT = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Argument
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

module GraphQL::Schema::Base64Encoder
end

module GraphQL::Schema::Base64Encoder
  def self.decode(encoded_text, nonce: T.unsafe(nil)); end

  def self.encode(unencoded_text, nonce: T.unsafe(nil)); end
end

module GraphQL::Schema::BuildFromDefinition
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap
  def call(type, field, obj, args, ctx); end

  def coerce_input(type, value, ctx); end

  def coerce_result(type, value, ctx); end

  def initialize(user_resolve_hash); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
  def call(obj, args, ctx); end

  def initialize(field_map, field_name); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap::DefaultResolve
end

module GraphQL::Schema::BuildFromDefinition::ResolveMap::NullScalarCoerce
end

module GraphQL::Schema::BuildFromDefinition::ResolveMap::NullScalarCoerce
  def self.call(val, _ctx); end
end

class GraphQL::Schema::BuildFromDefinition::ResolveMap
end

module GraphQL::Schema::BuildFromDefinition
  def self.from_definition(definition_string, parser: T.unsafe(nil), **kwargs); end

  def self.from_definition_path(definition_path, parser: T.unsafe(nil), **kwargs); end

  def self.from_document(document, default_resolve:, using: T.unsafe(nil), relay: T.unsafe(nil), interpreter: T.unsafe(nil)); end
end

module GraphQL::Schema::CatchallMiddleware
  MESSAGE = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::CatchallMiddleware
  def self.call(parent_type, parent_object, field_definition, field_args, query_context); end
end

class GraphQL::Schema::CyclicalDefinitionError
end

class GraphQL::Schema::CyclicalDefinitionError
end

module GraphQL::Schema::DefaultParseError
end

module GraphQL::Schema::DefaultParseError
  def self.call(parse_error, ctx); end
end

module GraphQL::Schema::DefaultTypeError
end

module GraphQL::Schema::DefaultTypeError
  def self.call(type_error, ctx); end
end

class GraphQL::Schema::Directive
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  ARGUMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  DEFAULT_DEPRECATION_REASON = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_VALUE = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_SPREAD = ::T.let(nil, ::T.untyped)
  INLINE_FRAGMENT = ::T.let(nil, ::T.untyped)
  INPUT_FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  INPUT_OBJECT = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  LOCATIONS = ::T.let(nil, ::T.untyped)
  LOCATION_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  MUTATION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCALAR = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  SUBSCRIPTION = ::T.let(nil, ::T.untyped)
  UNION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Directive::Deprecated
end

class GraphQL::Schema::Directive::Deprecated
end

class GraphQL::Schema::Directive::Feature
end

class GraphQL::Schema::Directive::Feature
  def self.enabled?(flag_name, object, context); end

  def self.include?(object, arguments, context); end
end

class GraphQL::Schema::Directive::Include
end

class GraphQL::Schema::Directive::Include
  def self.static_include?(args, ctx); end
end

class GraphQL::Schema::Directive::Skip
end

class GraphQL::Schema::Directive::Skip
  def self.static_include?(args, ctx); end
end

class GraphQL::Schema::Directive::Transform
  TRANSFORMS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Directive::Transform
end

class GraphQL::Schema::Directive
  extend ::GraphQL::Schema::Member::HasArguments
  def self.default_directive(new_default_directive=T.unsafe(nil)); end

  def self.default_directive?(); end

  def self.include?(_object, arguments, context); end

  def self.locations(*new_locations); end

  def self.on_field?(); end

  def self.on_fragment?(); end

  def self.on_operation?(); end

  def self.resolve(object, arguments, context); end

  def self.static_include?(_arguments, _context); end
end

class GraphQL::Schema::DuplicateTypeNamesError
  def initialize(type_name:, first_definition:, second_definition:, path:); end
end

class GraphQL::Schema::DuplicateTypeNamesError
end

class GraphQL::Schema::Enum::UnresolvedValueError
end

class GraphQL::Schema::Enum::UnresolvedValueError
end

class GraphQL::Schema::Enum
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.coerce_input(value_name, ctx); end

  def self.coerce_result(value, ctx); end

  def self.enum_value_class(new_enum_value_class=T.unsafe(nil)); end

  def self.validate_non_null_input(value_name, ctx); end

  def self.values(); end
end

class GraphQL::Schema::EnumValue
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accessible?(_ctx); end

  def authorized?(_ctx); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(new_desc=T.unsafe(nil)); end

  def graphql_name(); end

  def owner(); end

  def value(new_val=T.unsafe(nil)); end

  def visible?(_ctx); end
end

class GraphQL::Schema::EnumValue
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accessible?(context); end

  def authorized?(object, args, context); end

  def broadcastable?(); end

  def complexity(new_complexity=T.unsafe(nil)); end

  def connection?(); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(text=T.unsafe(nil)); end

  def description=(description); end

  def extension(extension, options=T.unsafe(nil)); end

  def extensions(new_extensions=T.unsafe(nil)); end

  def extras(new_extras=T.unsafe(nil)); end

  def fetch_extra(extra_name, ctx); end

  def graphql_name(); end

  def has_max_page_size?(); end

  def introspection?(); end

  def max_page_size(); end

  def method_conflict_warning?(); end

  def method_str(); end

  def method_sym(); end

  def mutation(); end

  def name(); end

  def original_name(); end

  def owner(); end

  def owner=(owner); end

  def owner_type(); end

  def relay_node_field(); end

  def resolve(object, args, ctx); end

  def resolve_field(obj, args, ctx); end

  def resolver(); end

  def resolver_method(); end

  def scoped?(); end

  def subscription_scope(); end

  def subscription_scope=(subscription_scope); end

  def trace(); end

  def type(); end

  def type=(type); end

  def visible?(context); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Field::ConnectionExtension
  def after_resolve(value:, object:, arguments:, context:, memo:); end
end

class GraphQL::Schema::Field::ConnectionExtension
end

class GraphQL::Schema::Field::ScopeExtension
  def after_resolve(value:, context:, **rest); end
end

class GraphQL::Schema::Field::ScopeExtension
end

class GraphQL::Schema::Field
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  def self.connection_extension(new_extension_class=T.unsafe(nil)); end

  def self.from_options(name=T.unsafe(nil), type=T.unsafe(nil), desc=T.unsafe(nil), resolver: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), **kwargs, &block); end
end

class GraphQL::Schema::FieldExtension
  def after_resolve(object:, arguments:, context:, value:, memo:); end

  def apply(); end

  def field(); end

  def initialize(field:, options:); end

  def options(); end

  def resolve(object:, arguments:, context:); end
end

class GraphQL::Schema::FieldExtension
end

module GraphQL::Schema::FindInheritedValue
end

module GraphQL::Schema::FindInheritedValue::EmptyObjects
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::FindInheritedValue::EmptyObjects
end

module GraphQL::Schema::FindInheritedValue
  def self.extended(child_cls); end

  def self.included(child_cls); end
end

class GraphQL::Schema::Finder
  def find(path); end

  def initialize(schema); end
end

class GraphQL::Schema::Finder::MemberNotFoundError
end

class GraphQL::Schema::Finder::MemberNotFoundError
end

class GraphQL::Schema::Finder
end

class GraphQL::Schema::InputObject
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Dig
  def [](key); end

  def any?(*args, &block); end

  def arguments(); end

  def context(); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def initialize(arguments=T.unsafe(nil), context:, defaults_used:, ruby_kwargs: T.unsafe(nil)); end

  def key?(key); end

  def keys(*args, &block); end

  def map(*args, &block); end

  def prepare(); end

  def to_h(); end

  def to_hash(); end

  def to_kwargs(); end

  def unwrap_value(value); end

  def values(*args, &block); end
end

class GraphQL::Schema::InputObject
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.arguments_class(); end

  def self.arguments_class=(arguments_class); end

  def self.coerce_input(value, ctx); end

  def self.coerce_result(value, ctx); end

  def self.validate_non_null_input(input, ctx); end
end

module GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  def unwrap(); end
end

module GraphQL::Schema::Interface::DefinitionMethods
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Relay::TypeExtensions
  include ::GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::TypeSystemHelpers
  include ::GraphQL::Schema::Member::HasFields
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::RelayShortcuts
  include ::GraphQL::Schema::Member::Scoped
  include ::GraphQL::Schema::Member::HasAstNode
  include ::GraphQL::Schema::Member::HasUnresolvedTypeError
  include ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def accessible?(context); end

  def definition_methods(&block); end

  def included(child_class); end

  def interfaces(); end

  def kind(); end

  def orphan_types(*types); end

  def own_interfaces(); end

  def to_graphql(); end

  def type_membership_class(membership_class=T.unsafe(nil)); end

  def visible?(context); end
end

module GraphQL::Schema::Interface::DefinitionMethods
end

module GraphQL::Schema::Interface
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema::IntrospectionSystem
  def dynamic_field(name:); end

  def dynamic_fields(); end

  def entry_point(name:); end

  def entry_points(); end

  def initialize(schema); end

  def possible_types(); end

  def resolve_late_bindings(); end

  def types(); end
end

class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
  def call(obj, args, ctx); end

  def initialize(object_class:, inner_resolve:); end
end

class GraphQL::Schema::IntrospectionSystem::PerFieldProxyResolve
end

class GraphQL::Schema::IntrospectionSystem
end

class GraphQL::Schema::InvalidDocumentError
end

class GraphQL::Schema::InvalidDocumentError
end

class GraphQL::Schema::InvalidTypeError
end

class GraphQL::Schema::InvalidTypeError
end

class GraphQL::Schema::LateBoundType
  def graphql_name(); end

  def initialize(local_name); end

  def name(); end

  def to_list_type(); end

  def to_non_null_type(); end

  def unwrap(); end
end

class GraphQL::Schema::LateBoundType
end

module GraphQL::Schema::LazyHandlingMethods
  def after_any_lazies(maybe_lazies); end

  def after_lazy(value, &block); end

  def lazy?(obj); end

  def lazy_method_name(obj); end

  def sync_lazy(value); end
end

module GraphQL::Schema::LazyHandlingMethods
end

class GraphQL::Schema::List
  include ::GraphQL::Schema::Member::ValidatesInput
  def coerce_input(value, ctx); end

  def coerce_result(value, ctx); end

  def description(); end

  def graphql_name(); end

  def validate_non_null_input(value, ctx); end
end

class GraphQL::Schema::List
end

module GraphQL::Schema::Loader
  def load(introspection_result); end
  NullScalarCoerce = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Loader
  extend ::GraphQL::Schema::Loader
  def self.build_arguments(arg_owner, args, type_resolver); end

  def self.build_fields(type_defn, fields, type_resolver); end
end

class GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Schema::Member::AcceptsDefinition
end

module GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  def accepts_definition(name); end

  def accepts_definition_methods(); end

  def own_accepts_definition_methods(); end
end

module GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accepts_definition_methods(); end

  def initialize(*args, **kwargs, &block); end
end

module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
end

module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def to_graphql(); end
end

module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

module GraphQL::Schema::Member::AcceptsDefinition
  def self.extended(child); end

  def self.included(child); end
end

module GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  def accessible?(context); end

  def authorized?(object, context); end

  def default_graphql_name(); end

  def description(new_description=T.unsafe(nil)); end

  def graphql_name(new_name=T.unsafe(nil)); end

  def introspection(new_introspection=T.unsafe(nil)); end

  def introspection?(); end

  def mutation(mutation_class=T.unsafe(nil)); end

  def name(new_name=T.unsafe(nil)); end

  def overridden_graphql_name(); end

  def to_graphql(); end

  def unwrap(); end

  def visible?(context); end
end

module GraphQL::Schema::Member::BaseDSLMethods
end

module GraphQL::Schema::Member::CachedGraphQLDefinition
  def graphql_definition(); end

  def type_class(); end
end

module GraphQL::Schema::Member::CachedGraphQLDefinition
end

module GraphQL::Schema::Member::GraphQLTypeNames
  Boolean = ::T.let(nil, ::T.untyped)
  ID = ::T.let(nil, ::T.untyped)
  Int = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Schema::Member::HasArguments
  def add_argument(arg_defn); end

  def argument_class(new_arg_class=T.unsafe(nil)); end

  def arguments(); end

  def arguments_statically_coercible?(); end

  def coerce_arguments(parent_object, values, context); end

  def get_argument(argument_name); end

  def own_arguments(); end
  NO_ARGUMENTS = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def load_application_object(argument, lookup_as_type, id, context); end

  def load_application_object_failed(err); end

  def object_from_id(type, id, context); end
end

module GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
end

module GraphQL::Schema::Member::HasArguments
  def self.extended(cls); end

  def self.included(cls); end
end

module GraphQL::Schema::Member::HasAstNode
  def ast_node(new_ast_node=T.unsafe(nil)); end
end

module GraphQL::Schema::Member::HasAstNode
end

module GraphQL::Schema::Member::HasFields
  def add_field(field_defn, method_conflict_warning: T.unsafe(nil)); end

  def fields(); end

  def get_field(field_name); end

  def global_id_field(field_name, **kwargs); end

  def own_fields(); end
  CONFLICT_FIELD_NAMES = ::T.let(nil, ::T.untyped)
  GRAPHQL_RUBY_KEYWORDS = ::T.let(nil, ::T.untyped)
  RUBY_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Member::HasPath
  def path(); end
end

module GraphQL::Schema::Member::HasPath
end

module GraphQL::Schema::Member::HasUnresolvedTypeError
end

module GraphQL::Schema::Member::HasUnresolvedTypeError
end

module GraphQL::Schema::Member::RelayShortcuts
  def connection_type(); end

  def connection_type_class(new_connection_type_class=T.unsafe(nil)); end

  def edge_type(); end

  def edge_type_class(new_edge_type_class=T.unsafe(nil)); end
end

module GraphQL::Schema::Member::RelayShortcuts
end

module GraphQL::Schema::Member::Scoped
  def scope_items(items, context); end
end

module GraphQL::Schema::Member::Scoped
end

module GraphQL::Schema::Member::TypeSystemHelpers
  def kind(); end

  def list?(); end

  def non_null?(); end

  def to_list_type(); end

  def to_non_null_type(); end

  def to_type_signature(); end
end

module GraphQL::Schema::Member::TypeSystemHelpers
end

module GraphQL::Schema::Member::ValidatesInput
  def coerce_isolated_input(v); end

  def coerce_isolated_result(v); end

  def valid_input?(val, ctx); end

  def valid_isolated_input?(v); end

  def validate_input(val, ctx); end
end

module GraphQL::Schema::Member::ValidatesInput
end

class GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::HasAstNode
end

class GraphQL::Schema::MiddlewareChain
  def <<(callable); end

  def ==(other); end

  def [](*args, &block); end

  def concat(callables); end

  def delete(*args, &block); end

  def final_step(); end

  def first(*args, &block); end

  def initialize(steps: T.unsafe(nil), final_step: T.unsafe(nil)); end

  def insert(*args, &block); end

  def invoke(arguments); end

  def push(callable); end

  def steps(); end
end

class GraphQL::Schema::MiddlewareChain::MiddlewareWrapper
  def call(*args, &next_middleware); end

  def callable(); end

  def initialize(callable); end
end

class GraphQL::Schema::MiddlewareChain::MiddlewareWrapper
end

class GraphQL::Schema::MiddlewareChain
  extend ::Forwardable
end

class GraphQL::Schema::Mutation
end

class GraphQL::Schema::Mutation
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Resolver::HasPayloadType
end

class GraphQL::Schema::NonNull
  include ::GraphQL::Schema::Member::ValidatesInput
  def coerce_input(value, ctx); end

  def coerce_result(value, ctx); end

  def description(); end

  def graphql_name(); end

  def validate_input(value, ctx); end
end

class GraphQL::Schema::NonNull
end

module GraphQL::Schema::NullMask
end

module GraphQL::Schema::NullMask
  def self.call(member, ctx); end
end

class GraphQL::Schema::Object
  def context(); end

  def initialize(object, context); end

  def object(); end
end

class GraphQL::Schema::Object
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.authorized_new(object, context); end

  def self.implements(*new_interfaces, **options); end

  def self.interface_type_memberships(); end

  def self.interfaces(context=T.unsafe(nil)); end

  def self.own_interface_type_memberships(); end
end

class GraphQL::Schema::PossibleTypes
  def initialize(schema); end

  def interface_implementers(ctx, type_defn); end

  def possible_types(type_defn, ctx); end
end

class GraphQL::Schema::PossibleTypes
end

class GraphQL::Schema::Printer
  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), introspection: T.unsafe(nil)); end

  def print_schema(); end

  def print_type(type); end

  def schema(); end

  def warden(); end
end

class GraphQL::Schema::Printer::IntrospectionPrinter
end

class GraphQL::Schema::Printer::IntrospectionPrinter
end

class GraphQL::Schema::Printer
  def self.print_introspection_schema(); end

  def self.print_schema(schema, **args); end
end

class GraphQL::Schema::RelayClassicMutation
  def resolve_with_support(**inputs); end
end

class GraphQL::Schema::RelayClassicMutation
  def self.input_object_class(new_class=T.unsafe(nil)); end

  def self.input_type(new_input_type=T.unsafe(nil)); end
end

class GraphQL::Schema::RescueMiddleware
  def call(*args); end

  def remove_handler(*error_classes); end

  def rescue_from(*error_classes, &block); end

  def rescue_table(); end
end

class GraphQL::Schema::RescueMiddleware
end

class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::HasPath
  def arguments(); end

  def authorized?(**inputs); end

  def context(); end

  def field(); end

  def initialize(object:, context:, field:); end

  def object(); end

  def ready?(**args); end

  def resolve(**args); end

  def resolve_with_support(**args); end
end

module GraphQL::Schema::Resolver::HasPayloadType
  def field_class(new_class=T.unsafe(nil)); end

  def object_class(new_class=T.unsafe(nil)); end

  def payload_type(new_payload_type=T.unsafe(nil)); end

  def type(new_payload_type=T.unsafe(nil)); end

  def type_expr(new_payload_type=T.unsafe(nil)); end
end

module GraphQL::Schema::Resolver::HasPayloadType
end

class GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasPath
  def self.arguments_loads_as_type(); end

  def self.broadcastable(new_broadcastable); end

  def self.broadcastable?(); end

  def self.complexity(new_complexity=T.unsafe(nil)); end

  def self.extension(extension, **options); end

  def self.extensions(); end

  def self.extras(new_extras=T.unsafe(nil)); end

  def self.field_options(); end

  def self.null(allow_null=T.unsafe(nil)); end

  def self.resolve_method(new_method=T.unsafe(nil)); end

  def self.type(new_type=T.unsafe(nil), null: T.unsafe(nil)); end

  def self.type_expr(); end
end

class GraphQL::Schema::Scalar
end

class GraphQL::Schema::Scalar
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::ValidatesInput
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.coerce_input(val, ctx); end

  def self.coerce_result(val, ctx); end

  def self.default_scalar(is_default=T.unsafe(nil)); end

  def self.default_scalar?(); end

  def self.validate_non_null_input(value, ctx); end
end

class GraphQL::Schema::Subscription
  def resolve_subscribe(**args); end

  def resolve_update(**args); end

  def subscribe(args=T.unsafe(nil)); end

  def unsubscribe(); end

  def update(args=T.unsafe(nil)); end
  READING_SCOPE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Subscription
  extend ::GraphQL::Schema::Resolver::HasPayloadType
  extend ::GraphQL::Schema::Member::HasFields
  def self.subscription_scope(new_scope=T.unsafe(nil)); end
end

class GraphQL::Schema::Timeout
  def handle_timeout(error, query); end

  def initialize(max_seconds:); end

  def max_seconds(query); end

  def trace(key, data); end
end

class GraphQL::Schema::Timeout::TimeoutError
  def initialize(parent_type, field); end
end

class GraphQL::Schema::Timeout::TimeoutError
end

class GraphQL::Schema::Timeout
  def self.use(schema, **options); end
end

class GraphQL::Schema::TimeoutMiddleware
  def call(parent_type, parent_object, field_definition, field_args, query_context); end

  def initialize(max_seconds:, context_key: T.unsafe(nil), &block); end

  def on_timeout(parent_type, parent_object, field_definition, field_args, field_context); end
end

class GraphQL::Schema::TimeoutMiddleware::TimeoutError
  def initialize(parent_type, field_defn); end
end

class GraphQL::Schema::TimeoutMiddleware::TimeoutError
end

class GraphQL::Schema::TimeoutMiddleware::TimeoutQueryProxy
  def context(); end

  def initialize(query, ctx); end
end

class GraphQL::Schema::TimeoutMiddleware::TimeoutQueryProxy
end

class GraphQL::Schema::TimeoutMiddleware
end

class GraphQL::Schema::Traversal
  def initialize(schema, introspection: T.unsafe(nil)); end

  def instrumented_field_map(); end

  def type_map(); end

  def type_reference_map(); end

  def union_memberships(); end
end

class GraphQL::Schema::Traversal
end

module GraphQL::Schema::TypeExpression
end

module GraphQL::Schema::TypeExpression
  def self.build_type(type_owner, ast_node); end
end

class GraphQL::Schema::TypeMembership
  def abstract_type(); end

  def initialize(abstract_type, object_type, **options); end

  def object_type(); end

  def object_type=(object_type); end

  def visible?(_ctx); end
end

class GraphQL::Schema::TypeMembership
end

class GraphQL::Schema::Union
end

class GraphQL::Schema::Union
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.assign_type_membership_object_type(object_type); end

  def self.possible_types(*types, context: T.unsafe(nil), **options); end

  def self.type_membership_class(membership_class=T.unsafe(nil)); end

  def self.type_memberships(); end
end

module GraphQL::Schema::UniqueWithinType
end

module GraphQL::Schema::UniqueWithinType
  def self.decode(node_id, separator: T.unsafe(nil)); end

  def self.default_id_separator(); end

  def self.default_id_separator=(default_id_separator); end

  def self.encode(type_name, object_value, separator: T.unsafe(nil)); end
end

class GraphQL::Schema::UnresolvedLateBoundTypeError
  def initialize(type:); end

  def type(); end
end

class GraphQL::Schema::UnresolvedLateBoundTypeError
end

class GraphQL::Schema::Validation
  RULES = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Validation::Rules
  ARGUMENTS_ARE_STRING_TO_ARGUMENT = ::T.let(nil, ::T.untyped)
  ARGUMENTS_ARE_VALID = ::T.let(nil, ::T.untyped)
  DEFAULT_VALUE_IS_VALID_FOR_TYPE = ::T.let(nil, ::T.untyped)
  DEPRECATED_ARGUMENTS_ARE_OPTIONAL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_IS_STRING_OR_NIL = ::T.let(nil, ::T.untyped)
  FIELDS_ARE_VALID = ::T.let(nil, ::T.untyped)
  HAS_AT_LEAST_ONE_ARGUMENT = ::T.let(nil, ::T.untyped)
  HAS_AT_LEAST_ONE_FIELD = ::T.let(nil, ::T.untyped)
  HAS_ONE_OR_MORE_POSSIBLE_TYPES = ::T.let(nil, ::T.untyped)
  INTERFACES_ARE_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NAME_IS_STRING = ::T.let(nil, ::T.untyped)
  RESERVED_NAME = ::T.let(nil, ::T.untyped)
  RESERVED_TYPE_NAME = ::T.let(nil, ::T.untyped)
  SCHEMA_CAN_FETCH_IDS = ::T.let(nil, ::T.untyped)
  SCHEMA_CAN_GENERATE_IDS = ::T.let(nil, ::T.untyped)
  SCHEMA_CAN_RESOLVE_TYPES = ::T.let(nil, ::T.untyped)
  SCHEMA_INSTRUMENTERS_ARE_VALID = ::T.let(nil, ::T.untyped)
  TYPE_IS_VALID_INPUT_TYPE = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Validation::Rules
  def self.assert_named_items_are_valid(item_name, get_items_proc); end

  def self.assert_property(property_name, *allowed_classes); end

  def self.assert_property_list_of(property_name, list_member_class); end

  def self.assert_property_mapping(property_name, from_class, to_class); end

  def self.count_at_least(item_name, minimum_count, get_items_proc); end
end

class GraphQL::Schema::Validation
  def self.validate(object); end
end

class GraphQL::Schema::Warden
  def arguments(argument_owner); end

  def directives(); end

  def enum_values(enum_defn); end

  def fields(type_defn); end

  def get_argument(parent_type, argument_name); end

  def get_field(parent_type, field_name); end

  def get_type(type_name); end

  def initialize(filter, context:, schema:); end

  def interfaces(obj_type); end

  def possible_types(type_defn); end

  def reachable_type?(type_name); end

  def reachable_types(); end

  def root_type_for_operation(op_name); end

  def types(); end
  NO_REFERENCES = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Warden
end

class GraphQL::Schema::Wrapper
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::TypeSystemHelpers
  def ==(other); end

  def initialize(of_type); end

  def of_type(); end

  def to_graphql(); end

  def unwrap(); end
end

class GraphQL::Schema::Wrapper
end

class GraphQL::Schema
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::LazyHandlingMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.accessible?(member, ctx); end

  def self.add_subscription_extension_if_necessary(); end

  def self.analysis_engine(); end

  def self.analysis_engine=(analysis_engine); end

  def self.as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def self.connections(); end

  def self.connections=(connections); end

  def self.context_class(new_context_class=T.unsafe(nil)); end

  def self.cursor_encoder(new_encoder=T.unsafe(nil)); end

  def self.default_directives(); end

  def self.default_execution_strategy(); end

  def self.default_execution_strategy=(default_execution_strategy); end

  def self.default_filter(); end

  def self.default_mask(new_mask=T.unsafe(nil)); end

  def self.default_max_page_size(new_default_max_page_size=T.unsafe(nil)); end

  def self.directive(new_directive); end

  def self.directives(*new_directives); end

  def self.disable_introspection_entry_points(); end

  def self.disable_introspection_entry_points?(); end

  def self.disable_schema_introspection_entry_point(); end

  def self.disable_schema_introspection_entry_point?(); end

  def self.disable_type_introspection_entry_point(); end

  def self.disable_type_introspection_entry_point?(); end

  def self.error_bubbling(new_error_bubbling=T.unsafe(nil)); end

  def self.error_bubbling=(error_bubbling); end

  def self.error_handler(); end

  def self.error_handler=(error_handler); end

  def self.execute(query_str=T.unsafe(nil), **kwargs); end

  def self.execution_strategy_for_operation(*args, &block); end

  def self.find(path); end

  def self.from_definition(definition_or_path, default_resolve: T.unsafe(nil), interpreter: T.unsafe(nil), parser: T.unsafe(nil), using: T.unsafe(nil)); end

  def self.from_introspection(introspection_result); end

  def self.get_field(type_or_name, field_name); end

  def self.get_fields(type); end

  def self.get_type(type_name); end

  def self.graphql_definition(); end

  def self.id_from_object(object, type, ctx); end

  def self.id_from_object=(*args, &block); end

  def self.id_from_object_proc(*args, &block); end

  def self.inaccessible_fields(error); end

  def self.inherited(child_class); end

  def self.instrument(instrument_step, instrumenter, options=T.unsafe(nil)); end

  def self.instrumenters(); end

  def self.interpreter=(interpreter); end

  def self.interpreter?(); end

  def self.introspection(new_introspection_namespace=T.unsafe(nil)); end

  def self.introspection_system(); end

  def self.lazy_resolve(lazy_class, value_method); end

  def self.max_complexity(max_complexity=T.unsafe(nil)); end

  def self.max_complexity=(max_complexity); end

  def self.max_depth(new_max_depth=T.unsafe(nil)); end

  def self.max_depth=(max_depth); end

  def self.metadata(*args, &block); end

  def self.middleware(new_middleware=T.unsafe(nil)); end

  def self.multiplex(queries, **kwargs); end

  def self.multiplex_analyzer(new_analyzer); end

  def self.multiplex_analyzers(); end

  def self.mutation(new_mutation_object=T.unsafe(nil)); end

  def self.mutation_execution_strategy(new_mutation_execution_strategy=T.unsafe(nil)); end

  def self.new_connections?(); end

  def self.object_from_id(node_id, ctx); end

  def self.object_from_id=(*args, &block); end

  def self.object_from_id_proc(*args, &block); end

  def self.orphan_types(*new_orphan_types); end

  def self.parse_error(parse_err, ctx); end

  def self.plugins(); end

  def self.possible_types(type=T.unsafe(nil), context=T.unsafe(nil)); end

  def self.query(new_query_object=T.unsafe(nil)); end

  def self.query_analyzer(new_analyzer); end

  def self.query_analyzers(); end

  def self.query_execution_strategy(new_query_execution_strategy=T.unsafe(nil)); end

  def self.query_stack_error(query, err); end

  def self.redefine(*args, &block); end

  def self.references_to(to_type=T.unsafe(nil), from: T.unsafe(nil)); end

  def self.remove_handler(*args, &block); end

  def self.rescue_from(*err_classes, &handler_block); end

  def self.rescues(); end

  def self.resolve_type(type, obj, ctx); end

  def self.root_type_for_operation(operation); end

  def self.root_types(); end

  def self.static_validator(); end

  def self.subscription(new_subscription_object=T.unsafe(nil)); end

  def self.subscription_execution_strategy(new_subscription_execution_strategy=T.unsafe(nil)); end

  def self.subscriptions(); end

  def self.subscriptions=(subscriptions); end

  def self.to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def self.to_document(); end

  def self.to_json(**args); end

  def self.tracer(new_tracer); end

  def self.tracers(); end

  def self.type_error(type_err, ctx); end

  def self.type_from_ast(ast_node, context: T.unsafe(nil)); end

  def self.types(); end

  def self.unauthorized_field(unauthorized_error); end

  def self.unauthorized_object(unauthorized_error); end

  def self.union_memberships(type=T.unsafe(nil)); end

  def self.use(plugin, **kwargs); end

  def self.using_ast_analysis?(); end

  def self.validate(*args, &block); end

  def self.visible?(member, ctx); end
end

module GraphQL::StaticValidation
  ALL_RULES = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  def on_argument(node, parent); end
end

module GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError
  def argument_name(); end

  def code(); end

  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil), argument: T.unsafe(nil), extensions: T.unsafe(nil), coerce_extensions: T.unsafe(nil)); end

  def type_name(); end
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatibleError
end

module GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  def on_directive(node, parent); end

  def on_field(node, parent); end

  def validate_arguments(node); end
end

module GraphQL::StaticValidation::ArgumentNamesAreUnique
end

class GraphQL::StaticValidation::ArgumentNamesAreUniqueError
  def code(); end

  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def name(); end
end

class GraphQL::StaticValidation::ArgumentNamesAreUniqueError
end

module GraphQL::StaticValidation::ArgumentsAreDefined
  def on_argument(node, parent); end
end

module GraphQL::StaticValidation::ArgumentsAreDefined
end

class GraphQL::StaticValidation::ArgumentsAreDefinedError
  def argument_name(); end

  def code(); end

  def initialize(message, name:, type:, argument:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def name(); end

  def type_name(); end
end

class GraphQL::StaticValidation::ArgumentsAreDefinedError
end

class GraphQL::StaticValidation::BaseVisitor
  def context(); end

  def initialize(document, context); end

  def object_types(); end

  def path(); end

  def rewrite_document(); end
end

module GraphQL::StaticValidation::BaseVisitor::ContextMethods
  def argument_definition(); end

  def directive_definition(); end

  def field_definition(); end

  def on_argument(node, parent); end

  def on_directive(node, parent); end

  def on_field(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object(node, parent); end

  def on_operation_definition(node, parent); end

  def parent_type_definition(); end

  def type_definition(); end
end

module GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::BaseVisitor
  def self.including_rules(rules, rewrite: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::DefaultVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::DefaultVisitor
end

module GraphQL::StaticValidation::DefinitionDependencies
  def dependencies(); end

  def dependency_map(&block); end

  def initialize(*_); end

  def on_document(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_operation_definition(node, prev_node); end
end

class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
  def [](definition_node); end

  def cyclical_definitions(); end

  def unmet_dependencies(); end

  def unused_dependencies(); end
end

class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  def eql?(*args, &block); end

  def hash(*args, &block); end

  def initialize(node, path); end

  def name(*args, &block); end

  def node(); end

  def path(); end
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  extend ::Forwardable
end

module GraphQL::StaticValidation::DefinitionDependencies
end

module GraphQL::StaticValidation::DirectivesAreDefined
  def initialize(*_); end

  def on_directive(node, parent); end
end

module GraphQL::StaticValidation::DirectivesAreDefined
end

class GraphQL::StaticValidation::DirectivesAreDefinedError
  def code(); end

  def directive_name(); end

  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::DirectivesAreDefinedError
end

module GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language
  def on_directive(node, parent); end
  LOCATION_MESSAGE_NAMES = ::T.let(nil, ::T.untyped)
  SIMPLE_LOCATIONS = ::T.let(nil, ::T.untyped)
  SIMPLE_LOCATION_NODES = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::DirectivesAreInValidLocations
end

class GraphQL::StaticValidation::DirectivesAreInValidLocationsError
  def code(); end

  def initialize(message, target:, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def name(); end

  def target_name(); end
end

class GraphQL::StaticValidation::DirectivesAreInValidLocationsError
end

class GraphQL::StaticValidation::Error
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def message(); end

  def path(); end

  def path=(path); end

  def to_h(); end
end

module GraphQL::StaticValidation::Error::ErrorHelper
  def error(error_message, nodes, context: T.unsafe(nil), path: T.unsafe(nil), extensions: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::Error::ErrorHelper
end

class GraphQL::StaticValidation::Error
end

module GraphQL::StaticValidation::FieldsAreDefinedOnType
  def on_field(node, parent); end
end

module GraphQL::StaticValidation::FieldsAreDefinedOnType
end

class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError
  def code(); end

  def field_name(); end

  def initialize(message, type:, field:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end
end

class GraphQL::StaticValidation::FieldsAreDefinedOnTypeError
end

module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  def on_field(node, parent); end

  def on_operation_definition(node, _parent); end
end

module GraphQL::StaticValidation::FieldsHaveAppropriateSelections
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError
  def code(); end

  def initialize(message, node_name:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def node_name(); end

  def type_name(); end
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelectionsError
end

module GraphQL::StaticValidation::FieldsWillMerge
  def initialize(*_); end

  def on_field(node, _parent); end

  def on_operation_definition(node, _parent); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
  NO_SELECTIONS = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::FieldsWillMerge::Field
  def definition(); end

  def definition=(_); end

  def node(); end

  def node=(_); end

  def owner_type(); end

  def owner_type=(_); end

  def parents(); end

  def parents=(_); end
end

class GraphQL::StaticValidation::FieldsWillMerge::Field
  def self.[](*_); end

  def self.members(); end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread
  def name(); end

  def name=(_); end

  def parents(); end

  def parents=(_); end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread
  def self.[](*_); end

  def self.members(); end
end

module GraphQL::StaticValidation::FieldsWillMerge
end

class GraphQL::StaticValidation::FieldsWillMergeError
  def code(); end

  def conflicts(); end

  def field_name(); end

  def initialize(message, field_name:, conflicts:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::FieldsWillMergeError
end

module GraphQL::StaticValidation::FragmentNamesAreUnique
  def initialize(*_); end

  def on_document(_n, _p); end

  def on_fragment_definition(node, parent); end
end

module GraphQL::StaticValidation::FragmentNamesAreUnique
end

class GraphQL::StaticValidation::FragmentNamesAreUniqueError
  def code(); end

  def fragment_name(); end

  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::FragmentNamesAreUniqueError
end

module GraphQL::StaticValidation::FragmentSpreadsArePossible
  def initialize(*_); end

  def on_document(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
  def initialize(node:, parent_type:, path:); end

  def node(); end

  def parent_type(); end

  def path(); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
end

module GraphQL::StaticValidation::FragmentSpreadsArePossible
end

class GraphQL::StaticValidation::FragmentSpreadsArePossibleError
  def code(); end

  def fragment_name(); end

  def initialize(message, type:, fragment_name:, parent:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def parent_name(); end

  def type_name(); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossibleError
end

module GraphQL::StaticValidation::FragmentTypesExist
  def on_fragment_definition(node, _parent); end

  def on_inline_fragment(node, _parent); end
end

module GraphQL::StaticValidation::FragmentTypesExist
end

class GraphQL::StaticValidation::FragmentTypesExistError
  def code(); end

  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end
end

class GraphQL::StaticValidation::FragmentTypesExistError
end

module GraphQL::StaticValidation::FragmentsAreFinite
  def on_document(_n, _p); end
end

module GraphQL::StaticValidation::FragmentsAreFinite
end

class GraphQL::StaticValidation::FragmentsAreFiniteError
  def code(); end

  def fragment_name(); end

  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::FragmentsAreFiniteError
end

module GraphQL::StaticValidation::FragmentsAreNamed
  def on_fragment_definition(node, _parent); end
end

module GraphQL::StaticValidation::FragmentsAreNamed
end

class GraphQL::StaticValidation::FragmentsAreNamedError
  def code(); end
end

class GraphQL::StaticValidation::FragmentsAreNamedError
end

module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  def on_fragment_definition(node, parent); end

  def on_inline_fragment(node, parent); end
end

module GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError
  def argument_name(); end

  def code(); end

  def initialize(message, type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypesError
end

module GraphQL::StaticValidation::FragmentsAreUsed
  def on_document(node, parent); end
end

module GraphQL::StaticValidation::FragmentsAreUsed
end

class GraphQL::StaticValidation::FragmentsAreUsedError
  def code(); end

  def fragment_name(); end

  def initialize(message, fragment:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::FragmentsAreUsedError
end

class GraphQL::StaticValidation::InterpreterVisitor
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::InterpreterVisitor
end

class GraphQL::StaticValidation::LiteralValidator
  def initialize(context:); end

  def validate(ast_value, type); end
end

class GraphQL::StaticValidation::LiteralValidator
end

module GraphQL::StaticValidation::MutationRootExists
  def on_operation_definition(node, _parent); end
end

module GraphQL::StaticValidation::MutationRootExists
end

class GraphQL::StaticValidation::MutationRootExistsError
  def code(); end
end

class GraphQL::StaticValidation::MutationRootExistsError
end

module GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
  def initialize(*_); end

  def on_directive_definition(node, parent); end

  def on_document(node, parent); end

  def on_enum_type_definition(node, parent); end

  def on_enum_type_extension(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_object_type_extension(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_interface_type_extension(node, parent); end

  def on_invalid_node(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_object_type_extension(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_scalar_type_extension(node, parent); end

  def on_schema_definition(node, parent); end

  def on_schema_extension(node, parent); end

  def on_union_type_definition(node, parent); end

  def on_union_type_extension(node, parent); end
end

module GraphQL::StaticValidation::NoDefinitionsArePresent
end

class GraphQL::StaticValidation::NoDefinitionsArePresentError
  def code(); end
end

class GraphQL::StaticValidation::NoDefinitionsArePresentError
end

class GraphQL::StaticValidation::NoValidateVisitor
  include ::GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DefinitionDependencies
  include ::GraphQL::StaticValidation::BaseVisitor::ContextMethods
end

class GraphQL::StaticValidation::NoValidateVisitor
end

module GraphQL::StaticValidation::OperationNamesAreValid
  def initialize(*_); end

  def on_document(node, parent); end

  def on_operation_definition(node, parent); end
end

module GraphQL::StaticValidation::OperationNamesAreValid
end

class GraphQL::StaticValidation::OperationNamesAreValidError
  def code(); end

  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil), name: T.unsafe(nil)); end

  def operation_name(); end
end

class GraphQL::StaticValidation::OperationNamesAreValidError
end

module GraphQL::StaticValidation::RequiredArgumentsArePresent
  def on_directive(node, _parent); end

  def on_field(node, _parent); end
end

module GraphQL::StaticValidation::RequiredArgumentsArePresent
end

class GraphQL::StaticValidation::RequiredArgumentsArePresentError
  def arguments(); end

  def class_name(); end

  def code(); end

  def initialize(message, class_name:, name:, arguments:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def name(); end
end

class GraphQL::StaticValidation::RequiredArgumentsArePresentError
end

module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  def on_input_object(node, parent); end
end

module GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
end

class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError
  def argument_name(); end

  def argument_type(); end

  def code(); end

  def initialize(message, path:, nodes:, argument_type:, argument_name:, input_object_type:); end

  def input_object_type(); end
end

class GraphQL::StaticValidation::RequiredInputObjectAttributesArePresentError
end

module GraphQL::StaticValidation::SubscriptionRootExists
  def on_operation_definition(node, _parent); end
end

module GraphQL::StaticValidation::SubscriptionRootExists
end

class GraphQL::StaticValidation::SubscriptionRootExistsError
  def code(); end
end

class GraphQL::StaticValidation::SubscriptionRootExistsError
end

class GraphQL::StaticValidation::TypeStack
  def argument_definitions(); end

  def directive_definitions(); end

  def field_definitions(); end

  def initialize(schema, visitor); end

  def object_types(); end

  def path(); end

  def schema(); end
  PUSH_STRATEGIES = ::T.let(nil, ::T.untyped)
  TYPE_INFERRENCE_ROOTS = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
  def call(node, parent); end

  def initialize(stack, strategy); end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def self.push_path_member(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def pop(stack, node); end

  def push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def self.push_path_member(stack, node); end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
  def call(node, parent); end

  def initialize(stack, strategy); end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

class GraphQL::StaticValidation::TypeStack
end

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end

  def on_enum_value_definition(node, parent); end

  def on_field(node, parent); end

  def on_field_definition(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_value_definition(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_operation_definition(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_union_type_definition(node, parent); end
  DIRECTIVE_NODE_HOOKS = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
end

class GraphQL::StaticValidation::UniqueDirectivesPerLocationError
  def code(); end

  def directive_name(); end

  def initialize(message, directive:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::UniqueDirectivesPerLocationError
end

class GraphQL::StaticValidation::ValidationContext
  def argument_definition(*args, &block); end

  def dependencies(*args, &block); end

  def directive_definition(*args, &block); end

  def document(*args, &block); end

  def errors(); end

  def field_definition(*args, &block); end

  def fragments(*args, &block); end

  def initialize(query, visitor_class); end

  def object_types(*args, &block); end

  def on_dependency_resolve(&handler); end

  def on_dependency_resolve_handlers(); end

  def operations(*args, &block); end

  def parent_type_definition(*args, &block); end

  def path(*args, &block); end

  def query(); end

  def schema(*args, &block); end

  def type_definition(*args, &block); end

  def validate_literal(ast_value, type); end

  def visitor(); end

  def warden(*args, &block); end
end

class GraphQL::StaticValidation::ValidationContext
  extend ::Forwardable
end

class GraphQL::StaticValidation::Validator
  def initialize(schema:, rules: T.unsafe(nil)); end

  def validate(query, validate: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::Validator
end

module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  def on_variable_definition(node, parent); end
end

module GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError
  def code(); end

  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil), type: T.unsafe(nil)); end

  def type_name(); end

  def variable_name(); end

  def violation(); end
  VIOLATIONS = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTypedError
end

module GraphQL::StaticValidation::VariableNamesAreUnique
  def on_operation_definition(node, parent); end
end

module GraphQL::StaticValidation::VariableNamesAreUnique
end

class GraphQL::StaticValidation::VariableNamesAreUniqueError
  def code(); end

  def initialize(message, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def variable_name(); end
end

class GraphQL::StaticValidation::VariableNamesAreUniqueError
end

module GraphQL::StaticValidation::VariableUsagesAreAllowed
  def initialize(*_); end

  def on_argument(node, parent); end

  def on_operation_definition(node, parent); end
end

module GraphQL::StaticValidation::VariableUsagesAreAllowed
end

class GraphQL::StaticValidation::VariableUsagesAreAllowedError
  def argument_name(); end

  def code(); end

  def error_message(); end

  def initialize(message, type:, name:, argument:, error:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end

  def variable_name(); end
end

class GraphQL::StaticValidation::VariableUsagesAreAllowedError
end

module GraphQL::StaticValidation::VariablesAreInputTypes
  def on_variable_definition(node, parent); end
end

module GraphQL::StaticValidation::VariablesAreInputTypes
end

class GraphQL::StaticValidation::VariablesAreInputTypesError
  def code(); end

  def initialize(message, type:, name:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def type_name(); end

  def variable_name(); end
end

class GraphQL::StaticValidation::VariablesAreInputTypesError
end

module GraphQL::StaticValidation::VariablesAreUsedAndDefined
  def initialize(*_); end

  def on_document(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_operation_definition(node, parent); end

  def on_variable_identifier(node, parent); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
  def ast_node(); end

  def ast_node=(ast_node); end

  def declared?(); end

  def declared_by(); end

  def declared_by=(declared_by); end

  def path(); end

  def path=(path); end

  def used?(); end

  def used_by(); end

  def used_by=(used_by); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
end

module GraphQL::StaticValidation::VariablesAreUsedAndDefined
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError
  def code(); end

  def initialize(message, name:, error_type:, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def variable_name(); end

  def violation(); end
  VIOLATIONS = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefinedError
end

module GraphQL::StaticValidation
end

module GraphQL::StringDedupBackport
end

module GraphQL::StringDedupBackport
end

class GraphQL::StringEncodingError
  def initialize(str); end

  def string(); end
end

class GraphQL::StringEncodingError
end

module GraphQL::StringMatchBackport
end

module GraphQL::StringMatchBackport
end

class GraphQL::Subscriptions
  def broadcastable?(query_str, **query_options); end

  def build_id(); end

  def default_broadcastable(); end

  def delete_subscription(subscription_id); end

  def deliver(subscription_id, result); end

  def each_subscription_id(event); end

  def execute(subscription_id, event, object); end

  def execute_all(event, object); end

  def execute_update(subscription_id, event, object); end

  def initialize(schema:, broadcast: T.unsafe(nil), default_broadcastable: T.unsafe(nil), **rest); end

  def normalize_name(event_or_arg_name); end

  def read_subscription(subscription_id); end

  def trigger(event_name, args, object, scope: T.unsafe(nil)); end

  def write_subscription(query, events); end
end

class GraphQL::Subscriptions::ActionCableSubscriptions
  def initialize(serializer: T.unsafe(nil), namespace: T.unsafe(nil), action_cable: T.unsafe(nil), action_cable_coder: T.unsafe(nil), **rest); end

  def setup_stream(channel, initial_event); end
  EVENT_PREFIX = ::T.let(nil, ::T.untyped)
  SUBSCRIPTION_PREFIX = ::T.let(nil, ::T.untyped)
end

class GraphQL::Subscriptions::ActionCableSubscriptions
end

class GraphQL::Subscriptions::BroadcastAnalyzer
end

class GraphQL::Subscriptions::BroadcastAnalyzer
end

class GraphQL::Subscriptions::DefaultSubscriptionResolveExtension
  def resolve(context:, object:, arguments:); end
end

class GraphQL::Subscriptions::DefaultSubscriptionResolveExtension
end

class GraphQL::Subscriptions::Event
  def arguments(); end

  def context(); end

  def fingerprint(); end

  def initialize(name:, arguments:, field: T.unsafe(nil), context: T.unsafe(nil), scope: T.unsafe(nil)); end

  def name(); end

  def topic(); end
end

class GraphQL::Subscriptions::Event
  def self.serialize(name, arguments, field, scope:); end
end

class GraphQL::Subscriptions::Instrumentation
  def after_query(query); end

  def before_query(query); end

  def initialize(schema:); end

  def instrument(type, field); end
end

class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
  def call(obj, args, ctx); end

  def initialize(inner_proc); end
end

class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
end

class GraphQL::Subscriptions::Instrumentation
end

class GraphQL::Subscriptions::InvalidTriggerError
end

class GraphQL::Subscriptions::InvalidTriggerError
end

module GraphQL::Subscriptions::Serialize
  GLOBALID_KEY = ::T.let(nil, ::T.untyped)
  OPEN_STRUCT_KEY = ::T.let(nil, ::T.untyped)
  SYMBOL_KEY = ::T.let(nil, ::T.untyped)
  SYMBOL_KEYS_KEY = ::T.let(nil, ::T.untyped)
  TIMESTAMP_FORMAT = ::T.let(nil, ::T.untyped)
  TIMESTAMP_KEY = ::T.let(nil, ::T.untyped)
end

module GraphQL::Subscriptions::Serialize
  def self.dump(obj); end

  def self.dump_recursive(obj); end

  def self.load(str); end
end

module GraphQL::Subscriptions::SubscriptionRoot
  def field(*args, extensions: T.unsafe(nil), **rest, &block); end
end

class GraphQL::Subscriptions::SubscriptionRoot::Extension
  def after_resolve(value:, context:, object:, arguments:, **rest); end
end

class GraphQL::Subscriptions::SubscriptionRoot::Extension
end

module GraphQL::Subscriptions::SubscriptionRoot::InstanceMethods
  def skip_subscription_root(*_); end
end

module GraphQL::Subscriptions::SubscriptionRoot::InstanceMethods
end

module GraphQL::Subscriptions::SubscriptionRoot
  def self.extended(child_cls); end
end

class GraphQL::Subscriptions
  def self.use(defn, options=T.unsafe(nil)); end
end

module GraphQL::Tracing
end

module GraphQL::Tracing::ActiveSupportNotificationsTracing
  KEYS = ::T.let(nil, ::T.untyped)
end

module GraphQL::Tracing::ActiveSupportNotificationsTracing
  def self.trace(key, metadata); end
end

class GraphQL::Tracing::AppOpticsTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, _key, data); end
  EXEC_KEYS = ::T.let(nil, ::T.untyped)
  PREP_KEYS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Tracing::AppOpticsTracing
  def self.version(); end
end

class GraphQL::Tracing::AppsignalTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::AppsignalTracing
end

class GraphQL::Tracing::DataDogTracing
  def analytics_available?(); end

  def analytics_enabled?(); end

  def analytics_sample_rate(); end

  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end

  def service_name(); end

  def tracer(); end
end

class GraphQL::Tracing::DataDogTracing
end

class GraphQL::Tracing::NewRelicTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::NewRelicTracing
end

module GraphQL::Tracing::NullTracer
end

module GraphQL::Tracing::NullTracer
  def self.trace(k, v); end
end

class GraphQL::Tracing::PlatformTracing
  def initialize(options=T.unsafe(nil)); end

  def instrument(type, field); end

  def trace(key, data); end

  def trace_field(type, field); end
end

class GraphQL::Tracing::PlatformTracing
  def self.platform_keys(); end

  def self.platform_keys=(platform_keys); end

  def self.use(schema_defn, options=T.unsafe(nil)); end
end

class GraphQL::Tracing::PrometheusTracing
  def initialize(opts=T.unsafe(nil)); end

  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data, &block); end
  DEFAULT_COLLECTOR_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_WHITELIST = ::T.let(nil, ::T.untyped)
end

class GraphQL::Tracing::PrometheusTracing
end

class GraphQL::Tracing::ScoutTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
  INSTRUMENT_OPTS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Tracing::ScoutTracing
end

class GraphQL::Tracing::SkylightTracing
  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::SkylightTracing
end

class GraphQL::Tracing::StatsdTracing
  def initialize(statsd:, **rest); end

  def platform_authorized_key(type); end

  def platform_field_key(type, field); end

  def platform_resolve_type_key(type); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::StatsdTracing
end

module GraphQL::Tracing::Traceable
  def trace(key, metadata, &block); end
end

module GraphQL::Tracing::Traceable
end

module GraphQL::Tracing
end

module GraphQL::TypeKinds
  ENUM = ::T.let(nil, ::T.untyped)
  INPUT_OBJECT = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  NON_NULL = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  SCALAR = ::T.let(nil, ::T.untyped)
  TYPE_KINDS = ::T.let(nil, ::T.untyped)
  UNION = ::T.let(nil, ::T.untyped)
end

class GraphQL::TypeKinds::TypeKind
  def abstract?(); end

  def composite?(); end

  def description(); end

  def enum?(); end

  def fields?(); end

  def initialize(name, abstract: T.unsafe(nil), fields: T.unsafe(nil), wraps: T.unsafe(nil), input: T.unsafe(nil), description: T.unsafe(nil)); end

  def input?(); end

  def input_object?(); end

  def interface?(); end

  def list?(); end

  def name(); end

  def non_null?(); end

  def object?(); end

  def resolves?(); end

  def scalar?(); end

  def union?(); end

  def wraps?(); end
end

class GraphQL::TypeKinds::TypeKind
end

module GraphQL::TypeKinds
end

module GraphQL::Types
end

class GraphQL::Types::BigInt
end

class GraphQL::Types::BigInt
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::Boolean
end

class GraphQL::Types::Boolean
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::Float
end

class GraphQL::Types::Float
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::ID
end

class GraphQL::Types::ID
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::ISO8601Date
end

class GraphQL::Types::ISO8601Date
  def self.coerce_input(str_value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::ISO8601DateTime
  DEFAULT_TIME_PRECISION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Types::ISO8601DateTime
  def self.coerce_input(str_value, _ctx); end

  def self.coerce_result(value, _ctx); end

  def self.time_precision(); end

  def self.time_precision=(value); end
end

class GraphQL::Types::Int
  MAX = ::T.let(nil, ::T.untyped)
  MIN = ::T.let(nil, ::T.untyped)
end

class GraphQL::Types::Int
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, ctx); end
end

class GraphQL::Types::JSON
end

class GraphQL::Types::JSON
  def self.coerce_input(value, _context); end

  def self.coerce_result(value, _context); end
end

module GraphQL::Types::Relay
  NodeField = ::T.let(nil, ::T.untyped)
  NodesField = ::T.let(nil, ::T.untyped)
end

class GraphQL::Types::Relay::BaseConnection
  def cursor_from_node(*args, &block); end

  def edges(); end

  def nodes(); end

  def parent(*args, &block); end
end

class GraphQL::Types::Relay::BaseConnection::InvalidNullError
end

class GraphQL::Types::Relay::BaseConnection::InvalidNullError
end

class GraphQL::Types::Relay::BaseConnection
  extend ::Forwardable
  def self.accessible?(ctx); end

  def self.authorized?(obj, ctx); end

  def self.edge_class(); end

  def self.edge_type(edge_type_class, edge_class: T.unsafe(nil), node_type: T.unsafe(nil), nodes_field: T.unsafe(nil), node_nullable: T.unsafe(nil)); end

  def self.node_type(); end

  def self.nodes_field(); end

  def self.visible?(ctx); end
end

class GraphQL::Types::Relay::BaseEdge
end

class GraphQL::Types::Relay::BaseEdge::InvalidNullError
end

class GraphQL::Types::Relay::BaseEdge::InvalidNullError
end

class GraphQL::Types::Relay::BaseEdge
  def self.accessible?(ctx); end

  def self.authorized?(obj, ctx); end

  def self.node_type(node_type=T.unsafe(nil), null: T.unsafe(nil)); end

  def self.visible?(ctx); end
end

class GraphQL::Types::Relay::BaseField
  def initialize(edge_class: T.unsafe(nil), **rest, &block); end
end

class GraphQL::Types::Relay::BaseField
end

module GraphQL::Types::Relay::BaseInterface
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  def default_relay(new_value); end

  def default_relay?(); end

  def to_graphql(); end
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
end

class GraphQL::Types::Relay::BaseInterface::UnresolvedTypeError
end

class GraphQL::Types::Relay::BaseInterface::UnresolvedTypeError
end

module GraphQL::Types::Relay::BaseInterface
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
end

class GraphQL::Types::Relay::BaseObject
end

class GraphQL::Types::Relay::BaseObject::InvalidNullError
end

class GraphQL::Types::Relay::BaseObject::InvalidNullError
end

class GraphQL::Types::Relay::BaseObject
  def self.default_relay(new_value); end

  def self.default_relay?(); end
end

module GraphQL::Types::Relay::Node
  include ::GraphQL::Types::Relay::BaseInterface
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

class GraphQL::Types::Relay::Node::UnresolvedTypeError
end

class GraphQL::Types::Relay::Node::UnresolvedTypeError
end

module GraphQL::Types::Relay::Node
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  extend ::GraphQL::Types::Relay::Node::DefinitionMethods
end

class GraphQL::Types::Relay::PageInfo
end

class GraphQL::Types::Relay::PageInfo::InvalidNullError
end

class GraphQL::Types::Relay::PageInfo::InvalidNullError
end

class GraphQL::Types::Relay::PageInfo
end

module GraphQL::Types::Relay
end

class GraphQL::Types::String
end

class GraphQL::Types::String
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, ctx); end
end

module GraphQL::Types
end

class GraphQL::UnauthorizedError
  def context(); end

  def initialize(message=T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil)); end

  def object(); end

  def type(); end
end

class GraphQL::UnauthorizedError
end

class GraphQL::UnauthorizedFieldError
  def field(); end

  def field=(field); end

  def initialize(message=T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil), field: T.unsafe(nil)); end
end

class GraphQL::UnauthorizedFieldError
end

class GraphQL::UnionType
  def add_possible_types(types, **options); end

  def get_possible_type(type_name, ctx); end

  def include?(child_type_defn, ctx=T.unsafe(nil)); end

  def kind(); end

  def possible_type?(type, ctx); end

  def possible_types(ctx=T.unsafe(nil)); end

  def possible_types=(types); end

  def resolve_type=(new_resolve_type_proc); end

  def resolve_type_proc(); end

  def resolve_type_proc=(resolve_type_proc); end

  def type_membership_class(); end

  def type_membership_class=(type_membership_class); end

  def type_memberships(); end

  def type_memberships=(type_memberships); end
end

class GraphQL::UnionType::AcceptPossibleTypesDefinition
end

class GraphQL::UnionType::AcceptPossibleTypesDefinition
  def self.call(target, possible_types, options=T.unsafe(nil)); end
end

class GraphQL::UnionType
end

class GraphQL::UnresolvedTypeError
  def field(); end

  def initialize(value, field, parent_type, resolved_type, possible_types); end

  def parent_type(); end

  def possible_types(); end

  def resolved_type(); end

  def value(); end
end

class GraphQL::UnresolvedTypeError
end

module GraphQL
  def self.default_parser(); end

  def self.default_parser=(default_parser); end

  def self.parse(graphql_string, tracer: T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_with_racc(string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end

  def self.scan(graphql_string); end

  def self.scan_with_ragel(graphql_string); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
end

class Hash
  def self.try_convert(_); end
end

class IO
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pressed?(); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IO
  def self.console(*_); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def evaluate(line, line_no, exception: T.unsafe(nil)); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect_last_value(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def initialize(file); end
end

class IRB::InputMethod
  def initialize(file=T.unsafe(nil)); end
end

class IRB::Inspector
  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end
end

class IRB::Irb
  def handle_exception(exc); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

class IRB::Notifier::AbstractNotifier
  def initialize(prefix, base_notifier); end
end

class IRB::Notifier::LeveledNotifier
  def initialize(base, level, prefix); end
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::ReadlineInputMethod
  def initialize(); end
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def initialize(); end
end

class IRB::WorkSpace
  def initialize(*main); end

  def local_variable_get(name); end

  def local_variable_set(name, value); end
end

module IRB
  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def byebug(); end

  def debugger(); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def remote_byebug(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class Method
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::MethodSource::MethodExtensions
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers
  def comment_describing(file, line_number); end

  def complete_expression?(str); end

  def expression_at(file, line_number, options=T.unsafe(nil)); end
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  def self.===(ex); end

  def self.rbx?(); end
end

module MethodSource::CodeHelpers
end

module MethodSource::MethodExtensions
  def comment(); end

  def source(); end
end

module MethodSource::MethodExtensions
  def self.included(klass); end
end

module MethodSource::ReeSourceLocation
  def source_location(); end
end

module MethodSource::ReeSourceLocation
end

module MethodSource::SourceLocation
end

module MethodSource::SourceLocation::MethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::MethodExtensions
end

module MethodSource::SourceLocation::ProcExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::ProcExtensions
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::UnboundMethodExtensions
end

module MethodSource::SourceLocation
end

class MethodSource::SourceNotFoundError
end

class MethodSource::SourceNotFoundError
end

module MethodSource
  extend ::MethodSource::CodeHelpers
  def self.comment_helper(source_location, name=T.unsafe(nil)); end

  def self.extract_code(source_location); end

  def self.lines_for(file_name, name=T.unsafe(nil)); end

  def self.source_helper(source_location, name=T.unsafe(nil)); end

  def self.valid_expression?(str); end
end

class Module
  def context(*a, &b); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def rake_extension(method); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def dclone(); end

  def pry(object=T.unsafe(nil), hash=T.unsafe(nil)); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RAKEVERSION = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLContext
  def add_certificate(*_); end

  def alpn_protocols(); end

  def alpn_protocols=(alpn_protocols); end

  def alpn_select_cb(); end

  def alpn_select_cb=(alpn_select_cb); end

  def enable_fallback_scsv(); end

  def max_version=(version); end

  def min_version=(version); end
  DEFAULT_TMP_DH_CALLBACK = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  def alpn_protocol(); end

  def tmp_key(); end
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.flat_map(*args, &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_find_pattern(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
end

class Parser::Base
  def builder(); end

  def context(); end

  def current_arg_stack(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def max_numparam_stack(); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def pattern_hash_keys(); end

  def pattern_variables(); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def array_pattern(lbrack_t, elements, rbrack_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def case_match(case_t, expr, in_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def const_pattern(const, ldelim_t, pattern, rdelim_t); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_endless_method(def_t, name_t, args, assignment_t, body); end

  def def_endless_singleton(def_t, definee, dot_t, name_t, args, assignment_t, body); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def find_pattern(lbrack_t, elements, rbrack_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def forward_arg(dots_t); end

  def forward_only_args(begin_t, dots_t, end_t); end

  def forwarded_args(dots_t); end

  def gvar(token); end

  def hash_pattern(lbrace_t, kwargs, rbrace_t); end

  def ident(token); end

  def if_guard(if_t, if_body); end

  def in_match(lhs, in_t, rhs); end

  def in_pattern(in_t, pattern, guard, then_t, body); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwnilarg(dstar_t, nil_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_alt(left, pipe_t, right); end

  def match_as(value, assoc_t, as); end

  def match_hash_var(name_t); end

  def match_hash_var_from_str(begin_t, strings, end_t); end

  def match_label(label_type, label); end

  def match_nil_pattern(dstar_t, nil_t); end

  def match_op(receiver, match_t, arg); end

  def match_pair(label_type, label, value); end

  def match_rest(star_t, name_t=T.unsafe(nil)); end

  def match_var(name_t); end

  def match_with_trailing_comma(match, comma_t); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def multi_rassign(lhs, assoc_t, rhs); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def numargs(max_numparam); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def pin(pin_t, var); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rassign(lhs, assoc_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def unless_guard(unless_t, unless_body); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_arg_inside_procarg0(); end

  def self.emit_arg_inside_procarg0=(emit_arg_inside_procarg0); end

  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_forward_arg(); end

  def self.emit_forward_arg=(emit_forward_arg); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def in_block?(); end

  def in_class?(); end

  def in_dynamic_block?(); end

  def in_lambda?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

class Parser::CurrentArgStack
  def pop(); end

  def push(value); end

  def reset(); end

  def set(value); end

  def stack(); end

  def top(); end
end

class Parser::CurrentArgStack
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(cmd_state); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def command_start(); end

  def command_start=(command_start); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def context(); end

  def context=(context); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
  TAB_WIDTH = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def supports_line_continuation_via_slash?(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

class Parser::MaxNumparamStack
  def has_numparams?(); end

  def has_ordinary_params!(); end

  def has_ordinary_params?(); end

  def pop(); end

  def push(); end

  def register(numparam); end

  def stack(); end

  def top(); end
end

class Parser::MaxNumparamStack
end

module Parser::Messages
end

module Parser::Messages
  def self.compile(reason, arguments); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*_); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Ruby24
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_110(val, _values, result); end

  def _reduce_111(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_118(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_122(val, _values, result); end

  def _reduce_123(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_17(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_196(val, _values, result); end

  def _reduce_197(val, _values, result); end

  def _reduce_198(val, _values, result); end

  def _reduce_199(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_200(val, _values, result); end

  def _reduce_201(val, _values, result); end

  def _reduce_202(val, _values, result); end

  def _reduce_203(val, _values, result); end

  def _reduce_204(val, _values, result); end

  def _reduce_205(val, _values, result); end

  def _reduce_206(val, _values, result); end

  def _reduce_207(val, _values, result); end

  def _reduce_208(val, _values, result); end

  def _reduce_209(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_210(val, _values, result); end

  def _reduce_211(val, _values, result); end

  def _reduce_212(val, _values, result); end

  def _reduce_213(val, _values, result); end

  def _reduce_214(val, _values, result); end

  def _reduce_215(val, _values, result); end

  def _reduce_216(val, _values, result); end

  def _reduce_217(val, _values, result); end

  def _reduce_218(val, _values, result); end

  def _reduce_219(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_220(val, _values, result); end

  def _reduce_221(val, _values, result); end

  def _reduce_222(val, _values, result); end

  def _reduce_223(val, _values, result); end

  def _reduce_224(val, _values, result); end

  def _reduce_225(val, _values, result); end

  def _reduce_226(val, _values, result); end

  def _reduce_227(val, _values, result); end

  def _reduce_228(val, _values, result); end

  def _reduce_229(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_230(val, _values, result); end

  def _reduce_231(val, _values, result); end

  def _reduce_232(val, _values, result); end

  def _reduce_233(val, _values, result); end

  def _reduce_234(val, _values, result); end

  def _reduce_235(val, _values, result); end

  def _reduce_236(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_241(val, _values, result); end

  def _reduce_242(val, _values, result); end

  def _reduce_244(val, _values, result); end

  def _reduce_245(val, _values, result); end

  def _reduce_246(val, _values, result); end

  def _reduce_248(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_251(val, _values, result); end

  def _reduce_252(val, _values, result); end

  def _reduce_253(val, _values, result); end

  def _reduce_254(val, _values, result); end

  def _reduce_255(val, _values, result); end

  def _reduce_256(val, _values, result); end

  def _reduce_257(val, _values, result); end

  def _reduce_258(val, _values, result); end

  def _reduce_259(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_260(val, _values, result); end

  def _reduce_261(val, _values, result); end

  def _reduce_262(val, _values, result); end

  def _reduce_263(val, _values, result); end

  def _reduce_264(val, _values, result); end

  def _reduce_265(val, _values, result); end

  def _reduce_266(val, _values, result); end

  def _reduce_267(val, _values, result); end

  def _reduce_269(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_270(val, _values, result); end

  def _reduce_271(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_282(val, _values, result); end

  def _reduce_283(val, _values, result); end

  def _reduce_284(val, _values, result); end

  def _reduce_285(val, _values, result); end

  def _reduce_286(val, _values, result); end

  def _reduce_287(val, _values, result); end

  def _reduce_288(val, _values, result); end

  def _reduce_289(val, _values, result); end

  def _reduce_290(val, _values, result); end

  def _reduce_291(val, _values, result); end

  def _reduce_292(val, _values, result); end

  def _reduce_293(val, _values, result); end

  def _reduce_294(val, _values, result); end

  def _reduce_295(val, _values, result); end

  def _reduce_296(val, _values, result); end

  def _reduce_297(val, _values, result); end

  def _reduce_298(val, _values, result); end

  def _reduce_299(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_300(val, _values, result); end

  def _reduce_301(val, _values, result); end

  def _reduce_303(val, _values, result); end

  def _reduce_304(val, _values, result); end

  def _reduce_305(val, _values, result); end

  def _reduce_306(val, _values, result); end

  def _reduce_307(val, _values, result); end

  def _reduce_308(val, _values, result); end

  def _reduce_309(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_310(val, _values, result); end

  def _reduce_311(val, _values, result); end

  def _reduce_312(val, _values, result); end

  def _reduce_313(val, _values, result); end

  def _reduce_314(val, _values, result); end

  def _reduce_315(val, _values, result); end

  def _reduce_316(val, _values, result); end

  def _reduce_317(val, _values, result); end

  def _reduce_318(val, _values, result); end

  def _reduce_319(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_320(val, _values, result); end

  def _reduce_321(val, _values, result); end

  def _reduce_322(val, _values, result); end

  def _reduce_323(val, _values, result); end

  def _reduce_324(val, _values, result); end

  def _reduce_325(val, _values, result); end

  def _reduce_326(val, _values, result); end

  def _reduce_327(val, _values, result); end

  def _reduce_328(val, _values, result); end

  def _reduce_329(val, _values, result); end

  def _reduce_330(val, _values, result); end

  def _reduce_331(val, _values, result); end

  def _reduce_332(val, _values, result); end

  def _reduce_333(val, _values, result); end

  def _reduce_337(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_341(val, _values, result); end

  def _reduce_343(val, _values, result); end

  def _reduce_346(val, _values, result); end

  def _reduce_347(val, _values, result); end

  def _reduce_348(val, _values, result); end

  def _reduce_349(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_351(val, _values, result); end

  def _reduce_352(val, _values, result); end

  def _reduce_353(val, _values, result); end

  def _reduce_354(val, _values, result); end

  def _reduce_355(val, _values, result); end

  def _reduce_356(val, _values, result); end

  def _reduce_357(val, _values, result); end

  def _reduce_358(val, _values, result); end

  def _reduce_359(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_360(val, _values, result); end

  def _reduce_361(val, _values, result); end

  def _reduce_362(val, _values, result); end

  def _reduce_363(val, _values, result); end

  def _reduce_364(val, _values, result); end

  def _reduce_365(val, _values, result); end

  def _reduce_366(val, _values, result); end

  def _reduce_367(val, _values, result); end

  def _reduce_368(val, _values, result); end

  def _reduce_369(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_371(val, _values, result); end

  def _reduce_372(val, _values, result); end

  def _reduce_373(val, _values, result); end

  def _reduce_374(val, _values, result); end

  def _reduce_375(val, _values, result); end

  def _reduce_376(val, _values, result); end

  def _reduce_377(val, _values, result); end

  def _reduce_378(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_380(val, _values, result); end

  def _reduce_381(val, _values, result); end

  def _reduce_382(val, _values, result); end

  def _reduce_383(val, _values, result); end

  def _reduce_384(val, _values, result); end

  def _reduce_385(val, _values, result); end

  def _reduce_386(val, _values, result); end

  def _reduce_387(val, _values, result); end

  def _reduce_388(val, _values, result); end

  def _reduce_389(val, _values, result); end

  def _reduce_39(val, _values, result); end

  def _reduce_391(val, _values, result); end

  def _reduce_392(val, _values, result); end

  def _reduce_393(val, _values, result); end

  def _reduce_394(val, _values, result); end

  def _reduce_395(val, _values, result); end

  def _reduce_396(val, _values, result); end

  def _reduce_397(val, _values, result); end

  def _reduce_398(val, _values, result); end

  def _reduce_399(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_400(val, _values, result); end

  def _reduce_401(val, _values, result); end

  def _reduce_402(val, _values, result); end

  def _reduce_403(val, _values, result); end

  def _reduce_404(val, _values, result); end

  def _reduce_405(val, _values, result); end

  def _reduce_406(val, _values, result); end

  def _reduce_407(val, _values, result); end

  def _reduce_408(val, _values, result); end

  def _reduce_409(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_410(val, _values, result); end

  def _reduce_411(val, _values, result); end

  def _reduce_412(val, _values, result); end

  def _reduce_413(val, _values, result); end

  def _reduce_414(val, _values, result); end

  def _reduce_415(val, _values, result); end

  def _reduce_416(val, _values, result); end

  def _reduce_417(val, _values, result); end

  def _reduce_418(val, _values, result); end

  def _reduce_419(val, _values, result); end

  def _reduce_420(val, _values, result); end

  def _reduce_421(val, _values, result); end

  def _reduce_422(val, _values, result); end

  def _reduce_423(val, _values, result); end

  def _reduce_424(val, _values, result); end

  def _reduce_425(val, _values, result); end

  def _reduce_427(val, _values, result); end

  def _reduce_428(val, _values, result); end

  def _reduce_429(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_432(val, _values, result); end

  def _reduce_434(val, _values, result); end

  def _reduce_439(val, _values, result); end

  def _reduce_440(val, _values, result); end

  def _reduce_441(val, _values, result); end

  def _reduce_442(val, _values, result); end

  def _reduce_443(val, _values, result); end

  def _reduce_444(val, _values, result); end

  def _reduce_445(val, _values, result); end

  def _reduce_446(val, _values, result); end

  def _reduce_447(val, _values, result); end

  def _reduce_448(val, _values, result); end

  def _reduce_449(val, _values, result); end

  def _reduce_450(val, _values, result); end

  def _reduce_451(val, _values, result); end

  def _reduce_452(val, _values, result); end

  def _reduce_453(val, _values, result); end

  def _reduce_454(val, _values, result); end

  def _reduce_455(val, _values, result); end

  def _reduce_456(val, _values, result); end

  def _reduce_457(val, _values, result); end

  def _reduce_458(val, _values, result); end

  def _reduce_459(val, _values, result); end

  def _reduce_46(val, _values, result); end

  def _reduce_460(val, _values, result); end

  def _reduce_461(val, _values, result); end

  def _reduce_462(val, _values, result); end

  def _reduce_463(val, _values, result); end

  def _reduce_464(val, _values, result); end

  def _reduce_465(val, _values, result); end

  def _reduce_466(val, _values, result); end

  def _reduce_467(val, _values, result); end

  def _reduce_468(val, _values, result); end

  def _reduce_469(val, _values, result); end

  def _reduce_47(val, _values, result); end

  def _reduce_470(val, _values, result); end

  def _reduce_471(val, _values, result); end

  def _reduce_472(val, _values, result); end

  def _reduce_473(val, _values, result); end

  def _reduce_475(val, _values, result); end

  def _reduce_476(val, _values, result); end

  def _reduce_477(val, _values, result); end

  def _reduce_478(val, _values, result); end

  def _reduce_479(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_480(val, _values, result); end

  def _reduce_481(val, _values, result); end

  def _reduce_482(val, _values, result); end

  def _reduce_483(val, _values, result); end

  def _reduce_484(val, _values, result); end

  def _reduce_485(val, _values, result); end

  def _reduce_486(val, _values, result); end

  def _reduce_487(val, _values, result); end

  def _reduce_488(val, _values, result); end

  def _reduce_489(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_490(val, _values, result); end

  def _reduce_491(val, _values, result); end

  def _reduce_492(val, _values, result); end

  def _reduce_493(val, _values, result); end

  def _reduce_494(val, _values, result); end

  def _reduce_495(val, _values, result); end

  def _reduce_496(val, _values, result); end

  def _reduce_497(val, _values, result); end

  def _reduce_498(val, _values, result); end

  def _reduce_499(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_500(val, _values, result); end

  def _reduce_501(val, _values, result); end

  def _reduce_502(val, _values, result); end

  def _reduce_503(val, _values, result); end

  def _reduce_504(val, _values, result); end

  def _reduce_505(val, _values, result); end

  def _reduce_506(val, _values, result); end

  def _reduce_507(val, _values, result); end

  def _reduce_508(val, _values, result); end

  def _reduce_509(val, _values, result); end

  def _reduce_510(val, _values, result); end

  def _reduce_511(val, _values, result); end

  def _reduce_512(val, _values, result); end

  def _reduce_513(val, _values, result); end

  def _reduce_514(val, _values, result); end

  def _reduce_515(val, _values, result); end

  def _reduce_516(val, _values, result); end

  def _reduce_517(val, _values, result); end

  def _reduce_518(val, _values, result); end

  def _reduce_519(val, _values, result); end

  def _reduce_520(val, _values, result); end

  def _reduce_521(val, _values, result); end

  def _reduce_522(val, _values, result); end

  def _reduce_523(val, _values, result); end

  def _reduce_524(val, _values, result); end

  def _reduce_525(val, _values, result); end

  def _reduce_526(val, _values, result); end

  def _reduce_527(val, _values, result); end

  def _reduce_528(val, _values, result); end

  def _reduce_529(val, _values, result); end

  def _reduce_530(val, _values, result); end

  def _reduce_531(val, _values, result); end

  def _reduce_533(val, _values, result); end

  def _reduce_534(val, _values, result); end

  def _reduce_535(val, _values, result); end

  def _reduce_536(val, _values, result); end

  def _reduce_537(val, _values, result); end

  def _reduce_538(val, _values, result); end

  def _reduce_539(val, _values, result); end

  def _reduce_540(val, _values, result); end

  def _reduce_541(val, _values, result); end

  def _reduce_542(val, _values, result); end

  def _reduce_543(val, _values, result); end

  def _reduce_544(val, _values, result); end

  def _reduce_545(val, _values, result); end

  def _reduce_546(val, _values, result); end

  def _reduce_547(val, _values, result); end

  def _reduce_55(val, _values, result); end

  def _reduce_550(val, _values, result); end

  def _reduce_551(val, _values, result); end

  def _reduce_552(val, _values, result); end

  def _reduce_553(val, _values, result); end

  def _reduce_554(val, _values, result); end

  def _reduce_555(val, _values, result); end

  def _reduce_556(val, _values, result); end

  def _reduce_557(val, _values, result); end

  def _reduce_56(val, _values, result); end

  def _reduce_560(val, _values, result); end

  def _reduce_561(val, _values, result); end

  def _reduce_564(val, _values, result); end

  def _reduce_565(val, _values, result); end

  def _reduce_566(val, _values, result); end

  def _reduce_568(val, _values, result); end

  def _reduce_569(val, _values, result); end

  def _reduce_57(val, _values, result); end

  def _reduce_571(val, _values, result); end

  def _reduce_572(val, _values, result); end

  def _reduce_573(val, _values, result); end

  def _reduce_574(val, _values, result); end

  def _reduce_575(val, _values, result); end

  def _reduce_576(val, _values, result); end

  def _reduce_589(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_590(val, _values, result); end

  def _reduce_595(val, _values, result); end

  def _reduce_596(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_600(val, _values, result); end

  def _reduce_604(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_75(val, _values, result); end

  def _reduce_76(val, _values, result); end

  def _reduce_77(val, _values, result); end

  def _reduce_78(val, _values, result); end

  def _reduce_79(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_80(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def default_encoding(); end

  def version(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Parser::Ruby24
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil), source: T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
  POSTFIX_TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::MethodDefinition
  def assignment(); end

  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l, assignment_l, body_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::MethodDefinition
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  include ::RuboCop::AST::Ext::Range
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def to_range(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def action_root(); end

  def as_nested_actions(); end

  def as_replacements(); end

  def diagnostics(); end

  def empty?(); end

  def import!(foreign_rewriter, offset: T.unsafe(nil)); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def merge(with); end

  def merge!(with); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def analyse_hierarchy(action); end

  def bsearch_child_index(from=T.unsafe(nil)); end

  def call_enforcer_for_merge(action); end

  def check_fusible(action, *fusible); end

  def children(); end

  def combine(action); end

  def combine_children(more_children); end

  def contract(); end

  def do_combine(action); end

  def empty?(); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def moved(source_buffer, offset); end

  def nested_actions(); end

  def ordered_replacements(); end

  def place_in_hierarchy(action); end

  def range(); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), enforcer: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::StaticEnvironment
  def declare(name); end

  def declare_forward_args(); end

  def declared?(name); end

  def declared_forward_args?(); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
  FORWARD_ARGS = ::T.let(nil, ::T.untyped)
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

class Parser::VariablesStack
  def declare(name); end

  def declared?(name); end

  def pop(); end

  def push(); end

  def reset(); end
end

class Parser::VariablesStack
end

module Parser
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::MethodSource::MethodExtensions
  def <<(_); end

  def >>(_); end

  def clone(); end
end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

class Pry
  def add_sticky_local(name, &block); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def binding_stack(); end

  def binding_stack=(binding_stack); end

  def color(*args, &block); end

  def color=(*args, &block); end

  def commands(*args, &block); end

  def commands=(*args, &block); end

  def complete(str); end

  def config(); end

  def current_binding(); end

  def current_context(); end

  def custom_completions(); end

  def custom_completions=(custom_completions); end

  def editor(*args, &block); end

  def editor=(*args, &block); end

  def eval(line, options=T.unsafe(nil)); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def evaluate_ruby(code); end

  def exception_handler(*args, &block); end

  def exception_handler=(*args, &block); end

  def exec_hook(name, *args, &block); end

  def exit_value(); end

  def extra_sticky_locals(*args, &block); end

  def extra_sticky_locals=(*args, &block); end

  def hooks(*args, &block); end

  def hooks=(*args, &block); end

  def initialize(options=T.unsafe(nil)); end

  def inject_local(name, value, binding); end

  def inject_sticky_locals!(); end

  def input(*args, &block); end

  def input=(*args, &block); end

  def input_ring(); end

  def last_dir(); end

  def last_dir=(last_dir); end

  def last_exception(); end

  def last_exception=(exception); end

  def last_file(); end

  def last_file=(last_file); end

  def last_result(); end

  def last_result=(last_result); end

  def last_result_is_exception?(); end

  def memory_size(); end

  def memory_size=(size); end

  def output(); end

  def output=(*args, &block); end

  def output_ring(); end

  def pager(); end

  def pager=(*args, &block); end

  def pop_prompt(); end

  def print(*args, &block); end

  def print=(*args, &block); end

  def process_command(val); end

  def process_command_safely(val); end

  def prompt(); end

  def prompt=(new_prompt); end

  def push_binding(object); end

  def push_initial_binding(target=T.unsafe(nil)); end

  def push_prompt(new_prompt); end

  def quiet?(); end

  def raise_up(*args); end

  def raise_up!(*args); end

  def raise_up_common(force, *args); end

  def repl(target=T.unsafe(nil)); end

  def reset_eval_string(); end

  def run_command(val); end

  def select_prompt(); end

  def set_last_result(result, code=T.unsafe(nil)); end

  def should_print?(); end

  def show_result(result); end

  def sticky_locals(); end

  def suppress_output(); end

  def suppress_output=(suppress_output); end

  def update_input_history(code); end
  BINDING_METHOD_IMPL = ::T.let(nil, ::T.untyped)
  Commands = ::T.let(nil, ::T.untyped)
  EMPTY_COMPLETIONS = ::T.let(nil, ::T.untyped)
  HAS_SAFE_LEVEL = ::T.let(nil, ::T.untyped)
  LOCAL_RC_FILE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::BasicObject
  include ::Kernel
  ENV = ::T.let(nil, ::T.untyped)
end

Pry::BasicObject::Dir = Dir

Pry::BasicObject::File = File

Pry::BasicObject::Kernel = Kernel

Pry::BasicObject::LoadError = LoadError

Pry::BasicObject::Pry = Pry

class Pry::BasicObject
end

class Pry::BlockCommand
  def call(*args); end

  def help(); end
end

class Pry::BlockCommand
end

module Pry::Byebug
end

module Pry::Byebug::Breakpoints
  def add_file(file, line, expression=T.unsafe(nil)); end

  def add_method(method, expression=T.unsafe(nil)); end

  def breakpoints(); end

  def change(id, expression=T.unsafe(nil)); end

  def delete(id); end

  def delete_all(); end

  def disable(id); end

  def disable_all(); end

  def each(&block); end

  def enable(id); end

  def find_by_id(id); end

  def last(); end

  def size(); end

  def to_a(); end
end

class Pry::Byebug::Breakpoints::FileBreakpoint
  def source_code(); end

  def to_s(); end
end

class Pry::Byebug::Breakpoints::FileBreakpoint
end

class Pry::Byebug::Breakpoints::MethodBreakpoint
  def initialize(byebug_bp, method); end

  def source_code(); end

  def to_s(); end
end

class Pry::Byebug::Breakpoints::MethodBreakpoint
end

module Pry::Byebug::Breakpoints
  extend ::Enumerable
  extend ::Pry::Byebug::Breakpoints
end

module Pry::Byebug
end

class Pry::CLI
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI::NoOptionsError
end

class Pry::CLI
  def self.add_option_processor(&block); end

  def self.add_options(&block); end

  def self.add_plugin_options(); end

  def self.input_args(); end

  def self.input_args=(input_args); end

  def self.option_processors(); end

  def self.option_processors=(option_processors); end

  def self.options(); end

  def self.options=(options); end

  def self.parse_options(args=T.unsafe(nil)); end

  def self.reset(); end

  def self.start(opts); end
end

class Pry::ClassCommand
  def args(); end

  def args=(args); end

  def call(*args); end

  def complete(search); end

  def help(); end

  def options(opt); end

  def opts(); end

  def opts=(opts); end

  def process(); end

  def setup(); end

  def slop(); end

  def subcommands(cmd); end
end

class Pry::ClassCommand
  def self.inherited(klass); end

  def self.source_location(); end
end

class Pry::Code
  def <<(line); end

  def ==(other); end

  def after(lineno, lines=T.unsafe(nil)); end

  def alter(&block); end

  def around(lineno, lines=T.unsafe(nil)); end

  def before(lineno, lines=T.unsafe(nil)); end

  def between(start_line, end_line=T.unsafe(nil)); end

  def code_type(); end

  def code_type=(code_type); end

  def comment_describing(line_number); end

  def expression_at(line_number, consume=T.unsafe(nil)); end

  def grep(pattern); end

  def highlighted(); end

  def initialize(lines=T.unsafe(nil), start_line=T.unsafe(nil), code_type=T.unsafe(nil)); end

  def length(); end

  def max_lineno_width(); end

  def method_missing(method_name, *args, &block); end

  def nesting_at(line_number); end

  def print_to_output(output, color=T.unsafe(nil)); end

  def push(line); end

  def raw(); end

  def reject(&block); end

  def select(&block); end

  def take_lines(start_line, num_lines); end

  def with_indentation(spaces=T.unsafe(nil)); end

  def with_line_numbers(y_n=T.unsafe(nil)); end

  def with_marker(lineno=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
  def indices_range(lines); end

  def initialize(start_line, end_line=T.unsafe(nil)); end
end

class Pry::Code::CodeRange
end

class Pry::Code::LOC
  def ==(other); end

  def add_line_number(max_width=T.unsafe(nil), color=T.unsafe(nil)); end

  def add_marker(marker_lineno); end

  def colorize(code_type); end

  def handle_multiline_entries_from_edit_command(line, max_width); end

  def indent(distance); end

  def initialize(line, lineno); end

  def line(); end

  def lineno(); end

  def tuple(); end
end

class Pry::Code::LOC
end

class Pry::Code
  extend ::MethodSource::CodeHelpers
  def self.from_file(filename, code_type=T.unsafe(nil)); end

  def self.from_method(meth, start_line=T.unsafe(nil)); end

  def self.from_module(mod, candidate_rank=T.unsafe(nil), start_line=T.unsafe(nil)); end
end

class Pry::CodeFile
  def code(); end

  def code_type(); end

  def initialize(filename, code_type=T.unsafe(nil)); end
  DEFAULT_EXT = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  FILES = ::T.let(nil, ::T.untyped)
  INITIAL_PWD = ::T.let(nil, ::T.untyped)
end

class Pry::CodeFile
end

class Pry::CodeObject
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def command_lookup(); end

  def default_lookup(); end

  def empty_lookup(); end

  def initialize(str, pry_instance, options=T.unsafe(nil)); end

  def method_or_class_lookup(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def str(); end

  def str=(str); end

  def super_level(); end

  def super_level=(super_level); end

  def target(); end

  def target=(target); end
end

module Pry::CodeObject::Helpers
  def c_method?(); end

  def c_module?(); end

  def command?(); end

  def module_with_yard_docs?(); end

  def real_method_object?(); end
end

module Pry::CodeObject::Helpers
end

class Pry::CodeObject
  def self.lookup(str, pry_instance, options=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def pp(object); end

  def text(str, max_width=T.unsafe(nil)); end
end

class Pry::ColorPrinter
  def self.default(_output, value, pry_instance); end

  def self.pp(obj, output=T.unsafe(nil), max_width=T.unsafe(nil)); end
end

class Pry::Command
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::Text
  def _pry_(); end

  def _pry_=(_pry_); end

  def arg_string(); end

  def arg_string=(arg_string); end

  def block(); end

  def captures(); end

  def captures=(captures); end

  def check_for_command_collision(command_match, arg_string); end

  def command_block(); end

  def command_block=(command_block); end

  def command_name(); end

  def command_options(); end

  def command_set(); end

  def command_set=(command_set); end

  def commands(); end

  def complete(_search); end

  def context(); end

  def context=(context); end

  def description(); end

  def eval_string(); end

  def eval_string=(eval_string); end

  def hooks(); end

  def hooks=(hooks); end

  def initialize(context=T.unsafe(nil)); end

  def interpolate_string(str); end

  def match(); end

  def name(); end

  def output(); end

  def output=(output); end

  def process_line(line); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def run(command_string, *args); end

  def source(); end

  def state(); end

  def target(); end

  def target=(target); end

  def target_self(); end

  def tokenize(val); end

  def void(); end
  VOID_VALUE = ::T.let(nil, ::T.untyped)
end

class Pry::Command::AmendLine
end

class Pry::Command::AmendLine
end

class Pry::Command::Bang
end

class Pry::Command::Bang
end

class Pry::Command::BangPry
end

class Pry::Command::BangPry
end

class Pry::Command::Cat
  def load_path_completions(); end
end

class Pry::Command::Cat::AbstractFormatter
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  include ::Pry::Helpers::BaseHelpers
end

class Pry::Command::Cat::AbstractFormatter
end

class Pry::Command::Cat::ExceptionFormatter
  include ::Pry::Helpers::Text
  def ex(); end

  def format(); end

  def initialize(exception, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::ExceptionFormatter
end

class Pry::Command::Cat::FileFormatter
  def file_and_line(); end

  def file_with_embedded_line(); end

  def format(); end

  def initialize(file_with_embedded_line, pry_instance, opts); end

  def opts(); end

  def pry_instance(); end
end

class Pry::Command::Cat::FileFormatter
end

class Pry::Command::Cat::InputExpressionFormatter
  def format(); end

  def initialize(input_expressions, opts); end

  def input_expressions(); end

  def input_expressions=(input_expressions); end

  def opts(); end

  def opts=(opts); end
end

class Pry::Command::Cat::InputExpressionFormatter
end

class Pry::Command::Cat
end

class Pry::Command::Cd
end

class Pry::Command::Cd
end

class Pry::Command::ChangeInspector
  def process(inspector); end
end

class Pry::Command::ChangeInspector
end

class Pry::Command::ChangePrompt
  def process(prompt); end
end

class Pry::Command::ChangePrompt
end

class Pry::Command::ClearScreen
end

class Pry::Command::ClearScreen
end

class Pry::Command::CodeCollector
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def args(); end

  def code_object(); end

  def content(); end

  def file(); end

  def file=(file); end

  def initialize(args, opts, pry_instance); end

  def line_range(); end

  def obj_name(); end

  def opts(); end

  def pry_input_content(); end

  def pry_instance(); end

  def pry_output_content(); end

  def restrict_to_lines(content, range); end
end

class Pry::Command::CodeCollector
  def self.inject_options(opt); end

  def self.input_expression_ranges(); end

  def self.input_expression_ranges=(input_expression_ranges); end

  def self.output_result_ranges(); end

  def self.output_result_ranges=(output_result_ranges); end
end

class Pry::Command::DisablePry
end

class Pry::Command::DisablePry
end

class Pry::Command::Edit
  def apply_runtime_patch(); end

  def bad_option_combination?(); end

  def code_object(); end

  def ensure_file_name_is_valid(file_name); end

  def file_and_line(); end

  def file_and_line_for_current_exception(); end

  def file_based_exception?(); end

  def file_edit(); end

  def filename_argument(); end

  def initial_temp_file_content(); end

  def input_expression(); end

  def never_reload?(); end

  def patch_exception?(); end

  def previously_patched?(code_object); end

  def probably_a_file?(str); end

  def pry_method?(code_object); end

  def reload?(file_name=T.unsafe(nil)); end

  def reloadable?(); end

  def repl_edit(); end

  def repl_edit?(); end

  def runtime_patch?(); end
end

class Pry::Command::Edit::ExceptionPatcher
  def file_and_line(); end

  def file_and_line=(file_and_line); end

  def initialize(pry_instance, state, exception_file_and_line); end

  def perform_patch(); end

  def pry_instance(); end

  def pry_instance=(pry_instance); end

  def state(); end

  def state=(state); end
end

class Pry::Command::Edit::ExceptionPatcher
end

module Pry::Command::Edit::FileAndLineLocator
end

module Pry::Command::Edit::FileAndLineLocator
  def self.from_binding(target); end

  def self.from_code_object(code_object, filename_argument); end

  def self.from_exception(exception, backtrace_level); end

  def self.from_filename_argument(filename_argument); end
end

class Pry::Command::Edit
end

class Pry::Command::Exit
  def process_pop_and_return(); end
end

class Pry::Command::Exit
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitAll
end

class Pry::Command::ExitProgram
end

class Pry::Command::ExitProgram
end

class Pry::Command::FindMethod
end

class Pry::Command::FindMethod
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::FixIndent
end

class Pry::Command::FixIndent
end

class Pry::Command::Help
  def command_groups(); end

  def display_command(command); end

  def display_filtered_commands(search); end

  def display_filtered_search_results(search); end

  def display_index(groups); end

  def display_search(search); end

  def group_sort_key(group_name); end

  def help_text_for_commands(name, commands); end

  def normalize(key); end

  def search_hash(search, hash); end

  def sorted_commands(commands); end

  def sorted_group_names(groups); end

  def visible_commands(); end
end

class Pry::Command::Help
end

class Pry::Command::Hist
end

class Pry::Command::Hist
end

class Pry::Command::ImportSet
  def process(_command_set_name); end
end

class Pry::Command::ImportSet
end

class Pry::Command::JumpTo
  def process(break_level); end
end

class Pry::Command::JumpTo
end

class Pry::Command::ListInspectors
end

class Pry::Command::ListInspectors
end

class Pry::Command::Ls
  def no_user_opts?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Constants
end

class Pry::Command::Ls::Formatter
  def grep=(grep); end

  def initialize(pry_instance); end

  def pry_instance(); end

  def write_out(); end
end

class Pry::Command::Ls::Formatter
end

class Pry::Command::Ls::Globals
  def initialize(opts, pry_instance); end
  BUILTIN_GLOBALS = ::T.let(nil, ::T.untyped)
  PSEUDO_GLOBALS = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Ls::Globals
end

class Pry::Command::Ls::Grep
  def initialize(grep_regexp); end

  def regexp(); end
end

class Pry::Command::Ls::Grep
end

class Pry::Command::Ls::InstanceVars
  include ::Pry::Command::Ls::Interrogatable
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::InstanceVars
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::Interrogatable
end

module Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::JRubyHacks
end

class Pry::Command::Ls::LocalNames
  def initialize(no_user_opts, args, pry_instance); end
end

class Pry::Command::Ls::LocalNames
end

class Pry::Command::Ls::LocalVars
  def initialize(opts, pry_instance); end
end

class Pry::Command::Ls::LocalVars
end

class Pry::Command::Ls::LsEntity
  def entities_table(); end

  def initialize(opts); end

  def pry_instance(); end
end

class Pry::Command::Ls::LsEntity
end

class Pry::Command::Ls::Methods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::Methods
end

module Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
end

module Pry::Command::Ls::MethodsHelper
end

class Pry::Command::Ls::SelfMethods
  include ::Pry::Command::Ls::Interrogatable
  include ::Pry::Command::Ls::MethodsHelper
  include ::Pry::Command::Ls::JRubyHacks
  def initialize(interrogatee, no_user_opts, opts, pry_instance); end
end

class Pry::Command::Ls::SelfMethods
end

class Pry::Command::Ls
end

class Pry::Command::Nesting
end

class Pry::Command::Nesting
end

class Pry::Command::Play
  def code_object(); end

  def content(); end

  def content_after_options(); end

  def content_at_expression(); end

  def default_file(); end

  def file_content(); end

  def perform_play(); end

  def should_use_default_file?(); end

  def show_input(); end
end

class Pry::Command::Play
end

class Pry::Command::PryBacktrace
end

class Pry::Command::PryBacktrace
end

class Pry::Command::RaiseUp
end

class Pry::Command::RaiseUp
end

class Pry::Command::ReloadCode
end

class Pry::Command::ReloadCode
end

class Pry::Command::Reset
end

class Pry::Command::Reset
end

class Pry::Command::Ri
  def process(spec); end
end

class Pry::Command::Ri
end

class Pry::Command::SaveFile
  def display_content(); end

  def file_name(); end

  def mode(); end

  def save_file(); end
end

class Pry::Command::SaveFile
end

class Pry::Command::ShellCommand
  def process(cmd); end
end

class Pry::Command::ShellCommand
end

class Pry::Command::ShellMode
end

class Pry::Command::ShellMode
end

class Pry::Command::ShowDoc
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowDoc
end

class Pry::Command::ShowInfo
  def code_object_header(code_object, line_num); end

  def code_object_with_accessible_source(code_object); end

  def complete(input); end

  def content_and_header_for_code_object(code_object); end

  def content_and_headers_for_all_module_candidates(mod); end

  def file_and_line_for(code_object); end

  def header(code_object); end

  def header_options(); end

  def initialize(*_); end

  def method_header(code_object, line_num); end

  def method_sections(code_object); end

  def module_header(code_object, line_num); end

  def no_definition_message(); end

  def obj_name(); end

  def show_all_modules?(code_object); end

  def start_line_for(code_object); end

  def use_line_numbers?(); end

  def valid_superclass?(code_object); end
end

class Pry::Command::ShowInfo
  extend ::Pry::Helpers::BaseHelpers
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowInput
end

class Pry::Command::ShowSource
  include ::Pry::Helpers::DocumentationHelpers
  def content_for(code_object); end

  def docs_for(code_object); end

  def render_doc_markup_for(code_object); end
end

class Pry::Command::ShowSource
end

class Pry::Command::Stat
end

class Pry::Command::Stat
end

class Pry::Command::SwitchTo
  def process(selection); end
end

class Pry::Command::SwitchTo
end

class Pry::Command::ToggleColor
  def color_toggle(); end
end

class Pry::Command::ToggleColor
end

class Pry::Command::Version
end

class Pry::Command::Version
end

class Pry::Command::WatchExpression
end

class Pry::Command::WatchExpression::Expression
  def changed?(); end

  def eval!(); end

  def initialize(pry_instance, target, source); end

  def previous_value(); end

  def pry_instance(); end

  def source(); end

  def target(); end

  def value(); end
end

class Pry::Command::WatchExpression::Expression
end

class Pry::Command::WatchExpression
end

class Pry::Command::Whereami
  def bad_option_combination?(); end

  def code(); end

  def code?(); end

  def initialize(*_); end

  def location(); end
end

class Pry::Command::Whereami
  def self.method_size_cutoff(); end

  def self.method_size_cutoff=(method_size_cutoff); end
end

class Pry::Command::Wtf
  RUBY_FRAME_PATTERN = ::T.let(nil, ::T.untyped)
end

class Pry::Command::Wtf
end

class Pry::Command
  extend ::Pry::Helpers::DocumentationHelpers
  extend ::Pry::CodeObject::Helpers
  def self.banner(arg=T.unsafe(nil)); end

  def self.block(); end

  def self.block=(block); end

  def self.command_name(); end

  def self.command_options(arg=T.unsafe(nil)); end

  def self.command_options=(command_options); end

  def self.command_regex(); end

  def self.convert_to_regex(obj); end

  def self.default_options(match); end

  def self.description(arg=T.unsafe(nil)); end

  def self.description=(description); end

  def self.doc(); end

  def self.file(); end

  def self.group(name=T.unsafe(nil)); end

  def self.line(); end

  def self.match(arg=T.unsafe(nil)); end

  def self.match=(match); end

  def self.match_score(val); end

  def self.matches?(val); end

  def self.options(arg=T.unsafe(nil)); end

  def self.options=(options); end

  def self.source(); end

  def self.source_file(); end

  def self.source_line(); end

  def self.state(); end

  def self.subclass(match, description, options, helpers, &block); end
end

class Pry::CommandError
end

class Pry::CommandError
end

class Pry::CommandSet
  include ::Enumerable
  include ::Pry::Helpers::BaseHelpers
  def [](pattern); end

  def []=(pattern, command); end

  def add_command(command); end

  def alias_command(match, action, options=T.unsafe(nil)); end

  def block_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def complete(search, context=T.unsafe(nil)); end

  def create_command(match, description=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def delete(*searches); end

  def desc(search, description=T.unsafe(nil)); end

  def each(&block); end

  def find_command(pattern); end

  def find_command_by_match_or_listing(match_or_listing); end

  def find_command_for_help(search); end

  def helper_module(); end

  def import(*sets); end

  def import_from(set, *matches); end

  def initialize(*imported_sets, &block); end

  def keys(); end

  def list_commands(); end

  def process_line(val, context=T.unsafe(nil)); end

  def rename_command(new_match, search, options=T.unsafe(nil)); end

  def to_h(); end

  def to_hash(); end

  def valid_command?(val); end
end

class Pry::CommandSet
end

class Pry::CommandState
  def reset(command_name); end

  def state_for(command_name); end
end

class Pry::CommandState
  def self.default(); end
end

class Pry::Config
  def [](attr); end

  def []=(attr, value); end

  def auto_indent(); end

  def auto_indent=(auto_indent); end

  def collision_warning(); end

  def collision_warning=(collision_warning); end

  def color(); end

  def color=(color); end

  def command_completions(); end

  def command_completions=(command_completions); end

  def command_prefix(); end

  def command_prefix=(command_prefix); end

  def commands(); end

  def commands=(commands); end

  def completer(); end

  def completer=(completer); end

  def control_d_handler(); end

  def control_d_handler=(value); end

  def correct_indent(); end

  def correct_indent=(correct_indent); end

  def default_window_size(); end

  def default_window_size=(default_window_size); end

  def disable_auto_reload(); end

  def disable_auto_reload=(disable_auto_reload); end

  def editor(); end

  def editor=(editor); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def exception_whitelist(); end

  def exception_whitelist=(exception_whitelist); end

  def exec_string(); end

  def exec_string=(exec_string); end

  def extra_sticky_locals(); end

  def extra_sticky_locals=(extra_sticky_locals); end

  def file_completions(); end

  def file_completions=(file_completions); end

  def history(); end

  def history=(history); end

  def history_file(); end

  def history_file=(history_file); end

  def history_ignorelist(); end

  def history_ignorelist=(history_ignorelist); end

  def history_load(); end

  def history_load=(history_load); end

  def history_save(); end

  def history_save=(history_save); end

  def hooks(); end

  def hooks=(hooks); end

  def input(); end

  def input=(input); end

  def ls(); end

  def ls=(ls); end

  def memory_size(); end

  def memory_size=(memory_size); end

  def merge(config_hash); end

  def merge!(config_hash); end

  def method_missing(method_name, *args, &_block); end

  def output(); end

  def output=(output); end

  def output_prefix(); end

  def output_prefix=(output_prefix); end

  def pager(); end

  def pager=(pager); end

  def print(); end

  def print=(print); end

  def prompt(); end

  def prompt=(prompt); end

  def prompt_name(); end

  def prompt_name=(prompt_name); end

  def prompt_safe_contexts(); end

  def prompt_safe_contexts=(prompt_safe_contexts); end

  def quiet(); end

  def quiet=(quiet); end

  def rc_file(); end

  def rc_file=(rc_file); end

  def requires(); end

  def requires=(requires); end

  def should_load_local_rc(); end

  def should_load_local_rc=(should_load_local_rc); end

  def should_load_plugins(); end

  def should_load_plugins=(should_load_plugins); end

  def should_load_rc(); end

  def should_load_rc=(should_load_rc); end

  def should_load_requires(); end

  def should_load_requires=(should_load_requires); end

  def should_trap_interrupts(); end

  def should_trap_interrupts=(should_trap_interrupts); end

  def system(); end

  def system=(system); end

  def unrescued_exceptions(); end

  def unrescued_exceptions=(unrescued_exceptions); end

  def windows_console_warning(); end

  def windows_console_warning=(windows_console_warning); end
end

module Pry::Config::Attributable
  def attribute(attr_name); end
end

module Pry::Config::Attributable
end

class Pry::Config::LazyValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::LazyValue
end

class Pry::Config::MemoizedValue
  def call(); end

  def initialize(&block); end
end

class Pry::Config::MemoizedValue
end

class Pry::Config::Value
  def call(); end

  def initialize(value); end
end

class Pry::Config::Value
end

class Pry::Config
  extend ::Pry::Config::Attributable
end

module Pry::ControlDHandler
end

module Pry::ControlDHandler
  def self.default(pry_instance); end
end

class Pry::Editor
  include ::Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def build_editor_invocation_string(file, line, blocking); end

  def edit_tempfile_with_content(initial_content, line=T.unsafe(nil)); end

  def initialize(pry_instance); end

  def invoke_editor(file, line, blocking=T.unsafe(nil)); end

  def pry_instance(); end
end

class Pry::Editor
  def self.default(); end
end

module Pry::Env
end

module Pry::Env
  def self.[](key); end
end

module Pry::ExceptionHandler
end

module Pry::ExceptionHandler
  def self.handle_exception(output, exception, _pry_instance); end
end

module Pry::Forwardable
  include ::Forwardable
  def def_private_delegators(target, *private_delegates); end
end

module Pry::Forwardable
end

module Pry::FrozenObjectException
end

module Pry::FrozenObjectException
  def self.===(exception); end
end

module Pry::Helpers
end

module Pry::Helpers::BaseHelpers
  def colorize_code(code); end

  def find_command(name, set=T.unsafe(nil)); end

  def heading(text); end

  def highlight(string, regexp, highlight_color=T.unsafe(nil)); end

  def not_a_real_file?(file); end

  def safe_send(obj, method, *args, &block); end

  def silence_warnings(); end

  def stagger_output(text, _out=T.unsafe(nil)); end

  def use_ansi_codes?(); end
end

module Pry::Helpers::BaseHelpers
  extend ::Pry::Helpers::BaseHelpers
end

module Pry::Helpers::CommandHelpers
  include ::Pry::Helpers::OptionsHelpers
  def absolute_index_number(line_number, array_length); end

  def absolute_index_range(range_or_number, array_length); end

  def get_method_or_raise(method_name, context, opts=T.unsafe(nil)); end

  def internal_binding?(context); end

  def one_index_number(line_number); end

  def one_index_range(range); end

  def one_index_range_or_number(range_or_number); end

  def restrict_to_lines(content, lines); end

  def set_file_and_dir_locals(file_name, pry=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def temp_file(ext=T.unsafe(nil)); end

  def unindent(dirty_text, left_padding=T.unsafe(nil)); end
end

module Pry::Helpers::CommandHelpers
  extend ::Pry::Helpers::CommandHelpers
  extend ::Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::DocumentationHelpers
  YARD_TAGS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::DocumentationHelpers
  def self.get_comment_content(comment); end

  def self.process_comment_markup(comment); end

  def self.process_rdoc(comment); end

  def self.process_yardoc(comment); end

  def self.process_yardoc_tag(comment, tag); end

  def self.strip_comments_from_c_code(code); end

  def self.strip_leading_whitespace(text); end
end

module Pry::Helpers::OptionsHelpers
end

module Pry::Helpers::OptionsHelpers
  def self.method_object(); end

  def self.method_options(opt); end
end

module Pry::Helpers::Platform
end

module Pry::Helpers::Platform
  def self.jruby?(); end

  def self.jruby_19?(); end

  def self.linux?(); end

  def self.mac_osx?(); end

  def self.mri?(); end

  def self.mri_19?(); end

  def self.mri_2?(); end

  def self.windows?(); end

  def self.windows_ansi?(); end
end

class Pry::Helpers::Table
  def ==(other); end

  def column_count(); end

  def column_count=(count); end

  def columns(); end

  def fits_on_line?(line_length); end

  def initialize(items, args, pry_instance=T.unsafe(nil)); end

  def items(); end

  def items=(items); end

  def rows_to_s(style=T.unsafe(nil)); end

  def to_a(); end
end

class Pry::Helpers::Table
end

module Pry::Helpers::Text
  def black(text); end

  def black_on_black(text); end

  def black_on_blue(text); end

  def black_on_cyan(text); end

  def black_on_green(text); end

  def black_on_magenta(text); end

  def black_on_purple(text); end

  def black_on_red(text); end

  def black_on_white(text); end

  def black_on_yellow(text); end

  def blue(text); end

  def blue_on_black(text); end

  def blue_on_blue(text); end

  def blue_on_cyan(text); end

  def blue_on_green(text); end

  def blue_on_magenta(text); end

  def blue_on_purple(text); end

  def blue_on_red(text); end

  def blue_on_white(text); end

  def blue_on_yellow(text); end

  def bold(text); end

  def bright_black(text); end

  def bright_black_on_black(text); end

  def bright_black_on_blue(text); end

  def bright_black_on_cyan(text); end

  def bright_black_on_green(text); end

  def bright_black_on_magenta(text); end

  def bright_black_on_purple(text); end

  def bright_black_on_red(text); end

  def bright_black_on_white(text); end

  def bright_black_on_yellow(text); end

  def bright_blue(text); end

  def bright_blue_on_black(text); end

  def bright_blue_on_blue(text); end

  def bright_blue_on_cyan(text); end

  def bright_blue_on_green(text); end

  def bright_blue_on_magenta(text); end

  def bright_blue_on_purple(text); end

  def bright_blue_on_red(text); end

  def bright_blue_on_white(text); end

  def bright_blue_on_yellow(text); end

  def bright_cyan(text); end

  def bright_cyan_on_black(text); end

  def bright_cyan_on_blue(text); end

  def bright_cyan_on_cyan(text); end

  def bright_cyan_on_green(text); end

  def bright_cyan_on_magenta(text); end

  def bright_cyan_on_purple(text); end

  def bright_cyan_on_red(text); end

  def bright_cyan_on_white(text); end

  def bright_cyan_on_yellow(text); end

  def bright_green(text); end

  def bright_green_on_black(text); end

  def bright_green_on_blue(text); end

  def bright_green_on_cyan(text); end

  def bright_green_on_green(text); end

  def bright_green_on_magenta(text); end

  def bright_green_on_purple(text); end

  def bright_green_on_red(text); end

  def bright_green_on_white(text); end

  def bright_green_on_yellow(text); end

  def bright_magenta(text); end

  def bright_magenta_on_black(text); end

  def bright_magenta_on_blue(text); end

  def bright_magenta_on_cyan(text); end

  def bright_magenta_on_green(text); end

  def bright_magenta_on_magenta(text); end

  def bright_magenta_on_purple(text); end

  def bright_magenta_on_red(text); end

  def bright_magenta_on_white(text); end

  def bright_magenta_on_yellow(text); end

  def bright_purple(text); end

  def bright_purple_on_black(text); end

  def bright_purple_on_blue(text); end

  def bright_purple_on_cyan(text); end

  def bright_purple_on_green(text); end

  def bright_purple_on_magenta(text); end

  def bright_purple_on_purple(text); end

  def bright_purple_on_red(text); end

  def bright_purple_on_white(text); end

  def bright_purple_on_yellow(text); end

  def bright_red(text); end

  def bright_red_on_black(text); end

  def bright_red_on_blue(text); end

  def bright_red_on_cyan(text); end

  def bright_red_on_green(text); end

  def bright_red_on_magenta(text); end

  def bright_red_on_purple(text); end

  def bright_red_on_red(text); end

  def bright_red_on_white(text); end

  def bright_red_on_yellow(text); end

  def bright_white(text); end

  def bright_white_on_black(text); end

  def bright_white_on_blue(text); end

  def bright_white_on_cyan(text); end

  def bright_white_on_green(text); end

  def bright_white_on_magenta(text); end

  def bright_white_on_purple(text); end

  def bright_white_on_red(text); end

  def bright_white_on_white(text); end

  def bright_white_on_yellow(text); end

  def bright_yellow(text); end

  def bright_yellow_on_black(text); end

  def bright_yellow_on_blue(text); end

  def bright_yellow_on_cyan(text); end

  def bright_yellow_on_green(text); end

  def bright_yellow_on_magenta(text); end

  def bright_yellow_on_purple(text); end

  def bright_yellow_on_red(text); end

  def bright_yellow_on_white(text); end

  def bright_yellow_on_yellow(text); end

  def cyan(text); end

  def cyan_on_black(text); end

  def cyan_on_blue(text); end

  def cyan_on_cyan(text); end

  def cyan_on_green(text); end

  def cyan_on_magenta(text); end

  def cyan_on_purple(text); end

  def cyan_on_red(text); end

  def cyan_on_white(text); end

  def cyan_on_yellow(text); end

  def default(text); end

  def green(text); end

  def green_on_black(text); end

  def green_on_blue(text); end

  def green_on_cyan(text); end

  def green_on_green(text); end

  def green_on_magenta(text); end

  def green_on_purple(text); end

  def green_on_red(text); end

  def green_on_white(text); end

  def green_on_yellow(text); end

  def indent(text, chars); end

  def magenta(text); end

  def magenta_on_black(text); end

  def magenta_on_blue(text); end

  def magenta_on_cyan(text); end

  def magenta_on_green(text); end

  def magenta_on_magenta(text); end

  def magenta_on_purple(text); end

  def magenta_on_red(text); end

  def magenta_on_white(text); end

  def magenta_on_yellow(text); end

  def no_color(); end

  def no_pager(); end

  def purple(text); end

  def purple_on_black(text); end

  def purple_on_blue(text); end

  def purple_on_cyan(text); end

  def purple_on_green(text); end

  def purple_on_magenta(text); end

  def purple_on_purple(text); end

  def purple_on_red(text); end

  def purple_on_white(text); end

  def purple_on_yellow(text); end

  def red(text); end

  def red_on_black(text); end

  def red_on_blue(text); end

  def red_on_cyan(text); end

  def red_on_green(text); end

  def red_on_magenta(text); end

  def red_on_purple(text); end

  def red_on_red(text); end

  def red_on_white(text); end

  def red_on_yellow(text); end

  def strip_color(text); end

  def white(text); end

  def white_on_black(text); end

  def white_on_blue(text); end

  def white_on_cyan(text); end

  def white_on_green(text); end

  def white_on_magenta(text); end

  def white_on_purple(text); end

  def white_on_red(text); end

  def white_on_white(text); end

  def white_on_yellow(text); end

  def with_line_numbers(text, offset, color=T.unsafe(nil)); end

  def yellow(text); end

  def yellow_on_black(text); end

  def yellow_on_blue(text); end

  def yellow_on_cyan(text); end

  def yellow_on_green(text); end

  def yellow_on_magenta(text); end

  def yellow_on_purple(text); end

  def yellow_on_red(text); end

  def yellow_on_white(text); end

  def yellow_on_yellow(text); end
  COLORS = ::T.let(nil, ::T.untyped)
end

module Pry::Helpers::Text
  extend ::Pry::Helpers::Text
end

module Pry::Helpers
  def self.tablify(things, line_length, pry_instance=T.unsafe(nil)); end

  def self.tablify_or_one_line(heading, things, pry_instance=T.unsafe(nil)); end

  def self.tablify_to_screen_width(things, options, pry_instance=T.unsafe(nil)); end
end

class Pry::History
  def <<(line); end

  def clear(); end

  def filter(history); end

  def history_line_count(); end

  def initialize(options=T.unsafe(nil)); end

  def load(); end

  def loader(); end

  def loader=(loader); end

  def original_lines(); end

  def push(line); end

  def saver(); end

  def saver=(saver); end

  def session_line_count(); end

  def to_a(); end
end

class Pry::History
  def self.default_file(); end
end

class Pry::Hooks
  def add_hook(event_name, hook_name, callable=T.unsafe(nil), &block); end

  def clear_event_hooks(event_name); end

  def delete_hook(event_name, hook_name); end

  def errors(); end

  def exec_hook(event_name, *args, &block); end

  def get_hook(event_name, hook_name); end

  def get_hooks(event_name); end

  def hook_count(event_name); end

  def hook_exists?(event_name, hook_name); end

  def hooks(); end

  def merge(other); end

  def merge!(other); end
end

class Pry::Hooks
  def self.default(); end
end

class Pry::Indent
  include ::Pry::Helpers::BaseHelpers
  def correct_indentation(prompt, code, overhang=T.unsafe(nil)); end

  def current_prefix(); end

  def end_of_statement?(last_token, last_kind); end

  def in_string?(); end

  def indent(input); end

  def indent_level(); end

  def indentation_delta(tokens); end

  def initialize(pry_instance=T.unsafe(nil)); end

  def module_nesting(); end

  def open_delimiters(); end

  def open_delimiters_line(); end

  def reset(); end

  def stack(); end

  def tokenize(string); end

  def track_delimiter(token); end

  def track_module_nesting(token, kind); end

  def track_module_nesting_end(token, kind=T.unsafe(nil)); end
  IGNORE_TOKENS = ::T.let(nil, ::T.untyped)
  MIDWAY_TOKENS = ::T.let(nil, ::T.untyped)
  OPEN_TOKENS = ::T.let(nil, ::T.untyped)
  OPTIONAL_DO_TOKENS = ::T.let(nil, ::T.untyped)
  SINGLELINE_TOKENS = ::T.let(nil, ::T.untyped)
  SPACES = ::T.let(nil, ::T.untyped)
  STATEMENT_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent::UnparseableNestingError
end

class Pry::Indent
  def self.indent(str); end

  def self.nesting_at(str, line_number); end
end

class Pry::InputCompleter
  def build_path(input); end

  def call(str, options=T.unsafe(nil)); end

  def ignored_modules(); end

  def initialize(input, pry=T.unsafe(nil)); end

  def select_message(path, receiver, message, candidates); end
  ARRAY_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_OR_METHOD_REGEXP = ::T.let(nil, ::T.untyped)
  CONSTANT_REGEXP = ::T.let(nil, ::T.untyped)
  GLOBALVARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  HEX_REGEXP = ::T.let(nil, ::T.untyped)
  NUMERIC_REGEXP = ::T.let(nil, ::T.untyped)
  PROC_OR_HASH_REGEXP = ::T.let(nil, ::T.untyped)
  REGEX_REGEXP = ::T.let(nil, ::T.untyped)
  RESERVED_WORDS = ::T.let(nil, ::T.untyped)
  SYMBOL_METHOD_CALL_REGEXP = ::T.let(nil, ::T.untyped)
  SYMBOL_REGEXP = ::T.let(nil, ::T.untyped)
  TOPLEVEL_LOOKUP_REGEXP = ::T.let(nil, ::T.untyped)
  VARIABLE_REGEXP = ::T.let(nil, ::T.untyped)
  WORD_ESCAPE_STR = ::T.let(nil, ::T.untyped)
end

class Pry::InputCompleter
end

class Pry::InputLock
  def __with_ownership(); end

  def enter_interruptible_region(); end

  def interruptible_region(); end

  def leave_interruptible_region(); end

  def with_ownership(&block); end
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock::Interrupt
end

class Pry::InputLock
  def self.for(input); end

  def self.global_lock(); end

  def self.global_lock=(global_lock); end

  def self.input_locks(); end

  def self.input_locks=(input_locks); end
end

class Pry::Inspector
  MAP = ::T.let(nil, ::T.untyped)
end

class Pry::Inspector
end

class Pry::LastException
  def bt_index(); end

  def bt_index=(bt_index); end

  def bt_source_location_for(index); end

  def file(); end

  def inc_bt_index(); end

  def initialize(exception); end

  def line(); end

  def method_missing(name, *args, &block); end

  def wrapped_exception(); end
end

class Pry::LastException
end

class Pry::Method
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def ==(other); end

  def alias?(); end

  def aliases(); end

  def bound_method?(); end

  def comment(); end

  def doc(); end

  def dynamically_defined?(); end

  def initialize(method, known_info=T.unsafe(nil)); end

  def is_a?(klass); end

  def kind_of?(klass); end

  def method_missing(method_name, *args, &block); end

  def name(); end

  def name_with_owner(); end

  def original_name(); end

  def owner(*args, &block); end

  def parameters(*args, &block); end

  def pry_method?(); end

  def receiver(*args, &block); end

  def redefine(source); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end

  def signature(); end

  def singleton_method?(); end

  def source(); end

  def source?(); end

  def source_file(); end

  def source_line(); end

  def source_range(); end

  def source_type(); end

  def super(times=T.unsafe(nil)); end

  def unbound_method?(); end

  def undefined?(); end

  def visibility(); end

  def wrapped(); end

  def wrapped_owner(); end
end

class Pry::Method::Disowned
  def initialize(receiver, method_name); end

  def owner(); end

  def receiver(); end
end

class Pry::Method::Disowned
end

class Pry::Method::Patcher
  def initialize(method); end

  def method(); end

  def method=(method); end

  def patch_in_ram(source); end
end

class Pry::Method::Patcher
  def self.code_for(filename); end
end

class Pry::Method::WeirdMethodLocator
  def find_method(); end

  def initialize(method, target); end

  def lost_method?(); end

  def method(); end

  def method=(method); end

  def target(); end

  def target=(target); end
end

class Pry::Method::WeirdMethodLocator
  def self.normal_method?(method, binding); end

  def self.weird_method?(method, binding); end
end

class Pry::Method
  extend ::Pry::Helpers::BaseHelpers
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.all_from_class(klass, include_super=T.unsafe(nil)); end

  def self.all_from_obj(obj, include_super=T.unsafe(nil)); end

  def self.from_binding(binding); end

  def self.from_class(klass, name, target=T.unsafe(nil)); end

  def self.from_module(klass, name, target=T.unsafe(nil)); end

  def self.from_obj(obj, name, target=T.unsafe(nil)); end

  def self.from_str(name, target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.instance_method_definition?(name, definition_line); end

  def self.instance_resolution_order(klass); end

  def self.lookup_method_via_binding(obj, method_name, method_type, target=T.unsafe(nil)); end

  def self.method_definition?(name, definition_line); end

  def self.resolution_order(obj); end

  def self.singleton_class_of(obj); end

  def self.singleton_class_resolution_order(klass); end

  def self.singleton_method_definition?(name, definition_line); end
end

class Pry::MethodNotFound
end

class Pry::MethodNotFound
end

class Pry::NoCommandError
  def initialize(match, owner); end
end

class Pry::NoCommandError
end

class Pry::ObjectPath
  def initialize(path_string, current_stack); end

  def resolve(); end
  SPECIAL_TERMS = ::T.let(nil, ::T.untyped)
end

class Pry::ObjectPath
end

class Pry::ObsoleteError
end

class Pry::ObsoleteError
end

class Pry::Output
  def <<(*objs); end

  def decolorize_maybe(str); end

  def height(); end

  def initialize(pry_instance); end

  def method_missing(method_name, *args, &block); end

  def print(*objs); end

  def pry_instance(); end

  def puts(*objs); end

  def size(); end

  def tty?(); end

  def width(); end

  def write(*objs); end
  DEFAULT_SIZE = ::T.let(nil, ::T.untyped)
end

class Pry::Output
end

class Pry::Pager
  def initialize(pry_instance); end

  def open(); end

  def page(text); end

  def pry_instance(); end
end

class Pry::Pager::NullPager
  def <<(str); end

  def close(); end

  def initialize(out); end

  def print(str); end

  def puts(str); end

  def write(str); end
end

class Pry::Pager::NullPager
end

class Pry::Pager::PageTracker
  def initialize(rows, cols); end

  def page?(); end

  def record(str); end

  def reset(); end
end

class Pry::Pager::PageTracker
end

class Pry::Pager::SimplePager
  def initialize(*_); end
end

class Pry::Pager::SimplePager
end

class Pry::Pager::StopPaging
end

class Pry::Pager::StopPaging
end

class Pry::Pager::SystemPager
  def initialize(*_); end
end

class Pry::Pager::SystemPager
  def self.available?(); end

  def self.default_pager(); end
end

class Pry::Pager
end

class Pry::PluginManager
  def load_plugins(); end

  def locate_plugins(); end

  def plugins(); end
  PRY_PLUGIN_PREFIX = ::T.let(nil, ::T.untyped)
end

class Pry::PluginManager::NoPlugin
  def initialize(name); end
end

class Pry::PluginManager::NoPlugin
end

class Pry::PluginManager::Plugin
  def activate!(); end

  def active(); end

  def active=(active); end

  def active?(); end

  def disable!(); end

  def enable!(); end

  def enabled(); end

  def enabled=(enabled); end

  def enabled?(); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def initialize(name, gem_name, spec, enabled); end

  def load_cli_options(); end

  def name(); end

  def name=(name); end

  def spec(); end

  def spec=(spec); end

  def supported?(); end
end

class Pry::PluginManager::Plugin
end

class Pry::PluginManager
end

class Pry::Prompt
  def [](key); end

  def description(); end

  def incomplete_proc(); end

  def initialize(name, description, prompt_procs); end

  def name(); end

  def prompt_procs(); end

  def wait_proc(); end
end

class Pry::Prompt
  def self.[](name); end

  def self.add(name, description=T.unsafe(nil), separators=T.unsafe(nil)); end

  def self.all(); end
end

class Pry::REPL
  def initialize(pry, options=T.unsafe(nil)); end

  def input(*args, &block); end

  def output(*args, &block); end

  def pry(); end

  def pry=(pry); end

  def start(); end
end

class Pry::REPL
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.start(options); end
end

class Pry::REPLFileLoader
  def define_additional_commands(); end

  def initialize(file_name); end

  def interactive_mode(pry_instance); end

  def load(); end

  def non_interactive_mode(pry_instance, content); end
end

class Pry::REPLFileLoader
end

module Pry::RescuableException
end

module Pry::RescuableException
  def self.===(exception); end
end

class Pry::Result
  def command?(); end

  def initialize(is_command, retval=T.unsafe(nil)); end

  def retval(); end

  def void_command?(); end
end

class Pry::Result
end

class Pry::Ring
  def <<(value); end

  def [](index); end

  def clear(); end

  def count(); end

  def initialize(max_size); end

  def max_size(); end

  def size(); end

  def to_a(); end
end

class Pry::Ring
end

class Pry::Slop
  include ::Enumerable
  def [](key); end

  def add_callback(label, &block); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def command(command, options=T.unsafe(nil), &block); end

  def config(); end

  def description(desc=T.unsafe(nil)); end

  def description=(desc); end

  def each(&block); end

  def fetch_command(command); end

  def fetch_option(key); end

  def get(key); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def missing(); end

  def on(*objects, &block); end

  def opt(*objects, &block); end

  def option(*objects, &block); end

  def options(); end

  def parse(items=T.unsafe(nil), &block); end

  def parse!(items=T.unsafe(nil), &block); end

  def present?(*keys); end

  def run(callable=T.unsafe(nil), &block); end

  def separator(text); end

  def strict?(); end

  def to_h(include_commands=T.unsafe(nil)); end

  def to_hash(include_commands=T.unsafe(nil)); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Commands
  include ::Enumerable
  def [](key); end

  def arguments(); end

  def banner(banner=T.unsafe(nil)); end

  def banner=(banner); end

  def commands(); end

  def config(); end

  def default(config=T.unsafe(nil), &block); end

  def each(&block); end

  def get(key); end

  def global(config=T.unsafe(nil), &block); end

  def help(); end

  def initialize(config=T.unsafe(nil), &block); end

  def on(command, config=T.unsafe(nil), &block); end

  def parse(items=T.unsafe(nil)); end

  def parse!(items=T.unsafe(nil)); end

  def present?(key); end

  def to_hash(); end
end

class Pry::Slop::Commands
end

class Pry::Slop::Error
end

class Pry::Slop::Error
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidArgumentError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidCommandError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::InvalidOptionError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingArgumentError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::MissingOptionError
end

class Pry::Slop::Option
  def accepts_optional_argument?(); end

  def argument?(); end

  def argument_in_value(); end

  def argument_in_value=(argument_in_value); end

  def as?(); end

  def autocreated?(); end

  def call(*objects); end

  def callback?(); end

  def config(); end

  def count(); end

  def count=(count); end

  def default?(); end

  def delimiter?(); end

  def description(); end

  def expects_argument?(); end

  def help(); end

  def initialize(slop, short, long, description, config=T.unsafe(nil), &block); end

  def key(); end

  def limit?(); end

  def long(); end

  def match?(); end

  def optional?(); end

  def optional_argument?(); end

  def required?(); end

  def short(); end

  def tail?(); end

  def types(); end

  def value(); end

  def value=(new_value); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Pry::Slop::Option
end

class Pry::Slop
  def self.optspec(string, config=T.unsafe(nil)); end

  def self.parse(items=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def self.parse!(items=T.unsafe(nil), config=T.unsafe(nil), &block); end
end

class Pry::SyntaxHighlighter
end

class Pry::SyntaxHighlighter
  def self.highlight(code, language=T.unsafe(nil)); end

  def self.keyword_token_color(); end

  def self.overwrite_coderay_comment_token!(); end

  def self.tokenize(code, language=T.unsafe(nil)); end
end

module Pry::SystemCommandHandler
end

module Pry::SystemCommandHandler
  def self.default(output, command, _pry_instance); end
end

module Pry::TooSafeException
end

module Pry::TooSafeException
  def self.===(exception); end
end

module Pry::UserError
end

module Pry::UserError
end

module Pry::Warning
end

module Pry::Warning
  def self.warn(message); end
end

class Pry::WrappedModule
  include ::Pry::Helpers::BaseHelpers
  include ::Pry::CodeObject::Helpers
  def candidate(rank); end

  def candidates(); end

  def class?(); end

  def constants(inherit=T.unsafe(nil)); end

  def doc(); end

  def file(); end

  def initialize(mod); end

  def line(); end

  def method_missing(method_name, *args, &block); end

  def method_prefix(); end

  def module?(); end

  def nonblank_name(); end

  def number_of_candidates(); end

  def singleton_class?(); end

  def singleton_instance(); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def super(times=T.unsafe(nil)); end

  def wrapped(); end

  def yard_doc(); end

  def yard_docs?(); end

  def yard_file(); end

  def yard_line(); end
end

class Pry::WrappedModule::Candidate
  include ::Pry::Helpers::DocumentationHelpers
  include ::Pry::CodeObject::Helpers
  def class?(*args, &block); end

  def doc(); end

  def file(); end

  def initialize(wrapper, rank); end

  def line(); end

  def module?(*args, &block); end

  def nonblank_name(*args, &block); end

  def number_of_candidates(*args, &block); end

  def source(); end

  def source_file(); end

  def source_line(); end

  def source_location(); end

  def wrapped(*args, &block); end
end

class Pry::WrappedModule::Candidate
  extend ::Pry::Forwardable
  extend ::Forwardable
end

class Pry::WrappedModule
  def self.from_str(mod_name, target=T.unsafe(nil)); end
end

class Pry
  extend ::Pry::Forwardable
  extend ::Forwardable
  def self.Code(obj); end

  def self.Method(obj); end

  def self.WrappedModule(obj); end

  def self.auto_resize!(); end

  def self.binding_for(target); end

  def self.cli(); end

  def self.cli=(cli); end

  def self.color(*args, &block); end

  def self.color=(*args, &block); end

  def self.commands(*args, &block); end

  def self.commands=(*args, &block); end

  def self.config(); end

  def self.config=(config); end

  def self.configure(); end

  def self.critical_section(); end

  def self.current(); end

  def self.current_line(); end

  def self.current_line=(current_line); end

  def self.custom_completions(); end

  def self.custom_completions=(custom_completions); end

  def self.editor(*args, &block); end

  def self.editor=(*args, &block); end

  def self.eval_path(); end

  def self.eval_path=(eval_path); end

  def self.exception_handler(*args, &block); end

  def self.exception_handler=(*args, &block); end

  def self.extra_sticky_locals(*args, &block); end

  def self.extra_sticky_locals=(*args, &block); end

  def self.final_session_setup(); end

  def self.history(*args, &block); end

  def self.history=(*args, &block); end

  def self.hooks(*args, &block); end

  def self.hooks=(*args, &block); end

  def self.in_critical_section?(); end

  def self.init(); end

  def self.initial_session?(); end

  def self.initial_session_setup(); end

  def self.input(*args, &block); end

  def self.input=(*args, &block); end

  def self.last_internal_error(); end

  def self.last_internal_error=(last_internal_error); end

  def self.line_buffer(); end

  def self.line_buffer=(line_buffer); end

  def self.load_file_at_toplevel(file); end

  def self.load_file_through_repl(file_name); end

  def self.load_history(); end

  def self.load_plugins(*args, &block); end

  def self.load_rc_files(); end

  def self.load_requires(); end

  def self.load_traps(); end

  def self.load_win32console(); end

  def self.locate_plugins(*args, &block); end

  def self.main(); end

  def self.memory_size(*args, &block); end

  def self.memory_size=(*args, &block); end

  def self.output(*args, &block); end

  def self.output=(*args, &block); end

  def self.pager(*args, &block); end

  def self.pager=(*args, &block); end

  def self.plugins(*args, &block); end

  def self.print(*args, &block); end

  def self.print=(*args, &block); end

  def self.prompt(*args, &block); end

  def self.prompt=(*args, &block); end

  def self.quiet(); end

  def self.quiet=(quiet); end

  def self.rc_files_to_load(); end

  def self.real_path_to(file); end

  def self.reset_defaults(); end

  def self.run_command(command_string, options=T.unsafe(nil)); end

  def self.start(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.start_with_pry_byebug(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.start_without_pry_byebug(target=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.toplevel_binding(); end

  def self.toplevel_binding=(toplevel_binding); end

  def self.view_clip(obj, options=T.unsafe(nil)); end
end

module PryByebug
  def current_remote_server(); end

  def current_remote_server=(current_remote_server); end
end

class PryByebug::BacktraceCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::BacktraceCommand
end

class PryByebug::BreakCommand
  include ::PryByebug::Helpers::Breakpoints
  include ::PryByebug::Helpers::Location
  include ::PryByebug::Helpers::Multiline
end

class PryByebug::BreakCommand
end

class PryByebug::ContinueCommand
  include ::PryByebug::Helpers::Navigation
  include ::PryByebug::Helpers::Breakpoints
  include ::PryByebug::Helpers::Location
end

class PryByebug::ContinueCommand
end

class PryByebug::DownCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::DownCommand
end

class PryByebug::ExitAllCommand
end

class PryByebug::ExitAllCommand
end

class PryByebug::FinishCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::FinishCommand
end

class PryByebug::FrameCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::FrameCommand
end

module PryByebug::Helpers
end

module PryByebug::Helpers::Breakpoints
  def bold_puts(msg); end

  def breakpoints(); end

  def max_width(); end

  def print_breakpoints_header(); end

  def print_full_breakpoint(breakpoint); end

  def print_short_breakpoint(breakpoint); end
end

module PryByebug::Helpers::Breakpoints
end

module PryByebug::Helpers::Location
end

module PryByebug::Helpers::Location
  def self.current_file(source=T.unsafe(nil)); end
end

module PryByebug::Helpers::Multiline
  def check_multiline_context(); end
end

module PryByebug::Helpers::Multiline
end

module PryByebug::Helpers::Navigation
  def breakout_navigation(action, options=T.unsafe(nil)); end
end

module PryByebug::Helpers::Navigation
end

module PryByebug::Helpers
end

class PryByebug::NextCommand
  include ::PryByebug::Helpers::Navigation
  include ::PryByebug::Helpers::Multiline
end

class PryByebug::NextCommand
end

class PryByebug::StepCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::StepCommand
end

class PryByebug::UpCommand
  include ::PryByebug::Helpers::Navigation
end

class PryByebug::UpCommand
end

module PryByebug
  def self.check_file_context(target, msg=T.unsafe(nil)); end

  def self.file_context?(target); end
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

class REXML::AttlistDecl
  def initialize(source); end
end

class REXML::Attribute
  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Attributes
  def initialize(element); end
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end
end

class REXML::Child
  def initialize(parent=T.unsafe(nil)); end
end

class REXML::Comment
  def initialize(first, second=T.unsafe(nil)); end
end

class REXML::Declaration
  def initialize(src); end
end

class REXML::DocType
  def initialize(first, parent=T.unsafe(nil)); end
end

class REXML::Document
  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Element
  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end
end

class REXML::Elements
  def initialize(parent); end
end

class REXML::Entity
  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end
end

class REXML::ExternalEntity
  def initialize(src); end
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end
end

class REXML::Formatters::Pretty
  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::Instruction
  def initialize(target, content=T.unsafe(nil)); end
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end
end

class REXML::Output
  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::ParseException
  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end
end

class REXML::Parsers::BaseParser
  def initialize(source); end
  QNAME = ::T.let(nil, ::T.untyped)
  QNAME_STR = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::StreamParser
  def initialize(source, listener); end
end

class REXML::Parsers::TreeParser
  def initialize(source, build_context=T.unsafe(nil)); end
end

class REXML::Parsers::XPathParser
  LOCAL_NAME_WILDCARD = ::T.let(nil, ::T.untyped)
  PREFIX_WILDCARD = ::T.let(nil, ::T.untyped)
end

class REXML::Source
  def initialize(arg, encoding=T.unsafe(nil)); end
end

class REXML::Text
  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::XMLDecl
  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end
end

class REXML::XPath
  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), options=T.unsafe(nil)); end
end

class REXML::XPathNode
  def context(); end

  def initialize(node, context=T.unsafe(nil)); end

  def position(); end

  def raw_node(); end
end

class REXML::XPathNode
end

class REXML::XPathParser
  def initialize(strict: T.unsafe(nil)); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

module RSpec::Core
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::BacktraceFormatter
end

module RSpec::Core::Bisect
end

class RSpec::Core::Bisect::BisectFailedError
end

class RSpec::Core::Bisect::BisectFailedError
  def self.for_failed_spec_run(spec_output); end
end

class RSpec::Core::Bisect::Channel
  def close(); end

  def receive(); end

  def send(message); end
end

class RSpec::Core::Bisect::Channel
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def all_example_ids(); end

  def all_example_ids=(_); end

  def failed_example_ids(); end

  def failed_example_ids=(_); end
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Bisect::Notifier
  def initialize(formatter); end

  def publish(event, *args); end
end

class RSpec::Core::Bisect::Notifier
end

module RSpec::Core::Bisect
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks
  include ::RSpec::Core::Configuration::Readers
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_exit_code=(error_exit_code); end

  def error_exit_code?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(value); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples(); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_exit_code(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

module RSpec::Core::Configuration::Readers
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_alias(name, alias_name); end

  def self.define_predicate(name); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
end

module RSpec::Core::DSL
end

module RSpec::Core::DSL
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DidYouMean
  def call(); end

  def initialize(relative_file_name); end

  def relative_file_name(); end
end

class RSpec::Core::DidYouMean
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

RSpec::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example::Procsy
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MemoizedHelpers
  include ::RSpec::Core::Pending
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup
  extend ::RSpec::Core::Hooks
  extend ::RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::RSpec::Core::SharedExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.descendants(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusDumper
  def dump(); end

  def initialize(examples); end
end

class RSpec::Core::ExampleStatusDumper
  def self.dump(examples); end
end

class RSpec::Core::ExampleStatusMerger
  def initialize(this_run, from_previous_runs); end

  def merge(); end
end

class RSpec::Core::ExampleStatusMerger
  def self.merge(this_run, from_previous_runs); end
end

class RSpec::Core::ExampleStatusParser
  def initialize(string); end

  def parse(); end
end

class RSpec::Core::ExampleStatusParser
  def self.parse(string); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

RSpec::Core::ExclusionRules = RSpec::Core::FilterRules

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterManager
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

module RSpec::Core::FilterableItemRepository
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
end

module RSpec::Core::FilterableItemRepository
end

module RSpec::Core::FlatMap
end

module RSpec::Core::FlatMap
  def self.flat_map(array, &block); end
end

module RSpec::Core::Formatters
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  def self.format_backtrace(*_); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
end

class RSpec::Core::Formatters::ExceptionPresenter
end

class RSpec::Core::Formatters::FailureListFormatter
  def dump_profile(_profile); end

  def example_failed(failure); end

  def message(_message); end
end

class RSpec::Core::Formatters::FailureListFormatter
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::HtmlPrinter
  include ::ERB::Util
  def flush(); end

  def initialize(output); end

  def make_example_group_header_red(group_id); end

  def make_example_group_header_yellow(group_id); end

  def make_header_red(); end

  def make_header_yellow(); end

  def move_progress(percent_done); end

  def print_example_failed(pending_fixed, description, run_time, failure_id, exception, extra_content); end

  def print_example_group_end(); end

  def print_example_group_start(group_id, description, number_of_parents); end

  def print_example_passed(description, run_time); end

  def print_example_pending(description, pending_message); end

  def print_html_start(); end

  def print_summary(duration, example_count, failure_count, pending_count); end
  GLOBAL_SCRIPTS = ::T.let(nil, ::T.untyped)
  GLOBAL_STYLES = ::T.let(nil, ::T.untyped)
  HTML_HEADER = ::T.let(nil, ::T.untyped)
  REPORT_HEADER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::HtmlPrinter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  def self.highlight_syntax(lines); end
end

RSpec::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::HashImitatable
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterContextHook
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::AroundHook
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::BeforeHook
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Hooks::HookCollections
end

module RSpec::Core::Hooks
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::InclusionRules
end

module RSpec::Core::Invocations
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::Bisect
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::InitializeProject
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::Invocations::PrintVersion
end

module RSpec::Core::Invocations
end

class RSpec::Core::LegacyExampleGroupHash
  include ::RSpec::Core::HashImitatable
  def initialize(metadata); end
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MemoizedHelpers
  def initialize(*_); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
end

module RSpec::Core::MemoizedHelpers
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

class RSpec::Core::Metadata::HashPopulator
end

module RSpec::Core::Metadata
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
end

module RSpec::Core::MetadataFilter
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

class RSpec::Core::MultipleExceptionError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def self.for(ex); end
end

class RSpec::Core::MultipleExceptionError
end

module RSpec::Core::Notifications
end

class RSpec::Core::Notifications::CustomNotification
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.from_hash(data); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.for(example); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::ExamplesNotification
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
end

module RSpec::Core::Notifications::NullColorizer
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::ProfileNotification
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  include ::RSpec::Core::ShellEscape
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications
end

class RSpec::Core::NullReporter
end

class RSpec::Core::NullReporter
end

module RSpec::Core::Ordering
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::ConfigurationManager
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Custom
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Identity
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::Ordering::Registry
end

module RSpec::Core::Ordering
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def gets(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def method_missing(name, *args, &block); end

  def nread(*args, &block); end

  def output(); end

  def output=(output); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::OutputWrapper
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

class RSpec::Core::Pending::SkipDeclaredInExample
end

module RSpec::Core::Pending
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def exit_early(exit_code); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
end

module RSpec::Core::RubyProject
end

module RSpec::Core::RubyProject
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def exit_code(examples_passed=T.unsafe(nil)); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  include ::Enumerable
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

class RSpec::Core::Set
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

class RSpec::Core::SharedExampleGroup::Registry
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

module RSpec::Core::SharedExampleGroup
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

class RSpec::Core::SharedExampleGroupModule
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  def self.conditionally_quote(id); end

  def self.escape(shell_command); end

  def self.quote(argument); end

  def self.shell_allows_unquoted_ids?(); end
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::SuiteHookContext
end

class RSpec::Core::Time
end

class RSpec::Core::Time
  def self.now(); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

module RSpec::Core::Warnings
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_group_counts_by_spec_file(); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
end

module RSpec::Core::World::Null
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(); end
end

class RSpec::Core::World
end

module RSpec::Core
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
end

module RSpec::ExampleGroups
  extend ::RSpec::Support::RecursiveConstMethods
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

module RSpec::Expectations
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockExpectationTarget
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def strict_predicate_matchers(); end

  def strict_predicate_matchers=(flag); end

  def strict_predicate_matchers?(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

module RSpec::Expectations::ExpectationHelper
end

module RSpec::Expectations::ExpectationHelper
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

RSpec::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
end

class RSpec::Expectations::NegativeExpectationHandler
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, custom_message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, custom_message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
end

module RSpec::Expectations::Syntax
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
end

module RSpec::Expectations
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, &block); end

  def cover(*values); end

  def covering(*args, &block); end

  def end_with(*expected); end

  def ending_with(*args, &block); end

  def eq(expected); end

  def eq_to(*args, &block); end

  def eql(expected); end

  def eql_to(*args, &block); end

  def equal(expected); end

  def equal_to(*args, &block); end

  def exist(*args); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, &block); end

  def include(*expected); end

  def including(*args, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, &block); end

  def respond_to(*names); end

  def responding_to(*args, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, &block); end

  def start_with(*expected); end

  def starting_with(*args, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*_); end
end

class RSpec::Matchers::AliasedMatcher
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

RSpec::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::AliasedNegatedMatcher
end

module RSpec::Matchers::BuiltIn
end

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  def self.improve_hash_formatting(inspect_string); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual); end

  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

module RSpec::Matchers::BuiltIn::CaptureStderr
end

module RSpec::Matchers::BuiltIn::CaptureStderr
  def self.capture(block); end
end

module RSpec::Matchers::BuiltIn::CaptureStdout
end

module RSpec::Matchers::BuiltIn::CaptureStdout
  def self.capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
  def capture(block); end
end

class RSpec::Matchers::BuiltIn::CaptureStreamToTempfile
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::ChangeDetails
  def actual_after(); end

  def actual_delta(); end

  def changed?(); end

  def initialize(matcher_name, receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def perform_change(event_proc); end

  def value_representation(); end
end

class RSpec::Matchers::BuiltIn::ChangeDetails
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
  def does_not_match?(event_proc); end

  def initialize(change_details, expected_before); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::ChangeFromValue
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
  def does_not_match?(_event_proc); end

  def initialize(change_details, expected_delta, relativity, &comparer); end

  def matches?(event_proc); end
end

class RSpec::Matchers::BuiltIn::ChangeRelatively
end

class RSpec::Matchers::BuiltIn::ChangeToValue
  def does_not_match?(_event_proc); end

  def from(value); end

  def initialize(change_details, expected_after); end
end

class RSpec::Matchers::BuiltIn::ChangeToValue
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

module RSpec::Matchers::BuiltIn::CountExpectation
  def at_least(number); end

  def at_most(number); end

  def count_expectation_type(); end

  def exactly(number); end

  def expected_count(); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

module RSpec::Matchers::BuiltIn::CountExpectation
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::DynamicPredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::DynamicPredicate
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  include ::RSpec::Matchers::BuiltIn::CountExpectation
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

module RSpec::Matchers::BuiltIn::NullCapture
end

module RSpec::Matchers::BuiltIn::NullCapture
  def self.capture(_block); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message, expected_message, &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def with_message(expected_message); end
  UndefinedValue = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
  def captures(); end

  def initialize(match_data); end

  def match_data(); end

  def names(); end
end

class RSpec::Matchers::BuiltIn::ReliableMatchData
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def ignoring_method_signature_failure!(); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo::ArityCheck
  def initialize(expected_arity, expected_keywords, arbitrary_keywords, unlimited_arguments); end

  def matches?(actual, name); end

  def method_signature_for(actual, name); end

  def verifier_for(actual, name); end
end

class RSpec::Matchers::BuiltIn::RespondTo::ArityCheck
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::SpecificValuesChange
  def initialize(change_details, from, to); end

  def matches?(event_proc); end
end

RSpec::Matchers::BuiltIn::SpecificValuesChange::MATCH_ANYTHING = BasicObject

class RSpec::Matchers::BuiltIn::SpecificValuesChange
end

RSpec::Matchers::BuiltIn::StartAndEndWith = RSpec::Matchers::BuiltIn::StartOrEndWith

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  include ::RSpec::Matchers::BuiltIn::CountExpectation
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def assert_used!(); end

  def assert_valid_expect_block!(); end

  def has_block?(); end

  def initialize(block, &callback); end

  def num_yields(); end

  def num_yields=(num_yields); end

  def probe(); end

  def single_yield_args(); end

  def to_proc(); end

  def yielded_args(); end

  def yielded_args=(yielded_args); end

  def yielded_once?(matcher_name); end
end

class RSpec::Matchers::BuiltIn::YieldProbe
  def self.probe(block, &callback); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::BuiltIn
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end
end

module RSpec::Matchers::DSL::DefaultImplementations
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(options=T.unsafe(nil), &match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL::Macros
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Composable
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

class RSpec::Matchers::DSL::Matcher
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL
end

module RSpec::Matchers::EnglishPhrasing
end

module RSpec::Matchers::EnglishPhrasing
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def initialize(expected_list); end

  def message_with_diff(message, differ, actual); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def self.for_many_matchers(matchers); end

  def self.from(expected); end
end

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MatcherDelegator
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Mocks
  DEFAULT_CALLBACK_INVOCATION_STRATEGY = ::T.let(nil, ::T.untyped)
  IGNORED_BACKTRACE_LINE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AllowanceTarget
end

class RSpec::Mocks::AndReturnImplementation
  def call(*_args_to_ignore, &_block); end

  def initialize(values_to_return); end
end

class RSpec::Mocks::AndReturnImplementation
end

class RSpec::Mocks::AndWrapOriginalImplementation
  def call(*args, &block); end

  def initial_action=(_value); end

  def initialize(method, block); end

  def inner_action(); end

  def inner_action=(_value); end

  def present?(); end

  def terminal_action=(_value); end
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation::CannotModifyFurtherError
end

class RSpec::Mocks::AndWrapOriginalImplementation
end

class RSpec::Mocks::AndYieldImplementation
  def call(*_args_to_ignore, &block); end

  def initialize(args_to_yield, eval_context, error_generator); end
end

class RSpec::Mocks::AndYieldImplementation
end

module RSpec::Mocks::AnyInstance
end

class RSpec::Mocks::AnyInstance::Chain
  include ::RSpec::Mocks::AnyInstance::Chain::Customizations
  def constrained_to_any_of?(*constraints); end

  def expectation_fulfilled!(); end

  def initialize(recorder, *args, &block); end

  def matches_args?(*args); end

  def never(); end

  def playback!(instance); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def self.record(method_name); end
end

class RSpec::Mocks::AnyInstance::Chain
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
  def raise_does_not_implement_error(klass, method_name); end

  def raise_message_already_received_by_other_instance_error(method_name, object_inspect, invoked_instance); end

  def raise_not_supported_with_prepend_error(method_name, problem_mod); end

  def raise_second_instance_received_message_error(unfulfilled_expectations); end
end

class RSpec::Mocks::AnyInstance::ErrorGenerator
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::ExpectChainChain
end

class RSpec::Mocks::AnyInstance::ExpectationChain
  def expectation_fulfilled?(); end

  def initialize(*args, &block); end
end

class RSpec::Mocks::AnyInstance::ExpectationChain
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
  def initialize(targets); end

  def method_missing(*args, &block); end
end

class RSpec::Mocks::AnyInstance::FluentInterfaceProxy
end

class RSpec::Mocks::AnyInstance::MessageChains
  def [](method_name); end

  def add(method_name, chain); end

  def all_expectations_fulfilled?(); end

  def each_unfulfilled_expectation_matching(method_name, *args); end

  def has_expectation?(method_name); end

  def playback!(instance, method_name); end

  def received_expected_message!(method_name); end

  def remove_stub_chains_for!(method_name); end

  def unfulfilled_expectations(); end
end

class RSpec::Mocks::AnyInstance::MessageChains
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
  ExpectationInvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::PositiveExpectationChain
end

class RSpec::Mocks::AnyInstance::Proxy
  def expect_chain(*chain, &block); end

  def initialize(recorder, target_proxies); end

  def klass(); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stub(method_name_or_method_map, &block); end

  def stub_chain(*chain, &block); end

  def unstub(method_name); end
end

class RSpec::Mocks::AnyInstance::Proxy
end

class RSpec::Mocks::AnyInstance::Recorder
  include ::T::CompatibilityPatches::RSpecCompatibility::RecorderExtensions
  def already_observing?(method_name); end

  def build_alias_method_name(method_name); end

  def expect_chain(*method_names_and_optional_return_values, &block); end

  def initialize(klass); end

  def instance_that_received(method_name); end

  def klass(); end

  def message_chains(); end

  def notify_received_message(_object, message, args, _blk); end

  def playback!(instance, method_name); end

  def should_not_receive(method_name, &block); end

  def should_receive(method_name, &block); end

  def stop_all_observation!(); end

  def stop_observing!(method_name); end

  def stub(method_name, &block); end

  def stub_chain(*method_names_and_optional_return_values, &block); end

  def stubs(); end

  def unstub(method_name); end

  def verify(); end
end

class RSpec::Mocks::AnyInstance::Recorder
end

class RSpec::Mocks::AnyInstance::StubChain
  def expectation_fulfilled?(); end
  EmptyInvocationOrder = ::T.let(nil, ::T.untyped)
  InvocationOrder = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::AnyInstance::StubChain
end

class RSpec::Mocks::AnyInstance::StubChainChain
  def initialize(*args); end
end

class RSpec::Mocks::AnyInstance::StubChainChain
end

module RSpec::Mocks::AnyInstance
  def self.error_generator(); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def expression(); end

  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
end

class RSpec::Mocks::ArgumentListMatcher
  def args_match?(*args); end

  def expected_args(); end

  def initialize(*expected_args); end

  def resolve_expected_args_based_on(actual_args); end
  MATCH_ALL = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentListMatcher
end

module RSpec::Mocks::ArgumentMatchers
  def a_kind_of(klass); end

  def an_instance_of(klass); end

  def any_args(); end

  def anything(); end

  def array_including(*args); end

  def boolean(); end

  def duck_type(*args); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def hash_not_including(*args); end

  def instance_of(klass); end

  def kind_of(klass); end

  def no_args(); end
end

class RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
  def ===(_other); end

  def description(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::AnyArgMatcher
end

class RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher
  def description(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::AnyArgsMatcher
end

class RSpec::Mocks::ArgumentMatchers::ArrayIncludingMatcher
  def ===(actual); end

  def description(); end

  def initialize(expected); end
end

class RSpec::Mocks::ArgumentMatchers::ArrayIncludingMatcher
end

class RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
  def ===(predicate, actual); end

  def description(name); end

  def initialize(expected); end
end

class RSpec::Mocks::ArgumentMatchers::BaseHashMatcher
end

class RSpec::Mocks::ArgumentMatchers::BooleanMatcher
  def ===(value); end

  def description(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::BooleanMatcher
end

class RSpec::Mocks::ArgumentMatchers::DuckTypeMatcher
  def ===(value); end

  def description(); end

  def initialize(*methods_to_respond_to); end
end

class RSpec::Mocks::ArgumentMatchers::DuckTypeMatcher
end

class RSpec::Mocks::ArgumentMatchers::HashExcludingMatcher
  def ===(actual); end

  def description(); end
end

class RSpec::Mocks::ArgumentMatchers::HashExcludingMatcher
end

class RSpec::Mocks::ArgumentMatchers::HashIncludingMatcher
  def ===(actual); end

  def description(); end
end

class RSpec::Mocks::ArgumentMatchers::HashIncludingMatcher
end

class RSpec::Mocks::ArgumentMatchers::InstanceOf
  def ===(actual); end

  def description(); end

  def initialize(klass); end
end

class RSpec::Mocks::ArgumentMatchers::InstanceOf
end

class RSpec::Mocks::ArgumentMatchers::KindOf
  def ===(actual); end

  def description(); end

  def initialize(klass); end
end

class RSpec::Mocks::ArgumentMatchers::KindOf
end

class RSpec::Mocks::ArgumentMatchers::NoArgsMatcher
  def description(); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ArgumentMatchers::NoArgsMatcher
end

class RSpec::Mocks::ArgumentMatchers::SingletonMatcher
end

class RSpec::Mocks::ArgumentMatchers::SingletonMatcher
  def self.inherited(subklass); end
end

module RSpec::Mocks::ArgumentMatchers
  def self.anythingize_lonely_keys(*args); end
end

class RSpec::Mocks::CallbackInvocationStrategy
  def call(doubled_module); end
end

class RSpec::Mocks::CallbackInvocationStrategy
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::CannotSupportArgMutationsError
end

class RSpec::Mocks::ClassNewMethodReference
end

class RSpec::Mocks::ClassNewMethodReference
  def self.applies_to?(method_name); end
end

class RSpec::Mocks::ClassVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ClassVerifyingDouble
end

class RSpec::Mocks::Configuration
  def add_stub_and_should_receive_to(*modules); end

  def allow_message_expectations_on_nil(); end

  def allow_message_expectations_on_nil=(allow_message_expectations_on_nil); end

  def before_verifying_doubles(&block); end

  def color?(); end

  def patch_marshal_to_support_partial_doubles=(val); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(*values); end

  def temporarily_suppress_partial_double_verification(); end

  def temporarily_suppress_partial_double_verification=(temporarily_suppress_partial_double_verification); end

  def transfer_nested_constants=(transfer_nested_constants); end

  def transfer_nested_constants?(); end

  def verify_doubled_constant_names=(verify_doubled_constant_names); end

  def verify_doubled_constant_names?(); end

  def verify_partial_doubles=(val); end

  def verify_partial_doubles?(); end

  def verifying_double_callbacks(); end

  def when_declaring_verifying_double(&block); end

  def yield_receiver_to_any_instance_implementation_blocks=(yield_receiver_to_any_instance_implementation_blocks); end

  def yield_receiver_to_any_instance_implementation_blocks?(); end
end

class RSpec::Mocks::Configuration
end

class RSpec::Mocks::Constant
  def hidden=(hidden); end

  def hidden?(); end

  def initialize(name); end

  def mutated?(); end

  def name(); end

  def original_value(); end

  def original_value=(original_value); end

  def previously_defined=(previously_defined); end

  def previously_defined?(); end

  def stubbed=(stubbed); end

  def stubbed?(); end

  def valid_name=(valid_name); end

  def valid_name?(); end
end

class RSpec::Mocks::Constant
  extend ::RSpec::Support::RecursiveConstMethods
  def self.original(name); end

  def self.unmutated(name); end
end

class RSpec::Mocks::ConstantMutator
end

class RSpec::Mocks::ConstantMutator::BaseMutator
  include ::RSpec::Support::RecursiveConstMethods
  def full_constant_name(); end

  def idempotently_reset(); end

  def initialize(full_constant_name, mutated_value, transfer_nested_constants); end

  def original_value(); end

  def to_constant(); end
end

class RSpec::Mocks::ConstantMutator::BaseMutator
end

class RSpec::Mocks::ConstantMutator::ConstantHider
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::ConstantHider
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
  def initialize(*args); end

  def mutate(); end

  def reset(); end

  def should_transfer_nested_constants?(); end

  def transfer_nested_constants(); end

  def verify_constants_to_transfer!(); end
end

class RSpec::Mocks::ConstantMutator::DefinedConstantReplacer
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
  def mutate(); end

  def reset(); end
end

class RSpec::Mocks::ConstantMutator::UndefinedConstantSetter
end

class RSpec::Mocks::ConstantMutator
  extend ::RSpec::Support::RecursiveConstMethods
  def self.hide(constant_name); end

  def self.mutate(mutator); end

  def self.raise_on_invalid_const(); end

  def self.stub(constant_name, value, options=T.unsafe(nil)); end
end

class RSpec::Mocks::DirectObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(object); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::DirectObjectReference
end

class RSpec::Mocks::Double
  include ::RSpec::Mocks::TestDouble
end

class RSpec::Mocks::Double
end

class RSpec::Mocks::ErrorGenerator
  def default_error_message(expectation, expected_args, actual_args); end

  def describe_expectation(verb, message, expected_received_count, _actual_received_count, args); end

  def expectation_on_nil_message(method_name); end

  def initialize(target=T.unsafe(nil)); end

  def intro(unwrapped=T.unsafe(nil)); end

  def method_call_args_description(args, generic_prefix=T.unsafe(nil), matcher_prefix=T.unsafe(nil)); end

  def opts(); end

  def opts=(opts); end

  def raise_already_invoked_error(message, calling_customization); end

  def raise_cant_constrain_count_for_negated_have_received_error(count_constraint); end

  def raise_double_negation_error(wrapped_expression); end

  def raise_expectation_error(message, expected_received_count, argument_list_matcher, actual_received_count, expectation_count_type, args, backtrace_line=T.unsafe(nil), source_id=T.unsafe(nil)); end

  def raise_expectation_on_mocked_method(method); end

  def raise_expectation_on_nil_error(method_name); end

  def raise_expectation_on_unstubbed_method(method); end

  def raise_expired_test_double_error(); end

  def raise_have_received_disallowed(type, reason); end

  def raise_invalid_arguments_error(verifier); end

  def raise_method_not_stubbed_error(method_name); end

  def raise_missing_block_error(args_to_yield); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_non_public_error(method_name, visibility); end

  def raise_only_valid_on_a_partial_double(method); end

  def raise_out_of_order_error(message); end

  def raise_similar_message_args_error(expectation, args_for_multiple_calls, backtrace_line=T.unsafe(nil)); end

  def raise_unexpected_message_args_error(expectation, args_for_multiple_calls, source_id=T.unsafe(nil)); end

  def raise_unexpected_message_error(message, args); end

  def raise_unimplemented_error(doubled_module, method_name, object); end

  def raise_verifying_double_not_defined_error(ref); end

  def raise_wrong_arity_error(args_to_yield, signature); end
end

class RSpec::Mocks::ErrorGenerator
end

module RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  def allow(target); end

  def allow_any_instance_of(klass); end

  def allow_message_expectations_on_nil(); end

  def class_double(doubled_class, *args); end

  def class_spy(*args); end

  def double(*args); end

  def expect_any_instance_of(klass); end

  def have_received(method_name, &block); end

  def hide_const(constant_name); end

  def instance_double(doubled_class, *args); end

  def instance_spy(*args); end

  def object_double(object_or_name, *args); end

  def object_spy(*args); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end

  def spy(*args); end

  def stub_const(constant_name, value, options=T.unsafe(nil)); end

  def without_partial_double_verification(); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
end

module RSpec::Mocks::ExampleMethods
  def self.declare_double(type, *args); end

  def self.declare_verifying_double(type, ref, *args); end

  def self.extended(object); end

  def self.included(klass); end
end

class RSpec::Mocks::ExpectChain
end

class RSpec::Mocks::ExpectChain
  def self.expect_chain_on(object, *chain, &blk); end
end

class RSpec::Mocks::ExpectationTarget
  include ::RSpec::Mocks::ExpectationTargetMethods
end

class RSpec::Mocks::ExpectationTarget
end

module RSpec::Mocks::ExpectationTargetMethods
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def expression(); end

  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

module RSpec::Mocks::ExpectationTargetMethods
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::ExpiredTestDoubleError
end

class RSpec::Mocks::Implementation
  def call(*args, &block); end

  def initial_action(); end

  def initial_action=(initial_action); end

  def inner_action(); end

  def inner_action=(inner_action); end

  def present?(); end

  def terminal_action(); end

  def terminal_action=(terminal_action); end
end

class RSpec::Mocks::Implementation
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodReference
end

class RSpec::Mocks::InstanceMethodStasher
  def handle_restoration_failures(); end

  def initialize(object, method); end

  def method_is_stashed?(); end

  def original_method(); end

  def restore(); end

  def stash(); end
end

class RSpec::Mocks::InstanceMethodStasher
end

class RSpec::Mocks::InstanceVerifyingDouble
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::InstanceVerifyingDouble
end

class RSpec::Mocks::MarshalExtension
end

class RSpec::Mocks::MarshalExtension
  def self.patch!(); end

  def self.unpatch!(); end
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::Matchers::ExpectationCustomization
  def block(); end

  def block=(block); end

  def initialize(method_name, args, block); end

  def playback_onto(expectation); end
end

class RSpec::Mocks::Matchers::ExpectationCustomization
end

class RSpec::Mocks::Matchers::HaveReceived
  include ::RSpec::Mocks::Matchers::Matcher
  def at_least(*args); end

  def at_most(*args); end

  def description(); end

  def does_not_match?(subject); end

  def exactly(*args); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method_name, &block); end

  def matches?(subject, &block); end

  def name(); end

  def once(*args); end

  def ordered(*args); end

  def setup_allowance(_subject, &_block); end

  def setup_any_instance_allowance(_subject, &_block); end

  def setup_any_instance_expectation(_subject, &_block); end

  def setup_any_instance_negative_expectation(_subject, &_block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
  ARGS_CONSTRAINTS = ::T.let(nil, ::T.untyped)
  CONSTRAINTS = ::T.let(nil, ::T.untyped)
  COUNT_CONSTRAINTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Matchers::HaveReceived
end

module RSpec::Mocks::Matchers::Matcher
end

module RSpec::Mocks::Matchers::Matcher
end

class RSpec::Mocks::Matchers::Receive
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def description(); end

  def does_not_match?(subject, &block); end

  def exactly(*args, &block); end

  def initialize(message, block); end

  def matches?(subject, &block); end

  def name(); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_any_instance_negative_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(subject, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
  def description_for(verb); end

  def initialize(message); end
end

class RSpec::Mocks::Matchers::Receive::DefaultDescribable
end

class RSpec::Mocks::Matchers::Receive
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  include ::RSpec::Mocks::Matchers::Matcher
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def description(); end

  def does_not_match?(*_args); end

  def initialize(chain, &block); end

  def matches?(subject, &block); end

  def name(); end

  def setup_allowance(subject, &block); end

  def setup_any_instance_allowance(subject, &block); end

  def setup_any_instance_expectation(subject, &block); end

  def setup_expectation(subject, &block); end

  def setup_negative_expectation(*_args); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
end

class RSpec::Mocks::Matchers::ReceiveMessages
  include ::RSpec::Mocks::Matchers::Matcher
  def description(); end

  def does_not_match?(_subject); end

  def initialize(message_return_value_hash); end

  def matches?(subject); end

  def name(); end

  def setup_allowance(subject); end

  def setup_any_instance_allowance(subject); end

  def setup_any_instance_expectation(subject); end

  def setup_expectation(subject); end

  def setup_negative_expectation(_subject); end

  def warn_about_block(); end
end

class RSpec::Mocks::Matchers::ReceiveMessages
end

module RSpec::Mocks::Matchers
end

class RSpec::Mocks::MessageChain
  def block(); end

  def chain(); end

  def initialize(object, *chain, &blk); end

  def object(); end

  def setup_chain(); end
end

class RSpec::Mocks::MessageChain
end

class RSpec::Mocks::MessageExpectation
  include ::RSpec::Mocks::MessageExpectation::ImplementationDetails
  def and_call_original(); end

  def and_raise(*args); end

  def and_return(first_value, *values); end

  def and_throw(*args); end

  def and_wrap_original(&block); end

  def and_yield(*args, &block); end

  def at_least(n, &block); end

  def at_most(n, &block); end

  def exactly(n, &block); end

  def never(); end

  def once(&block); end

  def ordered(&block); end

  def thrice(&block); end

  def time(&block); end

  def times(&block); end

  def twice(&block); end

  def with(*args, &block); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
  def actual_received_count_matters?(); end

  def additional_expected_calls(); end

  def advise(*args); end

  def and_yield_receiver_to_implementation(); end

  def argument_list_matcher=(argument_list_matcher); end

  def called_max_times?(); end

  def description_for(verb); end

  def ensure_expected_ordering_received!(); end

  def error_generator(); end

  def error_generator=(error_generator); end

  def expectation_count_type(); end

  def expected_args(); end

  def expected_from=(expected_from); end

  def expected_messages_received?(); end

  def expected_received_count=(expected_received_count); end

  def generate_error(); end

  def ignoring_args?(); end

  def implementation(); end

  def implementation=(implementation); end

  def increase_actual_received_count!(); end

  def initialize(error_generator, expectation_ordering, expected_from, method_double, type=T.unsafe(nil), opts=T.unsafe(nil), &implementation_block); end

  def invoke(parent_stub, *args, &block); end

  def invoke_without_incrementing_received_count(parent_stub, *args, &block); end

  def matches?(message, *args); end

  def matches_at_least_count?(); end

  def matches_at_most_count?(); end

  def matches_exact_count?(); end

  def matches_name_but_not_args(message, *args); end

  def message(); end

  def negative?(); end

  def negative_expectation_for?(message); end

  def ordered?(); end

  def orig_object(); end

  def raise_out_of_order_error(); end

  def raise_unexpected_message_args_error(args_for_multiple_calls); end

  def safe_invoke(parent_stub, *args, &block); end

  def similar_messages(); end

  def type(); end

  def unadvise(args); end

  def verify_messages_received(); end

  def yield_receiver_to_implementation_block?(); end
end

module RSpec::Mocks::MessageExpectation::ImplementationDetails
end

class RSpec::Mocks::MessageExpectation
end

class RSpec::Mocks::MethodDouble
  include ::T::CompatibilityPatches::RSpecCompatibility::MethodDoubleExtensions
  def add_default_stub(*args, &implementation); end

  def add_expectation(error_generator, expectation_ordering, expected_from, opts, &implementation); end

  def add_simple_expectation(method_name, response, error_generator, backtrace_line); end

  def add_simple_stub(method_name, response); end

  def add_stub(error_generator, expectation_ordering, expected_from, opts=T.unsafe(nil), &implementation); end

  def build_expectation(error_generator, expectation_ordering); end

  def clear(); end

  def configure_method(); end

  def define_proxy_method(); end

  def expectations(); end

  def message_expectation_class(); end

  def method_name(); end

  def method_stasher(); end

  def object(); end

  def object_singleton_class(); end

  def original_implementation_callable(); end

  def original_method(); end

  def proxy_method_invoked(_obj, *args, &block); end

  def raise_method_not_stubbed_error(); end

  def remove_stub(); end

  def remove_stub_if_present(); end

  def reset(); end

  def restore_original_method(); end

  def restore_original_visibility(); end

  def save_original_implementation_callable!(); end

  def setup_simple_method_double(method_name, response, collection, error_generator=T.unsafe(nil), backtrace_line=T.unsafe(nil)); end

  def show_frozen_warning(); end

  def stubs(); end

  def verify(); end

  def visibility(); end
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble::RSpecPrependedModule
end

class RSpec::Mocks::MethodDouble
end

class RSpec::Mocks::MethodReference
  def defined?(); end

  def implemented?(); end

  def initialize(object_reference, method_name); end

  def unimplemented?(); end

  def visibility(); end

  def with_signature(); end
end

class RSpec::Mocks::MethodReference
  def self.for(object_reference, method_name); end

  def self.instance_method_visibility_for(klass, method_name); end

  def self.method_defined_at_any_visibility?(klass, method_name); end

  def self.method_visibility_for(object, method_name); end
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationAlreadyInvokedError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::MockExpectationError
end

class RSpec::Mocks::NamedObjectReference
  def const_to_replace(); end

  def defined?(); end

  def description(); end

  def initialize(const_name); end

  def target(); end

  def when_loaded(); end
end

class RSpec::Mocks::NamedObjectReference
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NegationUnsupportedError
end

class RSpec::Mocks::NestedSpace
  def initialize(parent); end
end

class RSpec::Mocks::NestedSpace
end

class RSpec::Mocks::NoCallbackInvocationStrategy
  def call(_doubled_module); end
end

class RSpec::Mocks::NoCallbackInvocationStrategy
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectMethodReference
end

class RSpec::Mocks::ObjectReference
  MODULE_NAME_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::ObjectReference
  def self.for(object_module_or_name, allow_direct_object_refs=T.unsafe(nil)); end
end

class RSpec::Mocks::ObjectVerifyingDouble
  include ::RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::ObjectVerifyingDouble
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
  include ::RSpec::Mocks::TestDouble
  include ::RSpec::Mocks::VerifyingDouble
  def as_stubbed_const(options=T.unsafe(nil)); end
end

module RSpec::Mocks::ObjectVerifyingDoubleMethods
end

class RSpec::Mocks::OrderGroup
  def clear(); end

  def consume(); end

  def empty?(); end

  def handle_order_constraint(expectation); end

  def invoked(message); end

  def ready_for?(expectation); end

  def register(expectation); end

  def verify_invocation_order(expectation); end
end

class RSpec::Mocks::OrderGroup
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::OutsideOfExampleError
end

class RSpec::Mocks::PartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialClassDoubleProxy
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
  def initialize(source_space, *args); end

  def method_double_from_ancestor_for(message); end

  def original_method_handle_for(message); end

  def original_unbound_method_handle_from_ancestor_for(message); end

  def superclass_proxy(); end
end

module RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::PartialDoubleProxy
  def original_method_handle_for(message); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::PartialDoubleProxy
end

class RSpec::Mocks::Proxy
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_expectation(method_name, response, location); end

  def add_simple_stub(method_name, response); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def build_expectation(method_name); end

  def check_for_unexpected_arguments(expectation); end

  def ensure_implemented(*_args); end

  def has_negative_expectation?(message); end

  def initialize(object, order_group, options=T.unsafe(nil)); end

  def message_received(message, *args, &block); end

  def messages_arg_list(); end

  def method_double_if_exists_for_message(message); end

  def object(); end

  def original_method_handle_for(_message); end

  def prepended_modules_of_singleton_class(); end

  def raise_missing_default_stub_error(expectation, args_for_multiple_calls); end

  def raise_unexpected_message_error(method_name, args); end

  def received_message?(method_name, *args, &block); end

  def record_message_received(message, *args, &block); end

  def remove_stub(method_name); end

  def remove_stub_if_present(method_name); end

  def replay_received_message_on(expectation, &block); end

  def reset(); end

  def verify(); end

  def visibility_for(_method_name); end
  DEFAULT_MESSAGE_EXPECTATION_OPTS = ::T.let(nil, ::T.untyped)
end

class RSpec::Mocks::Proxy::SpecificMessage
  def ==(expectation); end

  def args(); end

  def args=(_); end

  def message(); end

  def message=(_); end

  def object(); end

  def object=(_); end
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Mocks::Proxy
  def self.prepended_modules_of(klass); end
end

class RSpec::Mocks::ProxyForNil
  def disallow_expectations(); end

  def disallow_expectations=(disallow_expectations); end

  def initialize(order_group); end

  def warn_about_expectations(); end

  def warn_about_expectations=(warn_about_expectations); end
end

class RSpec::Mocks::ProxyForNil
end

class RSpec::Mocks::RootSpace
  def any_instance_proxy_for(*_args); end

  def any_instance_recorder_for(*_args); end

  def any_instance_recorders_from_ancestry_of(_object); end

  def new_scope(); end

  def proxy_for(*_args); end

  def register_constant_mutator(_mutator); end

  def registered?(_object); end

  def reset_all(); end

  def superclass_proxy_for(*_args); end

  def verify_all(); end
end

class RSpec::Mocks::RootSpace
end

class RSpec::Mocks::SimpleMessageExpectation
  def called_max_times?(); end

  def initialize(message, response, error_generator, backtrace_line=T.unsafe(nil)); end

  def invoke(*_); end

  def matches?(message, *_); end

  def unadvise(_); end

  def verify_messages_received(); end
end

class RSpec::Mocks::SimpleMessageExpectation
end

class RSpec::Mocks::Space
  def any_instance_mutex(); end

  def any_instance_proxy_for(klass); end

  def any_instance_recorder_for(klass, only_return_existing=T.unsafe(nil)); end

  def any_instance_recorders(); end

  def any_instance_recorders_from_ancestry_of(object); end

  def constant_mutator_for(name); end

  def ensure_registered(object); end

  def new_scope(); end

  def proxies(); end

  def proxies_of(klass); end

  def proxy_for(object); end

  def proxy_mutex(); end

  def register_constant_mutator(mutator); end

  def registered?(object); end

  def reset_all(); end

  def superclass_proxy_for(klass); end

  def verify_all(); end
end

class RSpec::Mocks::Space
end

class RSpec::Mocks::StubChain
end

class RSpec::Mocks::StubChain
  def self.stub_chain_on(object, *chain, &blk); end
end

module RSpec::Mocks::Syntax
end

module RSpec::Mocks::Syntax
  def self.default_should_syntax_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_unless_should_configured(method_name, replacement=T.unsafe(nil)); end
end

class RSpec::Mocks::TargetBase
  include ::RSpec::Mocks::TargetDelegationInstanceMethods
  def initialize(target); end
end

class RSpec::Mocks::TargetBase
  extend ::RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationClassMethods
  def delegate_not_to(matcher_method, options=T.unsafe(nil)); end

  def delegate_to(matcher_method); end

  def disallow_negation(method_name); end
end

module RSpec::Mocks::TargetDelegationClassMethods
end

module RSpec::Mocks::TargetDelegationInstanceMethods
  def target(); end
end

module RSpec::Mocks::TargetDelegationInstanceMethods
end

module RSpec::Mocks::TestDouble
  def ==(other); end

  def __build_mock_proxy_unless_expired(order_group); end

  def __disallow_further_usage!(); end

  def as_null_object(); end

  def freeze(); end

  def initialize(name=T.unsafe(nil), stubs=T.unsafe(nil)); end

  def inspect(); end

  def null_object?(); end

  def respond_to?(message, incl_private=T.unsafe(nil)); end

  def to_s(); end
end

module RSpec::Mocks::TestDouble
end

module RSpec::Mocks::TestDoubleFormatter
end

module RSpec::Mocks::TestDoubleFormatter
  def self.format(dbl, unwrap=T.unsafe(nil)); end
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::TestDoubleProxy
end

class RSpec::Mocks::UnsupportedMatcherError
end

class RSpec::Mocks::UnsupportedMatcherError
end

module RSpec::Mocks::VerifyingDouble
  def __send__(name, *args, &block); end

  def initialize(doubled_module, *args); end

  def method_missing(message, *args, &block); end

  def respond_to?(message, include_private=T.unsafe(nil)); end

  def send(name, *args, &block); end
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble::SilentIO
end

module RSpec::Mocks::VerifyingDouble
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingDoubleNotDefinedError
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingClassNewMethodDouble
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def initialize(object, method_name, proxy); end

  def unimplemented?(); end

  def with_signature(); end
end

class RSpec::Mocks::VerifyingExistingMethodDouble
  def self.for(object, method_name, proxy); end
end

class RSpec::Mocks::VerifyingMessageExpectation
  def initialize(*args); end

  def method_reference(); end

  def method_reference=(method_reference); end
end

class RSpec::Mocks::VerifyingMessageExpectation
end

class RSpec::Mocks::VerifyingMethodDouble
  def add_expectation(*args, &block); end

  def add_stub(*args, &block); end

  def initialize(object, method_name, proxy, method_reference); end

  def proxy_method_invoked(obj, *args, &block); end

  def validate_arguments!(actual_args); end
end

class RSpec::Mocks::VerifyingMethodDouble
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
  include ::RSpec::Mocks::PartialClassDoubleProxyMethods
end

class RSpec::Mocks::VerifyingPartialClassDoubleProxy
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def ensure_implemented(_method_name); end

  def initialize(object, expectation_ordering, optional_callback_invocation_strategy=T.unsafe(nil)); end

  def method_reference(); end
end

class RSpec::Mocks::VerifyingPartialDoubleProxy
end

class RSpec::Mocks::VerifyingProxy
  include ::RSpec::Mocks::VerifyingProxyMethods
  def initialize(object, order_group, doubled_module, method_reference_class); end

  def method_reference(); end

  def validate_arguments!(method_name, args); end

  def visibility_for(method_name); end
end

class RSpec::Mocks::VerifyingProxy
end

module RSpec::Mocks::VerifyingProxyMethods
  def add_message_expectation(method_name, opts=T.unsafe(nil), &block); end

  def add_simple_stub(method_name, *args); end

  def add_stub(method_name, opts=T.unsafe(nil), &implementation); end

  def ensure_implemented(method_name); end

  def ensure_publicly_implemented(method_name, _object); end
end

module RSpec::Mocks::VerifyingProxyMethods
end

module RSpec::Mocks::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Mocks::Version
end

module RSpec::Mocks
  def self.allow_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.configuration(); end

  def self.error_generator(); end

  def self.expect_message(subject, message, opts=T.unsafe(nil), &block); end

  def self.setup(); end

  def self.space(); end

  def self.teardown(); end

  def self.verify(); end

  def self.with_temporary_scope(); end
end

RSpec::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  def self.===(exception); end
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::ComparableVersion
  include ::Comparable
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::ComparableVersion
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::DirectoryMaker
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
end

module RSpec::Support::FuzzyMatcher
  def self.values_match?(expected, actual); end
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureExpectation
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::MethodSignatureVerifier
end

class RSpec::Support::Mutex
  NEW_MUTEX_METHOD = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::Mutex
  def self.new(); end
end

module RSpec::Support::OS
end

module RSpec::Support::OS
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.can_inspect?(_object); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

module RSpec::Support::RecursiveConstMethods
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

class RSpec::Support::ReentrantMutex
end

module RSpec::Support::Ruby
end

module RSpec::Support::Ruby
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end

  def self.truffleruby?(); end
end

module RSpec::Support::RubyFeatures
end

module RSpec::Support::RubyFeatures
  def self.caller_locations_supported?(); end

  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_taint?(); end
end

RSpec::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Version
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::Warnings
end

module RSpec::Support::WithKeywordsWhenNeeded
end

module RSpec::Support::WithKeywordsWhenNeeded
  def self.class_exec(klass, *args, &block); end
end

module RSpec::Support
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Version
end

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.reset(); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::NullPresenter
  def method_missing(method_name, *args); end
end

class Rainbow::Presenter
  def method_missing(method_name, *args); end
end

class Rainbow::StringUtils
  def self.uncolor(string); end
end

module Rainbow
  def self.new(); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rake::AltSystem
  WINDOWS = ::T.let(nil, ::T.untyped)
end

module Rake::AltSystem
  def self.backticks(_); end

  def self.define_module_function(name, &block); end
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(); end

  def run_with_threads(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output_state); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
  FIXNUM_MAX = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def excluded_from_list?(fn); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil)); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, &block); end

  def chdir(*args, &block); end

  def chmod(*args, &block); end

  def chmod_R(*args, &block); end

  def chown(*args, &block); end

  def chown_R(*args, &block); end

  def copy(*args, &block); end

  def cp(*args, &block); end

  def cp_lr(*args, &block); end

  def cp_r(*args, &block); end

  def install(*args, &block); end

  def link(*args, &block); end

  def ln(*args, &block); end

  def ln_s(*args, &block); end

  def ln_sf(*args, &block); end

  def makedirs(*args, &block); end

  def mkdir(*args, &block); end

  def mkdir_p(*args, &block); end

  def mkpath(*args, &block); end

  def move(*args, &block); end

  def mv(*args, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_merge_option(args, defaults); end

  def rake_output_message(message); end

  def remove(*args, &block); end

  def rm(*args, &block); end

  def rm_f(*args, &block); end

  def rm_r(*args, &block); end

  def rm_rf(*args, &block); end

  def rmdir(*args, &block); end

  def rmtree(*args, &block); end

  def ruby(*args, &block); end

  def safe_unlink(*args, &block); end

  def sh(*args, &block); end

  def symlink(*args, &block); end

  def touch(*args, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(&blk); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
end

module Rake::PrivateReader
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_comment(); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  def self.normalize(path); end

  def self.rake_system(*cmd); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end
end

RakeFileUtils = Rake::FileUtilsExt

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  def self.completion_quote_character(); end
end

class Regexp
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

module Regexp::Expression
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

class Regexp::Expression::Alternation
end

class Regexp::Expression::Alternative
end

class Regexp::Expression::Alternative
end

module Regexp::Expression::Anchor
end

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
  def match_length(); end
end

class Regexp::Expression::Anchor::Base
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfString
end

class Regexp::Expression::Anchor::BeginningOfString
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

module Regexp::Expression::Anchor
end

module Regexp::Expression::Assertion
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

module Regexp::Expression::Assertion
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Backreference::Base
  def match_length(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Backreference::Base
end

class Regexp::Expression::Backreference::Name
  def name(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Name
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
end

class Regexp::Expression::Backreference::Number
  def number(); end

  def reference(); end
end

class Regexp::Expression::Backreference::Number
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
end

class Regexp::Expression::Backreference::NumberRelative
  def effective_number(); end

  def effective_number=(effective_number); end
end

class Regexp::Expression::Backreference::NumberRelative
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Base
  def =~(string, offset=T.unsafe(nil)); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def case_insensitive?(); end

  def coded_offset(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def full_length(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset=T.unsafe(nil)); end

  def match?(string); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def nesting_level=(nesting_level); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def possessive?(); end

  def quantified?(); end

  def quantifier(); end

  def quantifier=(quantifier); end

  def quantifier_affix(expression_format); end

  def quantify(token, text, min=T.unsafe(nil), max=T.unsafe(nil), mode=T.unsafe(nil)); end

  def quantity(); end

  def reluctant?(); end

  def repetitions(); end

  def set_level(); end

  def set_level=(set_level); end

  def starts_at(); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def terminal?(); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def type?(test_type); end

  def u?(); end

  def unicode_classes?(); end

  def unquantified_clone(); end

  def x?(); end
end

class Regexp::Expression::Base
end

class Regexp::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negated?(); end

  def negative(); end

  def negative=(negative); end

  def negative?(); end
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::Intersection
end

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Intersection
end

class Regexp::Expression::CharacterSet::Range
  def complete?(); end

  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::CharacterSet::Range
end

class Regexp::Expression::CharacterSet
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Base
  def match_length(); end
end

class Regexp::Expression::CharacterType::Base
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Word
end

class Regexp::Expression::CharacterType::Word
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::Comment
end

class Regexp::Expression::Comment
end

module Regexp::Expression::Conditional
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Condition
  def match_length(); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Condition
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(active_opts=T.unsafe(nil)); end

  def branch(active_opts=T.unsafe(nil)); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end

  def referenced_expression(); end

  def referenced_expression=(referenced_expression); end
end

class Regexp::Expression::Conditional::Expression
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

class Regexp::Expression::Conditional::TooManyBranches
end

module Regexp::Expression::Conditional
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def codepoint(); end

  def match_length(); end
end

class Regexp::Expression::EscapeSequence::Base
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoints(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::FreeSpace
  def match_length(); end
end

class Regexp::Expression::FreeSpace
end

module Regexp::Expression::Group
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Base
  def capturing?(); end

  def comment?(); end
end

class Regexp::Expression::Group::Base
end

class Regexp::Expression::Group::Capture
  def identifier(); end

  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Capture
end

class Regexp::Expression::Group::Comment
  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::Group::Comment
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Named
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Options
end

class Regexp::Expression::Group::Passive
end

class Regexp::Expression::Group::Passive
end

module Regexp::Expression::Group
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Keep::Mark
  def match_length(); end
end

class Regexp::Expression::Keep::Mark
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Literal
  def match_length(); end
end

class Regexp::Expression::Literal
end

Regexp::Expression::MatchLength = Regexp::MatchLength

class Regexp::Expression::PosixClass
  def match_length(); end

  def name(); end

  def negative?(); end
end

class Regexp::Expression::PosixClass
end

class Regexp::Expression::Quantifier
  def greedy?(); end

  def initialize(token, text, min, max, mode); end

  def lazy?(); end

  def max(); end

  def min(); end

  def mode(); end

  def possessive?(); end

  def reluctant?(); end

  def text(); end

  def to_h(); end

  def to_str(); end

  def token(); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Quantifier
end

class Regexp::Expression::Root
  def initialize(*args); end
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end

  def self.build_token(); end
end

class Regexp::Expression::Sequence
  def initialize(*args); end
end

class Regexp::Expression::Sequence
  def self.add_to(subexpression, params=T.unsafe(nil), active_opts=T.unsafe(nil)); end

  def self.at_levels(level, set_level, conditional_level); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(active_opts=T.unsafe(nil)); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::SequenceOperation
end

class Regexp::Expression::Subexpression
  include ::Enumerable
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil), &block); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil), &block); end

  def index(*args, &block); end

  def inner_match_length(); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def match_length(); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def te(); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::Subexpression
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Base
  def match_length(); end

  def name(); end

  def negative?(); end

  def shortcut(); end
end

class Regexp::Expression::UnicodeProperty::Base
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Graph
end

class Regexp::Expression::UnicodeProperty::Graph
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Lower
end

class Regexp::Expression::UnicodeProperty::Lower
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Newline
end

class Regexp::Expression::UnicodeProperty::Newline
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Punct
end

class Regexp::Expression::UnicodeProperty::Punct
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Script
end

class Regexp::Expression::UnicodeProperty::Script
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Space
end

class Regexp::Expression::UnicodeProperty::Space
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Expression::WhiteSpace
end

module Regexp::Expression
  def self.parsed(exp); end
end

class Regexp::Lexer
  def lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::MatchLength
  include ::Enumerable
  def each(opts=T.unsafe(nil), &blk); end

  def endless_each(&block); end

  def fixed?(); end

  def include?(length); end

  def initialize(exp, opts=T.unsafe(nil)); end

  def max(); end

  def min(); end

  def to_re(); end
end

class Regexp::MatchLength
  def self.of(obj); end
end

class Regexp::Parser
  include ::Regexp::Expression
  include ::Regexp::Syntax
  include ::Regexp::Expression::UnicodeProperty
  def parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
  ENC_FLAGS = ::T.let(nil, ::T.untyped)
  MOD_FLAGS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenError
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), options: T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def emit(type, token, text, ts, te); end

  def scan(input_object, options: T.unsafe(nil), &block); end
  PROP_MAPS_DIR = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidBackrefError
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidGroupOption
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::InvalidSequenceError
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
end

class Regexp::Scanner::ValidationError
  def initialize(reason); end
end

class Regexp::Scanner::ValidationError
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.scan(input_object, options: T.unsafe(nil), &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token
  def check!(type, token); end

  def check?(type, token); end

  def excludes(type, tokens); end

  def features(); end

  def implementations(type); end

  def implements(type, tokens); end

  def implements!(type, token); end

  def implements?(type, token); end

  def normalize(type, token); end

  def normalize_backref(type, token); end

  def normalize_group(type, token); end
end

class Regexp::Syntax::Base
end

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::InvalidVersionNameError
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

class Regexp::Syntax::NotImplementedError
end

class Regexp::Syntax::SyntaxError
end

class Regexp::Syntax::SyntaxError
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_0 = ::T.let(nil, ::T.untyped)
  Age_V2_6_2 = ::T.let(nil, ::T.untyped)
  Age_V2_6_3 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_0 = ::T.let(nil, ::T.untyped)
  Script_V2_6_2 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_6_2 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
  V2_6_0 = ::T.let(nil, ::T.untyped)
  V2_6_2 = ::T.let(nil, ::T.untyped)
  V2_6_3 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
end

module Regexp::Syntax::Token::UnicodeProperty
end

module Regexp::Syntax::Token
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

class Regexp::Syntax::UnknownSyntaxNameError
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_5
end

class Regexp::Syntax::V2_5
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_0
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_2
end

class Regexp::Syntax::V2_6_3
end

class Regexp::Syntax::V2_6_3
end

module Regexp::Syntax
  def self.comparable_version(name); end

  def self.const_missing(const_name); end

  def self.fallback_version_class(version); end

  def self.inherit_from_version(parent_version, new_version); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end

  def self.version_const_name(version_string); end

  def self.warn_if_future_version(const_name); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(_); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*_); end

  def self.members(); end
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def getname(address); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def initialize(config_info=T.unsafe(nil)); end
end

class Resolv::DNS::Label::Str
  def initialize(string); end
end

class Resolv::DNS::Message
  def initialize(id=T.unsafe(nil)); end
end

class Resolv::DNS::Message::MessageDecoder
  def initialize(data); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def lazy_initialize(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def initialize(msg, data, sock, host, port); end
end

class Resolv::DNS::Resource
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::LOC
  def initialize(version, ssize, hprecision, vprecision, latitude, longitude, altitude); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end
end

module RuboCop::AST
end

class RuboCop::AST::AliasNode
  def new_identifier(); end

  def old_identifier(); end
end

class RuboCop::AST::AliasNode
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def each_value(&block); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
end

class RuboCop::AST::BlockNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::BreakNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::BreakNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseMatchNode
  include ::RuboCop::AST::ConditionalNode
  def each_in_pattern(&block); end

  def else?(); end

  def else_branch(); end

  def in_pattern_branches(); end

  def keyword(); end
end

class RuboCop::AST::CaseMatchNode
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def branches(); end

  def each_when(&block); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

class RuboCop::AST::ClassNode
  def body(); end

  def identifier(); end

  def parent_class(); end
end

class RuboCop::AST::ClassNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_ary(*args, &block); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
end

class RuboCop::AST::ConstNode
  def absolute?(); end

  def class_name?(); end

  def each_path(&block); end

  def module_name?(); end

  def namespace(); end

  def relative?(); end

  def short_name(); end
end

class RuboCop::AST::ConstNode
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def argument_forwarding?(); end

  def arguments(); end

  def body(); end

  def endless?(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::DefinedNode
end

module RuboCop::AST::Descendence
  def child_nodes(); end

  def descendants(); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def visit_descendants(types, &block); end
end

module RuboCop::AST::Descendence
end

class RuboCop::AST::EnsureNode
  def body(); end
end

class RuboCop::AST::EnsureNode
end

module RuboCop::AST::Ext
end

module RuboCop::AST::Ext::Range
  def line_span(exclude_end: T.unsafe(nil)); end
end

module RuboCop::AST::Ext::Range
end

module RuboCop::AST::Ext
end

class RuboCop::AST::FloatNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::FloatNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

class RuboCop::AST::ForwardArgsNode
  include ::RuboCop::AST::CollectionNode
end

class RuboCop::AST::ForwardArgsNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(&block); end

  def each_pair(); end

  def each_value(&block); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def branches(); end

  def each_branch(&block); end

  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::IndexNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexNode
end

class RuboCop::AST::IndexasgnNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::IndexasgnNode
end

class RuboCop::AST::IntNode
  include ::RuboCop::AST::BasicLiteralNode
  include ::RuboCop::AST::NumericNode
end

class RuboCop::AST::IntNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
end

class RuboCop::AST::KeywordSplatNode
end

class RuboCop::AST::LambdaNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(); end
end

class RuboCop::AST::LambdaNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(param0=T.unsafe(nil)); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def binary_operation?(); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def in_macro_scope?(param0=T.unsafe(nil)); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(param0=T.unsafe(nil)); end

  def receiver(); end

  def safe_navigation?(); end

  def self_receiver?(); end

  def setter_method?(); end

  def special_modifier?(); end

  def unary_operation?(); end
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerable_method?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def nonmutating_array_method?(); end

  def nonmutating_binary_operator_method?(); end

  def nonmutating_hash_method?(); end

  def nonmutating_operator_method?(); end

  def nonmutating_string_method?(); end

  def nonmutating_unary_operator_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
end

module RuboCop::AST::MethodIdentifierPredicates
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
end

class RuboCop::AST::ModuleNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::ModuleNode
end

class RuboCop::AST::NextNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::NextNode
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  include ::RuboCop::AST::Descendence
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def argument_type?(); end

  def array_pattern_type?(); end

  def array_pattern_with_tail_type?(); end

  def array_type?(); end

  def assignment?(); end

  def assignment_or_similar?(param0=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_conditional?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_expr_type?(); end

  def blockarg_type?(); end

  def boolean_type?(); end

  def break_type?(); end

  def call_type?(); end

  def case_match_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def class_constructor?(param0=T.unsafe(nil)); end

  def class_definition?(param0=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def conditional?(); end

  def const_name(); end

  def const_pattern_type?(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def eflipflop_type?(); end

  def empty_else_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def find_pattern_type?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def forward_arg_type?(); end

  def forward_args_type?(); end

  def forwarded_args_type?(); end

  def global_const?(param0=T.unsafe(nil), param1); end

  def guard_clause?(); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_pattern_type?(); end

  def hash_type?(); end

  def ident_type?(); end

  def if_guard_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def in_match_type?(); end

  def in_pattern_type?(); end

  def index_type?(); end

  def indexasgn_type?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwnilarg_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(param0=T.unsafe(nil)); end

  def lambda_or_proc?(param0=T.unsafe(nil)); end

  def lambda_type?(); end

  def last_line(); end

  def left_sibling(); end

  def left_siblings(); end

  def line_count(); end

  def literal?(); end

  def loop_keyword?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_alt_type?(); end

  def match_as_type?(); end

  def match_current_line_type?(); end

  def match_guard_clause?(param0=T.unsafe(nil)); end

  def match_nil_pattern_type?(); end

  def match_rest_type?(); end

  def match_var_type?(); end

  def match_with_lvasgn_type?(); end

  def match_with_trailing_comma_type?(); end

  def mlhs_type?(); end

  def module_definition?(param0=T.unsafe(nil)); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(param0=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numargs_type?(); end

  def numblock_type?(); end

  def numeric_type?(); end

  def objc_kwarg_type?(); end

  def objc_restarg_type?(); end

  def objc_varargs_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent?(); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def pin_type?(); end

  def post_condition_loop?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(param0=T.unsafe(nil)); end

  def procarg0_type?(); end

  def pure?(); end

  def range_type?(); end

  def rational_type?(); end

  def receiver(param0=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_expr_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def right_sibling(); end

  def right_siblings(); end

  def root?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(param0=T.unsafe(nil)); end

  def str_type?(); end

  def struct_constructor?(param0=T.unsafe(nil)); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def undef_type?(); end

  def unless_guard_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  ARGUMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  BASIC_CONDITIONALS = ::T.let(nil, ::T.untyped)
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  CONDITIONALS = ::T.let(nil, ::T.untyped)
  EQUALS_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASSIGNMENTS = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::AST::NodePattern
  include ::RuboCop::AST::NodePattern::MethodDefiner
  def ==(other); end

  def as_json(_options=T.unsafe(nil)); end

  def ast(); end

  def captures(*args, &block); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def initialize(str, compiler: T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(pattern); end

  def match(*args, **rest, &block); end

  def match_code(); end

  def named_parameters(*args, &block); end

  def pattern(); end

  def positional_parameters(*args, &block); end
  VAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Builder
  def emit_atom(type, value); end

  def emit_call(type, selector, args=T.unsafe(nil)); end

  def emit_capture(capture_token, node); end

  def emit_list(type, _begin, children, _end); end

  def emit_subsequence(node_list); end

  def emit_unary_op(type, _operator=T.unsafe(nil), *children); end

  def emit_union(begin_t, pattern_lists, end_t); end
end

class RuboCop::AST::NodePattern::Builder
end

class RuboCop::AST::NodePattern::Comment
  def ==(other); end

  def initialize(range); end

  def loc(); end

  def location(); end

  def text(); end
end

class RuboCop::AST::NodePattern::Comment
end

class RuboCop::AST::NodePattern::Compiler
  def bind(*args, &block); end

  def captures(); end

  def compile_as_atom(node); end

  def compile_as_node_pattern(node, **options); end

  def compile_sequence(sequence, var:); end

  def each_union(enum, &block); end

  def named_parameter(name); end

  def named_parameters(); end

  def next_capture(); end

  def parser(); end

  def positional_parameter(number); end

  def positional_parameters(); end

  def with_temp_variables(*names, &block); end
end

class RuboCop::AST::NodePattern::Compiler::AtomSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::AtomSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Binding
  def bind(name); end

  def union_bind(enum); end
end

class RuboCop::AST::NodePattern::Compiler::Binding
end

class RuboCop::AST::NodePattern::Compiler::Debug
  def comments(*args, &block); end

  def node_ids(); end

  def tokens(*args, &block); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
  def compiler(); end

  def initialize(pattern, compiler: T.unsafe(nil)); end

  def node_pattern(); end

  def pattern(); end

  def test(ruby, trace: T.unsafe(nil)); end
  COLOR_SCHEME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def color_map(color_scheme=T.unsafe(nil)); end

  def colorize(color_scheme=T.unsafe(nil)); end

  def colorizer(); end

  def colorizer=(_); end

  def match_map(); end

  def matched?(node); end

  def returned(); end

  def returned=(_); end

  def ruby_ast(); end

  def ruby_ast=(_); end

  def trace(); end

  def trace=(_); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer::Result
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Colorizer
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
  def do_compile(); end
end

module RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
  include ::RuboCop::AST::NodePattern::Compiler::Debug::InstrumentationSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
  def enter(node_id); end

  def matched?(node_id); end

  def success(node_id); end
end

class RuboCop::AST::NodePattern::Compiler::Debug::Trace
end

class RuboCop::AST::NodePattern::Compiler::Debug
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
  def access(); end

  def initialize(compiler, var: T.unsafe(nil), access: T.unsafe(nil), seq_head: T.unsafe(nil)); end

  def seq_head(); end
end

class RuboCop::AST::NodePattern::Compiler::NodePatternSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
  def compile_sequence(); end

  def compile_terms(children=T.unsafe(nil), last_arity=T.unsafe(nil)); end

  def cur_index(); end

  def in_sync(); end

  def initialize(compiler, sequence:, var:); end

  def sync(); end
  DELTA = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Compiler::SequenceSubcompiler
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def compile(node); end

  def compiler(); end

  def initialize(compiler); end
end

class RuboCop::AST::NodePattern::Compiler::Subcompiler
  def self.inherited(base); end

  def self.method_added(method); end

  def self.registry(); end
end

class RuboCop::AST::NodePattern::Compiler
  extend ::Forwardable
end

class RuboCop::AST::NodePattern::Invalid
end

class RuboCop::AST::NodePattern::Invalid
end

class RuboCop::AST::NodePattern::Lexer
  def comments(); end

  def initialize(source); end

  def source_buffer(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern::LexerRex
  def action(); end

  def filename(); end

  def filename=(filename); end

  def location(); end

  def match(); end

  def matches(); end

  def next_token(); end

  def parse(str); end

  def parse_file(path); end

  def scanner_class(); end

  def ss(); end

  def ss=(ss); end

  def state(); end

  def state=(state); end
  CALL = ::T.let(nil, ::T.untyped)
  CONST_NAME = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  REGEXP_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::LexerRex::LexerError
end

class RuboCop::AST::NodePattern::LexerRex::LexerError
end

class RuboCop::AST::NodePattern::LexerRex::ScanError
end

class RuboCop::AST::NodePattern::LexerRex::ScanError
end

class RuboCop::AST::NodePattern::LexerRex
end

module RuboCop::AST::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str, **keyword_defaults); end

  def def_node_search(method_name, pattern_str, **keyword_defaults); end
end

module RuboCop::AST::NodePattern::Macros
end

module RuboCop::AST::NodePattern::MethodDefiner
  def as_lambda(); end

  def compile_as_lambda(); end

  def def_node_matcher(base, method_name, **defaults); end

  def def_node_search(base, method_name, **defaults); end
end

module RuboCop::AST::NodePattern::MethodDefiner
end

class RuboCop::AST::NodePattern::Node
  include ::RuboCop::AST::Descendence
  def arity(); end

  def arity_range(); end

  def capture?(); end

  def child(); end

  def children_nodes(); end

  def in_sequence_head(); end

  def matches_within_set?(); end

  def nb_captures(); end

  def rest?(); end

  def variadic?(); end

  def with(type: T.unsafe(nil), children: T.unsafe(nil), location: T.unsafe(nil)); end
  MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::AnyOrder
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def ends_with_rest?(); end

  def rest_node(); end

  def term_nodes(); end
end

class RuboCop::AST::NodePattern::Node::AnyOrder
end

class RuboCop::AST::NodePattern::Node::Capture
  def arity(*args, &block); end

  def rest?(*args, &block); end
end

class RuboCop::AST::NodePattern::Node::Capture
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def in_sequence_head(); end
end

module RuboCop::AST::NodePattern::Node::ForbidInSeqHead
end

module RuboCop::AST::NodePattern::Node::MapMinMax
  def map_min_max(enum); end
end

module RuboCop::AST::NodePattern::Node::MapMinMax
end

class RuboCop::AST::NodePattern::Node::Predicate
  def arg_list(); end

  def method_name(); end
end

class RuboCop::AST::NodePattern::Node::Predicate
end

class RuboCop::AST::NodePattern::Node::Repetition
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  def operator(); end
  ARITIES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Node::Repetition
end

class RuboCop::AST::NodePattern::Node::Rest
end

class RuboCop::AST::NodePattern::Node::Rest
end

class RuboCop::AST::NodePattern::Node::Sequence
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
end

class RuboCop::AST::NodePattern::Node::Sequence
end

class RuboCop::AST::NodePattern::Node::Subsequence
  include ::RuboCop::AST::NodePattern::Node::ForbidInSeqHead
  include ::RuboCop::AST::NodePattern::Node::MapMinMax
end

class RuboCop::AST::NodePattern::Node::Subsequence
end

class RuboCop::AST::NodePattern::Node::Union
  include ::RuboCop::AST::NodePattern::Node::MapMinMax
end

class RuboCop::AST::NodePattern::Node::Union
end

class RuboCop::AST::NodePattern::Node
  extend ::Forwardable
end

class RuboCop::AST::NodePattern::Parser
  def _reduce_10(val, _values); end

  def _reduce_11(val, _values); end

  def _reduce_13(val, _values); end

  def _reduce_14(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_19(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_20(val, _values); end

  def _reduce_21(val, _values); end

  def _reduce_22(val, _values); end

  def _reduce_25(val, _values); end

  def _reduce_26(val, _values); end

  def _reduce_3(val, _values); end

  def _reduce_33(val, _values); end

  def _reduce_37(val, _values); end

  def _reduce_38(val, _values); end

  def _reduce_39(val, _values); end

  def _reduce_4(val, _values); end

  def _reduce_40(val, _values); end

  def _reduce_41(val, _values); end

  def _reduce_42(val, _values); end

  def _reduce_43(val, _values); end

  def _reduce_44(val, _values); end

  def _reduce_45(val, _values); end

  def _reduce_46(val, _values); end

  def _reduce_5(val, _values); end

  def _reduce_6(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def emit_atom(*args, &block); end

  def emit_call(*args, &block); end

  def emit_capture(*args, &block); end

  def emit_list(*args, &block); end

  def emit_unary_op(*args, &block); end

  def emit_union(*args, &block); end

  def initialize(builder=T.unsafe(nil)); end

  def next_token(*args, &block); end

  def parse(source); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::NodePattern::Parser::WithMeta
  def comments(); end

  def tokens(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
  def emit_atom(type, token); end

  def emit_call(type, selector_t, args=T.unsafe(nil)); end

  def emit_list(type, begin_t, children, end_t); end

  def emit_unary_op(type, operator_t=T.unsafe(nil), *children); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Builder
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
  def initialize(str_or_buffer); end

  def pos(); end
end

class RuboCop::AST::NodePattern::Parser::WithMeta::Lexer
end

class RuboCop::AST::NodePattern::Parser::WithMeta
end

class RuboCop::AST::NodePattern::Parser
  extend ::Forwardable
end

module RuboCop::AST::NodePattern::Sets
  MAX = ::T.let(nil, ::T.untyped)
  REGISTRY = ::T.let(nil, ::T.untyped)
  SET_0_1 = ::T.let(nil, ::T.untyped)
  SET_10_10 = ::T.let(nil, ::T.untyped)
  SET_1_1 = ::T.let(nil, ::T.untyped)
  SET_ABSTRACT_OVERRIDE_OVERRIDABLE_ETC = ::T.let(nil, ::T.untyped)
  SET_ADD_DEPENDENCY_ADD_RUNTIME_DEPENDENCY_ADD_DEVELOPMENT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  SET_ANY_ALL_NORETURN_ETC = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR = ::T.let(nil, ::T.untyped)
  SET_ATTR_READER_ATTR_WRITER_ATTR_ACCESSOR_ATTR = ::T.let(nil, ::T.untyped)
  SET_CAPTURE2_CAPTURE2E_CAPTURE3_ETC = ::T.let(nil, ::T.untyped)
  SET_CIPHER_DIGEST = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_INSTANCE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE = ::T.let(nil, ::T.untyped)
  SET_CLASS_MODULE_STRUCT = ::T.let(nil, ::T.untyped)
  SET_CONSTANTIZE_CONSTANTS_CONST_GET = ::T.let(nil, ::T.untyped)
  SET_COUNT_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_DEBUGGER_BYEBUG_REMOTE_BYEBUG = ::T.let(nil, ::T.untyped)
  SET_DEFINE_METHOD_DEFINE_SINGLETON_METHOD = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_INDEX_WITH_INDEX = ::T.let(nil, ::T.untyped)
  SET_EACH_WITH_OBJECT_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  SET_ENUMERATOR_RATIONAL_COMPLEX_THREAD = ::T.let(nil, ::T.untyped)
  SET_ESCAPE_ENCODE_UNESCAPE_DECODE = ::T.let(nil, ::T.untyped)
  SET_FIRST_LAST__ETC = ::T.let(nil, ::T.untyped)
  SET_FIXNUM_BIGNUM = ::T.let(nil, ::T.untyped)
  SET_FORMAT_SPRINTF_PRINTF = ::T.let(nil, ::T.untyped)
  SET_GEMCUTTER_RUBYGEMS_RUBYFORGE = ::T.let(nil, ::T.untyped)
  SET_GSUB_GSUB = ::T.let(nil, ::T.untyped)
  SET_INCLUDE_EXTEND_PREPEND = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EVAL_CLASS_EVAL_MODULE_EVAL = ::T.let(nil, ::T.untyped)
  SET_INSTANCE_EXEC_CLASS_EXEC_MODULE_EXEC = ::T.let(nil, ::T.untyped)
  SET_KEYS_VALUES = ::T.let(nil, ::T.untyped)
  SET_KEY_HAS_KEY_FETCH_ETC = ::T.let(nil, ::T.untyped)
  SET_LAST_FIRST = ::T.let(nil, ::T.untyped)
  SET_LENGTH_SIZE = ::T.let(nil, ::T.untyped)
  SET_LOAD_RESTORE = ::T.let(nil, ::T.untyped)
  SET_MAP_COLLECT = ::T.let(nil, ::T.untyped)
  SET_NEW_OPEN = ::T.let(nil, ::T.untyped)
  SET_NIL_ = ::T.let(nil, ::T.untyped)
  SET_PIPELINE_PIPELINE_R_PIPELINE_RW_ETC = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED = ::T.let(nil, ::T.untyped)
  SET_PRIVATE_PROTECTED_PUBLIC = ::T.let(nil, ::T.untyped)
  SET_PROP_CONST = ::T.let(nil, ::T.untyped)
  SET_PRY_REMOTE_PRY_PRY_REMOTE_CONSOLE = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_CONSTANT_PRIVATE_CONSTANT = ::T.let(nil, ::T.untyped)
  SET_PUBLIC_PROTECTED_PRIVATE_MODULE_FUNCTION = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL = ::T.let(nil, ::T.untyped)
  SET_RAISE_FAIL_THROW_ETC = ::T.let(nil, ::T.untyped)
  SET_REDUCE_INJECT = ::T.let(nil, ::T.untyped)
  SET_REQUIRE_REQUIRE_RELATIVE = ::T.let(nil, ::T.untyped)
  SET_SAVE_AND_OPEN_PAGE_SAVE_AND_OPEN_SCREENSHOT_SAVE_SCREENSHOT = ::T.let(nil, ::T.untyped)
  SET_SEND_PUBLIC_SEND___SEND__ = ::T.let(nil, ::T.untyped)
  SET_SORT_BY_SORT = ::T.let(nil, ::T.untyped)
  SET_SPAWN_SYSTEM = ::T.let(nil, ::T.untyped)
  SET_SPRINTF_FORMAT = ::T.let(nil, ::T.untyped)
  SET_STRUCT_CLASS = ::T.let(nil, ::T.untyped)
  SET_SUCC_PRED_NEXT = ::T.let(nil, ::T.untyped)
  SET_TEMPFILE_STRINGIO = ::T.let(nil, ::T.untyped)
  SET_TIME_DATETIME = ::T.let(nil, ::T.untyped)
  SET_TO_I_TO_F_TO_C = ::T.let(nil, ::T.untyped)
  SET_TRUE_FALSE = ::T.let(nil, ::T.untyped)
  SET_TYPE_TEMPLATE_TYPE_MEMBER = ::T.let(nil, ::T.untyped)
  SET_ZERO_POSITIVE_NEGATIVE = ::T.let(nil, ::T.untyped)
  SET__ = ::T.let(nil, ::T.untyped)
  SET__AT_SLICE = ::T.let(nil, ::T.untyped)
  SET__EQUAL_EQL = ::T.let(nil, ::T.untyped)
  SET__GLOB = ::T.let(nil, ::T.untyped)
  SET___ = ::T.let(nil, ::T.untyped)
  SET___2 = ::T.let(nil, ::T.untyped)
  SET___3 = ::T.let(nil, ::T.untyped)
  SET___4 = ::T.let(nil, ::T.untyped)
  SET___5 = ::T.let(nil, ::T.untyped)
  SET___6 = ::T.let(nil, ::T.untyped)
  SET____ = ::T.let(nil, ::T.untyped)
  SET____ETC = ::T.let(nil, ::T.untyped)
  SET____ETC_2 = ::T.let(nil, ::T.untyped)
  SET____ETC_3 = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::NodePattern::Sets
  def self.[](set); end

  def self.name(set); end

  def self.uniq(name); end
end

class RuboCop::AST::NodePattern
  extend ::Forwardable
  def self.descend(element, &block); end
end

module RuboCop::AST::NumericNode
  def sign?(); end
end

module RuboCop::AST::NumericNode
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(*deprecated, with_spacing: T.unsafe(nil)); end

  def value_on_new_line?(); end
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  def arguments(); end

  def arguments?(); end

  def first_argument(); end

  def last_argument(); end
end

module RuboCop::AST::ParameterizedNode::RestArguments
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
  def arguments(); end
end

module RuboCop::AST::ParameterizedNode::WrappedArguments
end

module RuboCop::AST::ParameterizedNode
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
end

module RuboCop::AST::PredicateOperatorNode
end

class RuboCop::AST::ProcessedSource
  include ::RuboCop::Ext::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def blank?(); end

  def buffer(); end

  def checksum(); end

  def comment_at_line(line); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def contains_comment?(source_range); end

  def current_line(token); end

  def diagnostics(); end

  def each_comment(&block); end

  def each_comment_in_lines(line_range); end

  def each_token(&block); end

  def file_path(); end

  def find_comment(&block); end

  def find_token(&block); end

  def first_token_of(range_or_node); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def last_token_of(range_or_node); end

  def line_indentation(line_number); end

  def line_with_comment?(line); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def start_with?(string); end

  def tokens(); end

  def tokens_within(range_or_node); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ProcessedSource
  def self.from_file(path, ruby_version); end
end

class RuboCop::AST::RangeNode
  def begin(); end

  def end(); end
end

class RuboCop::AST::RangeNode
end

class RuboCop::AST::RegexpNode
  include ::RuboCop::Ext::RegexpNode
  def content(); end

  def delimiter?(char); end

  def delimiters(); end

  def extended?(); end

  def ignore_case?(); end

  def interpolation?(); end

  def multiline_mode?(); end

  def no_encoding?(); end

  def options(); end

  def percent_r_literal?(); end

  def regopt(); end

  def single_interpolation?(); end

  def slash_literal?(); end

  def to_regexp(); end
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end

  def branch_index(); end

  def exception_variable(); end

  def exceptions(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::RescueNode
  def body(); end

  def branches(); end

  def else?(); end

  def else_branch(); end

  def resbody_branches(); end
end

class RuboCop::AST::RescueNode
end

class RuboCop::AST::ReturnNode
  include ::RuboCop::AST::ParameterizedNode::WrappedArguments
  include ::RuboCop::AST::ParameterizedNode
end

class RuboCop::AST::ReturnNode
end

module RuboCop::AST::RuboCopCompatibility
  def rubocop_loaded(); end
  INCOMPATIBLE_COPS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::RuboCopCompatibility
end

class RuboCop::AST::SelfClassNode
  def body(); end

  def identifier(); end
end

class RuboCop::AST::SelfClassNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode::RestArguments
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def attribute_accessor?(param0=T.unsafe(nil)); end
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

class RuboCop::AST::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::AST::Token
  def self.from_parser_token(parser_token); end
end

module RuboCop::AST::Traversal
  def on_(node); end

  def on___ENCODING__(node); end

  def on___FILE__(node); end

  def on___LINE__(node); end

  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_array_pattern(node); end

  def on_array_pattern_with_tail(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_const_pattern(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_empty_else(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_find_pattern(node); end

  def on_float(node); end

  def on_for(node); end

  def on_forward_arg(node); end

  def on_forward_args(node); end

  def on_forwarded_args(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_hash_pattern(node); end

  def on_if(node); end

  def on_if_guard(node); end

  def on_iflipflop(node); end

  def on_in_match(node); end

  def on_in_pattern(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwnilarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_alt(node); end

  def on_match_as(node); end

  def on_match_current_line(node); end

  def on_match_nil_pattern(node); end

  def on_match_rest(node); end

  def on_match_var(node); end

  def on_match_with_lvasgn(node); end

  def on_match_with_trailing_comma(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_mrasgn(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_numblock(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_pin(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_rasgn(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_unless_guard(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  TYPE_TO_METHOD = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Traversal::DebugError
end

class RuboCop::AST::Traversal::DebugError
end

module RuboCop::AST::Traversal
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

module RuboCop::AST::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Version
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(&block); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
  extend ::RuboCop::AST::RuboCopCompatibility
end

class RuboCop::CLI
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end
end

class RuboCop::CLI::Command::AutoGenerateConfig
  def run(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::Base
  def env(); end

  def initialize(env); end
end

class RuboCop::CLI::Command::Base
  def self.by_command_name(name); end

  def self.command_name(); end

  def self.command_name=(command_name); end

  def self.inherited(subclass); end
end

class RuboCop::CLI::Command::ExecuteRunner
  include ::RuboCop::Formatter::TextUtil
  def run(); end
  INTEGRATION_FORMATTERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Command::ExecuteRunner
end

class RuboCop::CLI::Command::InitDotfile
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
  def run(); end
end

class RuboCop::CLI::Command::ShowCops
end

class RuboCop::CLI::Command::Version
  def run(); end
end

class RuboCop::CLI::Command::Version
end

module RuboCop::CLI::Command
  def self.run(env, name); end
end

class RuboCop::CLI::Environment
  def config_store(); end

  def initialize(options, config_store, paths); end

  def options(); end

  def paths(); end

  def run(name); end
end

class RuboCop::CLI::Environment
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](*args, &block); end

  def []=(*args, &block); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def bundler_lock_file_path(); end

  def check(); end

  def delete(*args, &block); end

  def deprecation_check(); end

  def disabled_new_cops?(); end

  def each(*args, &block); end

  def each_key(*args, &block); end

  def enabled_new_cops?(); end

  def fetch(*args, &block); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_badge(badge); end

  def for_cop(cop); end

  def for_department(department_name); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def internal?(); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(*args, &block); end

  def merge(*args, &block); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def pending_cops(); end

  def possibly_include_hidden?(); end

  def signature(); end

  def smart_loaded_path(); end

  def target_rails_version(); end

  def target_ruby_version(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def transform_values(*args, &block); end

  def validate(*args, &block); end
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config::CopConfig
  def metadata(); end

  def metadata=(_); end

  def name(); end

  def name=(_); end
end

class RuboCop::Config::CopConfig
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Config
  extend ::Forwardable
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_missing_namespaces(path, hash); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.disable_pending_cops(); end

  def self.disable_pending_cops=(disable_pending_cops); end

  def self.enable_pending_cops(); end

  def self.enable_pending_cops=(enable_pending_cops); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.load_yaml_configuration(absolute_path); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file, unset_nil: T.unsafe(nil)); end

  def self.possible_new_cops?(config); end

  def self.project_root(); end

  def self.project_root=(project_root); end

  def self.warn_on_pending_cops(pending_cops); end

  def self.warn_pending_cop(cop); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file, unset_nil:); end

  def override_department_setting_for_cops(base_hash, derived_hash); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigObsoletion
  def initialize(config); end

  def reject_obsolete_cops_and_parameters(); end
end

class RuboCop::ConfigRegeneration
  def options(); end
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  COMMAND_REGEX = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigRegeneration
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def for_dir(dir); end

  def for_file(file); end

  def for_pwd(); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

class RuboCop::ConfigValidator
  def for_all_cops(*args, &block); end

  def initialize(config); end

  def smart_loaded_path(*args, &block); end

  def target_ruby_version(); end

  def validate(); end

  def validate_section_presence(name); end
end

class RuboCop::ConfigValidator
  extend ::Forwardable
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(corrector, processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

module RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::AllowedMethods
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::AutoCorrector
  def support_autocorrect?(); end
end

module RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def correctable?(); end

  def disable_uncorrectable?(); end

  def safe_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(department, cop_name); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge::InvalidBadge
  def initialize(token); end
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

class RuboCop::Cop::Base
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_global_offense(message=T.unsafe(nil), severity: T.unsafe(nil)); end

  def add_offense(node_or_range, message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def excluded_file?(file); end

  def external_dependency_checksum(); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def message(_range=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def on_investigation_end(); end

  def on_new_investigation(); end

  def on_other_file(); end

  def processed_source(); end

  def ready(); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Base::InvestigationReport
  def cop(); end

  def cop=(_); end

  def corrector(); end

  def corrector=(_); end

  def offenses(); end

  def offenses=(_); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Base::InvestigationReport
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Base
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::AST::NodePattern::Macros
  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.documentation_url(); end

  def self.exclude_from_registry(); end

  def self.inherited(subclass); end

  def self.joining_forces(); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.support_autocorrect?(); end

  def self.support_multiple_source?(); end
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(param0); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  def gem_declaration?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  include ::RuboCop::Cop::RangeHelp
  def insecure_protocol_source?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(param0); end

  def investigate(processed_source); end
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  def self.extract_rhs(node); end
end

module RuboCop::Cop::CheckLineBreakable
  def extract_breakable_node(node, max); end
end

module RuboCop::Cop::CheckLineBreakable
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::CodeLength
end

module RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  def source_range_with_comment(node); end
end

module RuboCop::Cop::CommentsHelp
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def cop_reports(); end

  def cop_reports=(_); end

  def cops(); end

  def correctors(); end

  def errors(); end

  def errors=(_); end

  def merge(investigation); end

  def offenses(); end

  def offenses_per_cop(); end

  def processed_source(); end

  def processed_source=(_); end
end

class RuboCop::Cop::Commissioner::InvestigationReport
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(corrector, node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_configured?(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

class RuboCop::Cop::Cop
  def add_offense(node_or_range, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil), &block); end

  def corrections(); end

  def find_location(node, loc); end

  def parse(source, path=T.unsafe(nil)); end

  def support_autocorrect?(); end
end

class RuboCop::Cop::Cop::Correction
  def call(corrector); end

  def cop(); end

  def cop=(_); end

  def lambda=(_); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::Cop::Correction
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Cop
  def self.all(); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def initialize(source); end

  def remove_leading(node_or_range, size); end

  def remove_preceding(node_or_range, size); end

  def remove_trailing(node_or_range, size); end

  def rewrite(); end
end

class RuboCop::Cop::Corrector
  def self.source_buffer(source); end
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Documentation
end

module RuboCop::Cop::Documentation
  def self.department_to_basename(department); end

  def self.url_for(cop_class); end
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
end

class RuboCop::Cop::EachToForCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::EachToForCorrector
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(corrector, node); end

  def self.insert_before(corrector, node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
end

class RuboCop::Cop::ForToEachCorrector
  def call(corrector); end

  def initialize(for_node); end
end

class RuboCop::Cop::ForToEachCorrector
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  def self.frozen_string_literal_comment_exists?(); end
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  def assignment_method_declarations(param0); end

  def gem_specification(param0); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(param0); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  include ::RuboCop::Cop::RangeHelp
  def defined_ruby_version(param0=T.unsafe(nil)); end

  def investigate(processed_source); end

  def required_ruby_version(param0); end
  MISSING_MSG = ::T.let(nil, ::T.untyped)
  NOT_EQUAL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RubyVersionGlobalsUsage
  def gem_specification?(param0); end

  def on_const(node); end

  def ruby_version?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Generator
  def initialize(name, github_user, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil), version_added: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
end

class RuboCop::Cop::Generator::ConfigurationInjector
  def initialize(configuration_file_path:, badge:, version_added:); end

  def inject(); end
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
end

module RuboCop::Cop::HashAlignmentStyles
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(first_pair, _node); end
end

class RuboCop::Cop::HashAlignmentStyles::KeyAlignment
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignmentStyles::SeparatorAlignment
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
  include ::RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignmentStyles::TableAlignment
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignmentStyles::ValueAlignment
end

module RuboCop::Cop::HashAlignmentStyles
end

module RuboCop::Cop::HashTransformMethod
  def array_receiver?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def block_node(); end

  def block_node=(_); end

  def leading(); end

  def leading=(_); end

  def match(); end

  def match=(_); end

  def set_new_arg_name(transformed_argname, corrector); end

  def set_new_body_expression(transforming_body_expr, corrector); end

  def set_new_method_name(new_method_name, corrector); end

  def strip_prefix_and_suffix(node, corrector); end

  def trailing(); end

  def trailing=(_); end
end

class RuboCop::Cop::HashTransformMethod::Autocorrection
  def self.[](*_); end

  def self.from_each_with_object(node, match); end

  def self.from_hash_brackets_map(node, match); end

  def self.from_map_to_h(node, match); end

  def self.from_to_h(node, match); end

  def self.members(); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def noop_transformation?(); end

  def transformation_uses_both_args?(); end

  def transformed_argname(); end

  def transformed_argname=(_); end

  def transforming_body_expr(); end

  def transforming_body_expr=(_); end

  def unchanged_body_expr(); end

  def unchanged_body_expr=(_); end
end

class RuboCop::Cop::HashTransformMethod::Captures
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::HashTransformMethod
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::Interpolation
  def on_dstr(node); end

  def on_dsym(node); end

  def on_node_with_interpolations(node); end

  def on_regexp(node); end

  def on_xstr(node); end
end

module RuboCop::Cop::Interpolation
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
  def call(corrector); end

  def initialize(block_node); end
end

class RuboCop::Cop::LambdaLiteralToMethodCorrector
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
end

class RuboCop::Cop::Layout::ArgumentAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::ArrayAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
end

class RuboCop::Cop::Layout::AssignmentIndentation
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def leftmost_multiple_assignment(node); end
end

class RuboCop::Cop::Layout::BeginEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BeginEndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def block_end_align_target?(param0=T.unsafe(nil), param1); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::BlockAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(case_node); end
end

class RuboCop::Cop::Layout::CaseIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClassStructure
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(class_node); end
end

class RuboCop::Cop::Layout::ClassStructure
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(comment); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::ConditionPosition
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::ConditionPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DefEndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_case_match(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::EmptyComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_if(node); end

  def on_rescue(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMultilineCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(corrector, prev_def, node); end

  def check_defs(nodes); end

  def on_begin(node); end
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::EmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  def on_send(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundAttributeAccessor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_kwbegin(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(param0=T.unsafe(nil)); end

  def empty_line_required?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def on_sclass(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_module(node); end
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end

  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::ExtraSpacing
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstArgumentIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def eligible_method_call?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::FirstArrayElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_array(node); end
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstHashElementIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_csend(node); end

  def on_hash(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_hash(node); end
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MultilineElementIndentation
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::HashAlignment
  include ::RuboCop::Cop::HashAlignmentStyles
  include ::RuboCop::Cop::RangeHelp
  def column_deltas(); end

  def column_deltas=(column_deltas); end

  def offences_by(); end

  def offences_by=(offences_by); end

  def on_hash(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

class RuboCop::Cop::Layout::HashAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
end

class RuboCop::Cop::Layout::HeredocArgumentClosingParenthesis
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::HeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
end

class RuboCop::Cop::Layout::HeredocIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
end

class RuboCop::Cop::Layout::IndentationStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  def access_modifier?(param0=T.unsafe(nil)); end

  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_csend(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_sclass(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::InitialIndentation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LeadingEmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::LineLength
  include ::RuboCop::Cop::CheckLineBreakable
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::LineLengthHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def investigate_post_walk(processed_source); end

  def on_array(node); end

  def on_block(node); end

  def on_hash(node); end

  def on_potential_breakable_node(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_array(node); end
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_array(node); end
end

class RuboCop::Cop::Layout::MultilineArrayLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_hash(node); end
end

class RuboCop::Cop::Layout::MultilineHashKeyLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  include ::RuboCop::Cop::MultilineElementLineBreaks
  def on_send(node); end
end

class RuboCop::Cop::Layout::MultilineMethodArgumentLineBreaks
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::ParameterAlignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_ensure(node); end

  def on_resbody(node); end
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def on_kwoptarg(node); end

  def on_pair(node); end
end

class RuboCop::Cop::Layout::SpaceAfterColon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
end

class RuboCop::Cop::Layout::SpaceAfterNot
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_optarg(node); end
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  include ::RuboCop::Cop::RangeHelp
  def on_const(node); end

  def on_csend(node); end

  def on_send(node); end
  SPACES_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundMethodCallOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::RationalLiteral
  def on_and(node); end

  def on_and_asgn(node); end

  def on_assignment(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_array(node); end
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

class RuboCop::Cop::Layout::SpaceInsideParens
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def on_erange(node); end

  def on_irange(node); end
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_interpolation(begin_node); end
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::TrailingEmptyLines
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Layout::TrailingWhitespace
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Legacy
end

class RuboCop::Cop::Legacy::CorrectionsProxy
  def <<(callable); end

  def concat(corrections); end

  def corrector(); end

  def empty?(); end

  def initialize(corrector); end
end

class RuboCop::Cop::Legacy::CorrectionsProxy
end

module RuboCop::Cop::Legacy
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::LineLengthHelp
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::AmbiguousOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Lint::BigDecimalNew
  def big_decimal_new(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
  def on_and(node); end

  def on_or(node); end

  def on_send(node); end
  MATH_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BinaryOperatorWithIdenticalOperands
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(param0=T.unsafe(nil)); end

  def on_sym(node); end
end

class RuboCop::Cop::Lint::BooleanSymbol
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
  def constant_assigned_in_block?(param0=T.unsafe(nil)); end

  def module_defined_in_block?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantDefinitionInBlock
end

class RuboCop::Cop::Lint::ConstantResolution
  def on_const(node); end

  def unqualified_const?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ConstantResolution
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(param0=T.unsafe(nil)); end

  def debugger_call?(param0=T.unsafe(nil)); end

  def kernel?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(deprecated:, replacement:, class_constant: T.unsafe(nil)); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  include ::RuboCop::Cop::RangeHelp
  def algorithm_const(param0=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::DeprecatedOpenSSLConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  def on_def(node); end
end

class RuboCop::Cop::Lint::DisjunctiveAssignmentInConstructor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateElsifCondition
end

class RuboCop::Cop::Lint::DuplicateHashKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(param0=T.unsafe(nil)); end

  def method_alias?(param0=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REQUIRE_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRequire
end

class RuboCop::Cop::Lint::DuplicateRescueException
  include ::RuboCop::Cop::RescueNode
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateRescueException
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(param0=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
end

class RuboCop::Cop::Lint::EmptyConditionalBody
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyConditionalBody
end

class RuboCop::Cop::Lint::EmptyEnsure
  def on_ensure(node); end
end

class RuboCop::Cop::Lint::EmptyEnsure
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
end

class RuboCop::Cop::Lint::EmptyFile
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyFile
end

class RuboCop::Cop::Lint::EmptyInterpolation
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end
end

class RuboCop::Cop::Lint::EmptyInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
end

class RuboCop::Cop::Lint::EnsureReturn
  include ::RuboCop::Cop::RangeHelp
  def on_ensure(node); end
end

class RuboCop::Cop::Lint::EnsureReturn
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ErbNewArguments
  include ::RuboCop::Cop::RangeHelp
  def erb_new_with_non_keyword_arguments(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
end

class RuboCop::Cop::Lint::FloatComparison
  def on_send(node); end
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_INSTANCE_METHODS = ::T.let(nil, ::T.untyped)
  FLOAT_RETURNING_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatComparison
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def called_on_string?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG_INVALID = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
  def id_as_hash_key?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HashCompareByIdentity
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::HeredocMethodCallPosition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::IdentityComparison
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IdentityComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(param0); end
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def class_new_call?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::InterpolationCheck
  def on_str(node); end
end

class RuboCop::Cop::Lint::InterpolationCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::LiteralAsCondition
  include ::RuboCop::Cop::RangeHelp
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::Interpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_interpolation(begin_node); end
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
end

class RuboCop::Cop::Lint::Loop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Lint::MissingSuper
  def on_def(node); end

  def on_defs(node); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
  CALLBACK_MSG = ::T.let(nil, ::T.untyped)
  CLASS_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  CONSTRUCTOR_MSG = ::T.let(nil, ::T.untyped)
  METHOD_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  OBJECT_LIFECYCLE_CALLBACKS = ::T.let(nil, ::T.untyped)
  STATELESS_CLASSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingSuper
end

class RuboCop::Cop::Lint::MixedRegexpCaptureTypes
  def on_regexp(node); end
end

class RuboCop::Cop::Lint::MultipleComparison
  def multiple_compare?(param0=T.unsafe(nil)); end

  def on_send(node); end
  COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(param0=T.unsafe(nil)); end

  def eval_call?(param0=T.unsafe(nil)); end

  def exec_call?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  def loop_variable(param0=T.unsafe(nil)); end

  def method_require?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_block_pass(node); end

  def unsorted_dir_block?(param0=T.unsafe(nil)); end

  def unsorted_dir_each?(param0=T.unsafe(nil)); end

  def unsorted_dir_each_pass?(param0=T.unsafe(nil)); end

  def unsorted_dir_glob_pass?(param0=T.unsafe(nil)); end

  def var_is_required?(param0, param1); end
end

class RuboCop::Cop::Lint::NonDeterministicRequireOrder
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(return_node); end
end

class RuboCop::Cop::Lint::NumberConversion
  def datetime?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def to_method(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
end

class RuboCop::Cop::Lint::OrderedMagicComments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
  def on_match_with_lvasgn(node); end

  def on_nth_ref(node); end

  def on_send(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REGEXP_ARGUMENT_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_CAPTURE_METHODS = ::T.let(nil, ::T.untyped)
  REGEXP_RECEIVER_METHODS = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OutOfRangeRegexpRef
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
end

class RuboCop::Cop::Lint::PercentStringArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
end

class RuboCop::Cop::Lint::PercentSymbolArray
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RaiseException
  def exception?(param0=T.unsafe(nil)); end

  def exception_new_with_message?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RaiseException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  include ::RuboCop::Cop::RangeHelp
  def initialize(config=T.unsafe(nil), options=T.unsafe(nil), offenses=T.unsafe(nil)); end

  def offenses_to_check(); end

  def offenses_to_check=(offenses_to_check); end
end

class RuboCop::Cop::Lint::RedundantCopDisableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Lint::RedundantCopEnableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def unnecessary_require_statement?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantRequireStatement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def respond_to_nil_specific_method?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  NIL_SPECIFIC_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantSafeNavigation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  def array_new?(param0=T.unsafe(nil)); end

  def literal_expansion(param0=T.unsafe(nil)); end

  def on_splat(node); end
end

class RuboCop::Cop::Lint::RedundantSplatExpansion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  include ::RuboCop::Cop::Interpolation
  def on_interpolation(begin_node); end

  def to_s_without_args?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantStringCoercion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def redundant_with_index?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantWithIndex
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def redundant_with_object?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::RedundantWithObject
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
end

class RuboCop::Cop::Lint::RegexpAsCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
end

class RuboCop::Cop::Lint::RescueType
  def autocorrect(corrector, node); end

  def on_resbody(node); end
end

class RuboCop::Cop::Lint::RescueType
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  def bad_method?(param0=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  def check(node); end

  def on_csend(node); end
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  def on_if(node); end

  def safe_navigation_empty_in_conditional?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::SafeNavigationWithEmpty
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ScriptPermission
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::SelfAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end
  ASSIGNMENT_TYPE_TO_RHS_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SelfAssignment
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def send_with_mixin_argument?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  SEND_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SendWithMixinArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def uses_var?(param0, param1); end
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end
end

class RuboCop::Cop::Lint::StructNewOverride
  def on_send(node); end

  def struct_new(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SuppressedException
  def on_resbody(node); end
end

class RuboCop::Cop::Lint::ToJSON
  def on_def(node); end
end

class RuboCop::Cop::Lint::ToJSON
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TopLevelReturnWithArgument
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::TrailingCommaInAttributeDeclaration
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end
end

class RuboCop::Cop::Lint::UnifiedInteger
  def fixnum_or_bignum_const(param0=T.unsafe(nil)); end

  def on_const(node); end
end

class RuboCop::Cop::Lint::UnifiedInteger
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
end

class RuboCop::Cop::Lint::UnreachableLoop
  def break_command?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableLoop
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def not_implemented?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(param0=T.unsafe(nil)); end
  METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
  URI_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessAccessModifier
  include ::RuboCop::Cop::RangeHelp
  def class_or_instance_eval?(param0=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(param0=T.unsafe(nil)); end

  def dynamic_method_definition?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UselessAccessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessAssignment
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end

  def setter_call_to_local_variable?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessTimes
  include ::RuboCop::Cop::RangeHelp
  def block_arg(param0=T.unsafe(nil)); end

  def block_reassigns_arg?(param0, param1); end

  def on_send(node); end

  def times_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessTimes
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message); end

  def config(); end

  def cop_config(); end

  def cop_name(); end

  def initialize(config, cop_name, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def define_method?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_casgn(node); end

  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def module_definition?(param0=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(param0=T.unsafe(nil)); end

  def on_args(node); end
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  include ::RuboCop::Cop::Metrics::Utils::IteratingBlock
  include ::RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def calculate(); end

  def else_branch?(node); end

  def evaluate_branch_nodes(node); end

  def evaluate_condition_node(node); end

  def initialize(node); end
end

class RuboCop::Cop::Metrics::Utils::AbcSizeCalculator
  def self.calculate(node); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def calculate(); end

  def initialize(node, processed_source, count_comments: T.unsafe(nil), foldable_types: T.unsafe(nil)); end
end

class RuboCop::Cop::Metrics::Utils::CodeLengthCalculator
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
  def block_method_name(node); end

  def iterating_block?(node); end

  def iterating_method?(name); end
  KNOWN_ITERATING_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Metrics::Utils::IteratingBlock
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
  def discount_for_repeated_csend?(csend_node); end

  def reset_on_lvasgn(node); end

  def reset_repeated_csend(); end
end

module RuboCop::Cop::Metrics::Utils::RepeatedCsendDiscount
end

class RuboCop::Cop::Migration::DepartmentName
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Migration::DepartmentName
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementIndentation
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineElementLineBreaks
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def call(); end

  def initialize(corrector, node, processed_source); end
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  def self.correct(corrector, node, processed_source); end
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  CONSTANT_MSG = ::T.let(nil, ::T.untyped)
  IDENTIFIER_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(param0=T.unsafe(nil)); end
  EXCLUDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BlockParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::BlockParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(param0=T.unsafe(nil)); end

  def literal_receiver?(param0=T.unsafe(nil)); end

  def on_casgn(node); end
end

class RuboCop::Cop::Naming::FileName
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def memoized?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def str_name(param0=T.unsafe(nil)); end

  def sym_name(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Naming::MethodParameterName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::MethodParameterName
end

class RuboCop::Cop::Naming::PredicateName
  include ::RuboCop::Cop::AllowedMethods
  def dynamic_method_define(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  def on_resbody(node); end
end

class RuboCop::Cop::Naming::RescuedExceptionsVariableName
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(param0=T.unsafe(nil)); end

  def single_negative?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
end

module RuboCop::Cop::NilMethods
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def correctable?(); end

  def corrected?(); end

  def corrected_with_todo?(); end

  def corrector(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil), corrector=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  NO_LOCATION = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(corrector, node); end
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def config(); end

  def correct(corrector, node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(corrector, token); end

  def self.remove_space(corrector, space_before); end

  def self.swap_comma(corrector, range); end
end

module RuboCop::Cop::RationalLiteral
  def rational_literal?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::RationalLiteral
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Registry
  include ::Enumerable
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def department_missing?(badge, name); end

  def departments(); end

  def dismiss(cop); end

  def each(&block); end

  def enabled(config, only=T.unsafe(nil), only_safe: T.unsafe(nil)); end

  def enabled?(cop, config, only_safe); end

  def enabled_pending_cop?(cop_cfg, config); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def initialize(cops=T.unsafe(nil), options=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def options(); end

  def print_warning(name, path); end

  def qualified_cop_name(name, path, warn: T.unsafe(nil)); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def unqualified_cop_names(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
  def self.all(); end

  def self.global(); end

  def self.qualified_cop_name(name, origin); end

  def self.with_temporary_global(temp_global=T.unsafe(nil)); end
end

module RuboCop::Cop::RescueNode
  def on_new_investigation(); end
end

module RuboCop::Cop::RescueNode
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(param0=T.unsafe(nil)); end

  def safe_assignment?(param0=T.unsafe(nil)); end

  def setter_method?(param0=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Security::Eval
  def eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  def json_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  def on_send(node); end

  def yaml_load(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::Sorbet
end

class RuboCop::Cop::Sorbet::AllowIncompatibleOverride
  def allow_incompatible?(param0); end

  def allow_incompatible_override?(param0=T.unsafe(nil)); end

  def not_nil?(node); end

  def on_send(node); end

  def sig?(param0); end
end

class RuboCop::Cop::Sorbet::AllowIncompatibleOverride
end

class RuboCop::Cop::Sorbet::BindingConstantWithoutTypeAlias
  def autocorrect(node); end

  def binding_unaliased_type?(param0=T.unsafe(nil)); end

  def dynamic_type_creation_with_block?(param0=T.unsafe(nil)); end

  def generic_parameter_decl?(param0=T.unsafe(nil)); end

  def method_needing_aliasing_on_t?(param0); end

  def not_dynamic_type_creation_with_block?(node); end

  def not_generic_parameter_decl?(node); end

  def not_nil?(node); end

  def not_t_let?(node); end

  def on_casgn(node); end

  def t_let?(param0=T.unsafe(nil)); end

  def using_deprecated_type_alias_syntax?(param0=T.unsafe(nil)); end

  def using_type_alias?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Sorbet::BindingConstantWithoutTypeAlias
end

class RuboCop::Cop::Sorbet::CheckedTrueInSignature
  include ::RuboCop::Cop::RangeHelp
  def offending_node(param0); end

  def on_signature(node); end
end

class RuboCop::Cop::Sorbet::CheckedTrueInSignature
end

class RuboCop::Cop::Sorbet::ConstantsFromStrings
  def constant_from_string?(param0=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Sorbet::ConstantsFromStrings
end

class RuboCop::Cop::Sorbet::EnforceSigilOrder
  include ::RuboCop::Cop::RangeHelp
  def check_magic_comments_order(tokens); end

  def extract_magic_comments(processed_source); end
  CODING_REGEX = ::T.let(nil, ::T.untyped)
  FROZEN_REGEX = ::T.let(nil, ::T.untyped)
  INDENT_REGEX = ::T.let(nil, ::T.untyped)
  MAGIC_REGEX = ::T.let(nil, ::T.untyped)
  PREFERRED_ORDER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::EnforceSigilOrder
end

class RuboCop::Cop::Sorbet::EnforceSignatures
  def accessor?(param0=T.unsafe(nil)); end

  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Sorbet::EnforceSignatures::SigSuggestion
  def initialize(indent, param_placeholder, return_placeholder); end

  def params(); end

  def params=(params); end

  def returns(); end

  def returns=(returns); end

  def to_autocorrect(); end
end

class RuboCop::Cop::Sorbet::EnforceSignatures::SigSuggestion
end

class RuboCop::Cop::Sorbet::EnforceSignatures
end

class RuboCop::Cop::Sorbet::FalseSigil
end

class RuboCop::Cop::Sorbet::FalseSigil
end

class RuboCop::Cop::Sorbet::ForbidIncludeConstLiteral
  def initialize(*_); end

  def not_lit_const_include?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def used_names(); end

  def used_names=(used_names); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidIncludeConstLiteral
end

class RuboCop::Cop::Sorbet::ForbidSuperclassConstLiteral
  def not_lit_const_superclass?(param0=T.unsafe(nil)); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidSuperclassConstLiteral
end

class RuboCop::Cop::Sorbet::ForbidUntypedStructProps
  def on_class(node); end

  def subclass_of_t_struct?(param0=T.unsafe(nil)); end

  def t_nilable_untyped(param0=T.unsafe(nil)); end

  def t_struct(param0=T.unsafe(nil)); end

  def t_untyped(param0=T.unsafe(nil)); end

  def untyped_props(param0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ForbidUntypedStructProps
end

class RuboCop::Cop::Sorbet::HasSigil
end

class RuboCop::Cop::Sorbet::HasSigil
end

class RuboCop::Cop::Sorbet::IgnoreSigil
end

class RuboCop::Cop::Sorbet::IgnoreSigil
end

class RuboCop::Cop::Sorbet::KeywordArgumentOrdering
  def on_signature(node); end
end

class RuboCop::Cop::Sorbet::KeywordArgumentOrdering
end

class RuboCop::Cop::Sorbet::ParametersOrderingInSignature
  def on_signature(node); end

  def signature_params(param0); end
end

class RuboCop::Cop::Sorbet::ParametersOrderingInSignature
end

class RuboCop::Cop::Sorbet::SignatureBuildOrder
  def autocorrect(node); end

  def on_signature(node); end

  def root_call(param0); end
  ORDER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::SignatureBuildOrder
end

class RuboCop::Cop::Sorbet::SignatureCop
  def on_block(node); end

  def on_signature(_); end

  def signature?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Sorbet::SignatureCop
end

class RuboCop::Cop::Sorbet::StrictSigil
end

class RuboCop::Cop::Sorbet::StrictSigil
end

class RuboCop::Cop::Sorbet::StrongSigil
end

class RuboCop::Cop::Sorbet::StrongSigil
end

class RuboCop::Cop::Sorbet::TrueSigil
end

class RuboCop::Cop::Sorbet::TrueSigil
end

class RuboCop::Cop::Sorbet::ValidSigil
  def autocorrect(_node); end

  def check_sigil_present(sigil); end

  def check_strictness_level(sigil, strictness); end

  def check_strictness_not_empty(sigil, strictness); end

  def check_strictness_valid(sigil, strictness); end

  def extract_sigil(processed_source); end

  def extract_strictness(sigil); end

  def investigate(processed_source); end

  def minimum_strictness(); end

  def require_sigil_on_all_files?(); end

  def suggested_strictness(); end

  def suggested_strictness_level(minimum_strictness, suggested_strictness); end
  SIGIL_REGEX = ::T.let(nil, ::T.untyped)
  STRICTNESS_LEVELS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Sorbet::ValidSigil
end

module RuboCop::Cop::Sorbet
end

module RuboCop::Cop::SpaceAfterPunctuation
  def on_new_investigation(); end
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def on_new_investigation(); end
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def access_modifier_with_symbol?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  ACCESSOR_METHODS = ::T.let(nil, ::T.untyped)
  GROUPED_MSG = ::T.let(nil, ::T.untyped)
  SEPARATED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessorGrouping
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def identifier(param0=T.unsafe(nil)); end

  def on_alias(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
end

class RuboCop::Cop::Style::AndOr
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
end

class RuboCop::Cop::Style::ArrayCoercion
  def array_splat?(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_if(node); end

  def unless_array?(param0=T.unsafe(nil)); end
  CHECK_MSG = ::T.let(nil, ::T.untyped)
  SPLAT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayCoercion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ArrayJoin
  def join_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def class_eval?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_dstr(node); end

  def on_str(node); end
end

class RuboCop::Cop::Style::BarePercentLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  include ::RuboCop::Cop::VisibilityHelp
  def on_class(class_node); end

  def on_module(class_node); end

  def on_sclass(class_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BisectedAttrAccessor
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::BlockComments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::BlockDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CaseLikeIf
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseLikeIf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def on_module(node); end
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassEqualityComparison
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def class_comparison_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassEqualityComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassMethods
  def on_class(node); end

  def on_module(node); end
end

class RuboCop::Cop::Style::ClassMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::CommentsHelp
  include ::RuboCop::Cop::VisibilityHelp
  include ::RuboCop::Cop::RangeHelp
  def on_defs(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethodsDefinitions
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ClassVars
  def on_cvasgn(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::CollectionMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ColonMethodCall
  def java_type_node?(param0=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::ColonMethodCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def on_defs(node); end
end

class RuboCop::Cop::Style::ColonMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CombinableLoops
  def on_block(node); end

  def on_for(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CombinableLoops
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_xstr(node); end
end

class RuboCop::Cop::Style::CommandLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::CommentAnnotation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::CommentedKeyword
  ALLOWED_COMMENT_REGEXES = ::T.let(nil, ::T.untyped)
  KEYWORD_REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(param0=T.unsafe(nil)); end

  def candidate_condition?(param0=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::ConditionalAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::AST::NodePattern::Macros
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
end

class RuboCop::Cop::Style::ConstantVisibility
  def on_casgn(node); end

  def visibility_declaration_for?(param0=T.unsafe(nil), param1); end
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::Copyright
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DateTime
  def date_time?(param0=T.unsafe(nil)); end

  def historic_date?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def to_datetime?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::DateTime
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DefWithParentheses
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::DefWithParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Dir
  def dir_replacement?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DisableCopsWithinSourceCodeDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(param0=T.unsafe(nil)); end

  def constant_visibility_declaration?(param0=T.unsafe(nil)); end

  def on_class(node); end

  def on_module(node); end

  def outer_module(param0); end
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def module_function_node?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::DoubleCopDisableDirective
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::DoubleNegation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def double_negative?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def offending_each_range(param0=T.unsafe(nil)); end

  def on_block(node); end
end

class RuboCop::Cop::Style::EachForSimpleLoop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def each_with_object_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end
end

class RuboCop::Cop::Style::EachWithObject
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Style::EmptyBlockParameter
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def on_case(case_node); end
end

class RuboCop::Cop::Style::EmptyCaseCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_case(node); end

  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::EmptyElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def array_node(param0=T.unsafe(nil)); end

  def array_with_block(param0=T.unsafe(nil)); end

  def hash_node(param0=T.unsafe(nil)); end

  def hash_with_block(param0=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::EmptyMethod
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::Encoding
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
end

class RuboCop::Cop::Style::EndBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(param0=T.unsafe(nil)); end

  def line_with_offset?(param0=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  def even_odd_candidate?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def file_expand_path(param0=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(param0=T.unsafe(nil)); end

  def pathname_parent_expand_path(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  include ::RuboCop::Cop::RangeHelp
  def on_yield(node); end

  def yielding_block?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExplicitBlockArgument
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ExponentialNotation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_float(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExponentialNotation
end

class RuboCop::Cop::Style::FloatDivision
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def any_coerce?(param0=T.unsafe(nil)); end

  def both_coerce?(param0=T.unsafe(nil)); end

  def left_coerce?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def right_coerce?(param0=T.unsafe(nil)); end
  MESSAGES = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FloatDivision
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_for(node); end
end

class RuboCop::Cop::Style::For
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def formatter(param0=T.unsafe(nil)); end

  def on_send(node); end

  def variable_argument?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def format_string_in_typical_context?(param0=T.unsafe(nil)); end

  def on_str(node); end
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::GlobalStdStream
  def const_to_gvar_assignment?(param0=T.unsafe(nil), param1); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
  STD_STREAMS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalStdStream
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_hash(node); end
end

class RuboCop::Cop::Style::HashAsLastArrayItem
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashEachMethods
  include ::RuboCop::Cop::Lint::UnusedArgument
  def kv_each(param0=T.unsafe(nil)); end

  def on_block(node); end
end

class RuboCop::Cop::Style::HashEachMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashLikeCase
  def hash_like_case?(param0=T.unsafe(nil)); end

  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashLikeCase
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
end

class RuboCop::Cop::Style::HashTransformKeys
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformKeys
  extend ::RuboCop::Cop::TargetRubyVersion
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::HashTransformValues
  include ::RuboCop::Cop::HashTransformMethod
  def on_bad_each_with_object(param0=T.unsafe(nil)); end

  def on_bad_hash_brackets_map(param0=T.unsafe(nil)); end

  def on_bad_map_to_h(param0=T.unsafe(nil)); end

  def on_bad_to_h(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::HashTransformValues
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, cop, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::IgnoredPattern
  def on_if(node); end
end

class RuboCop::Cop::Style::IfUnlessModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_if(node); end
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::IfWithSemicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
  def after_leaving_scope(scope, _variable_table); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
end

class RuboCop::Cop::Style::InfiniteLoop
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::InverseMethods
  include ::RuboCop::Cop::RangeHelp
  def inverse_block?(param0=T.unsafe(nil)); end

  def inverse_candidate?(param0=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::InverseMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
end

class RuboCop::Cop::Style::KeywordParametersOrder
  include ::RuboCop::Cop::RangeHelp
  def on_kwoptarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::KeywordParametersOrder
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_block(node); end

  def on_numblock(node); end
end

class RuboCop::Cop::Style::Lambda
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(corrector, node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LambdaCall
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
end

class RuboCop::Cop::Style::LineEndConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  include ::RuboCop::Cop::IgnoredPattern
  def autocorrect(_node); end

  def initialize(*_); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::OmitParentheses
  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
  def message(_node=T.unsafe(nil)); end

  def on_csend(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
end

module RuboCop::Cop::Style::MethodCallWithArgsParentheses::RequireParentheses
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def on_send(node); end
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::MethodDefParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MinMax
  def min_max_candidate(param0=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
end

class RuboCop::Cop::Style::MinMax
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_class(node); end

  def on_module(node); end
end

class RuboCop::Cop::Style::MixinGrouping
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MixinUsage
  def in_top_level_scope?(param0=T.unsafe(nil)); end

  def include_statement(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def extend_self_node?(param0=T.unsafe(nil)); end

  def module_function_node?(param0=T.unsafe(nil)); end

  def on_module(node); end

  def private_directive?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ModuleFunction
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  include ::RuboCop::Cop::Alignment
  def on_if(node); end
end

class RuboCop::Cop::Style::MultilineIfModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::MultilineIfThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def message(_node); end

  def on_or_asgn(node); end
  BRACES_MSG = ::T.let(nil, ::T.untyped)
  KEYWORD_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultilineWhenThen
  include ::RuboCop::Cop::RangeHelp
  def on_when(node); end
end

class RuboCop::Cop::Style::MultilineWhenThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison?(param0=T.unsafe(nil)); end

  def simple_double_comparison?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_casgn(node); end

  def on_or_asgn(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end

  def range_enclosed_in_parentheses?(param0=T.unsafe(nil)); end

  def splat_value(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::MutableConstant
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedUnless
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NestedModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::AllowedMethods
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
end

class RuboCop::Cop::Style::NestedTernaryOperator
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::Next
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def nil_check?(param0=T.unsafe(nil)); end

  def nil_comparison?(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NonNilCheck
  def nil_check?(param0=T.unsafe(nil)); end

  def not_and_nil_check?(param0=T.unsafe(nil)); end

  def not_equal_to_nil?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NonNilCheck
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def on_int(node); end
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_float(node); end

  def on_int(node); end
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def comparison(param0=T.unsafe(nil)); end

  def inverted_comparison(param0=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
end

class RuboCop::Cop::Style::OneLineConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
end

class RuboCop::Cop::Style::OptionalBooleanParameter
  include ::RuboCop::Cop::AllowedMethods
  def on_def(node); end

  def on_defs(node); end
  BOOLEAN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalBooleanParameter
end

class RuboCop::Cop::Style::OrAssignment
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(param0=T.unsafe(nil)); end

  def unless_assignment?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::OrAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def implicit_self_getter?(param0=T.unsafe(nil)); end

  def on_masgn(node); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(param0, param1, param2); end

  def tsort_each_child(assignment); end

  def tsort_each_node(&block); end

  def uses_var?(param0, param1); end

  def var_name(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def control_op_condition(param0=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_str(node); end
end

class RuboCop::Cop::Style::PercentQLiterals
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PerlBackrefs
  def on_nth_ref(node); end
end

class RuboCop::Cop::Style::PerlBackrefs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Proc
  def on_block(node); end

  def proc_new?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::Proc
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RandomWithOffset
  def integer_op_rand?(param0=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(param0=T.unsafe(nil)); end

  def rand_op_integer?(param0=T.unsafe(nil)); end

  def random_call(param0=T.unsafe(nil)); end

  def to_int(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantAssignment
  def on_def(node); end

  def on_defs(node); end

  def redundant_assignment?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantBegin
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
end

class RuboCop::Cop::Style::RedundantBegin
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end
end

class RuboCop::Cop::Style::RedundantCapitalW
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantCondition
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end
end

class RuboCop::Cop::Style::RedundantCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def on_if(node); end

  def redundant_condition?(param0=T.unsafe(nil)); end

  def redundant_condition_inverted?(param0=T.unsafe(nil)); end
  COMPARISON_OPERATOR_MATCHER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantException
  def compact?(param0=T.unsafe(nil)); end

  def exploded?(param0=T.unsafe(nil)); end

  def fix_compact(node); end

  def fix_exploded(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFetchBlock
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def rails_cache?(param0=T.unsafe(nil)); end

  def redundant_fetch_block_candidate?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFetchBlock
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  def on_send(node); end

  def require_call?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFileExtensionInRequire
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def on_send(node); end

  def operation_produces_immutable_object?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_dstr(node); end
end

class RuboCop::Cop::Style::RedundantInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(param0=T.unsafe(nil)); end

  def first_send_argument?(param0=T.unsafe(nil)); end

  def first_super_argument?(param0=T.unsafe(nil)); end

  def first_yield_argument?(param0=T.unsafe(nil)); end

  def method_node_and_args(param0=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(param0=T.unsafe(nil)); end

  def rescue?(param0=T.unsafe(nil)); end

  def square_brackets?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantPercentQ
  def on_dstr(node); end

  def on_str(node); end
end

class RuboCop::Cop::Style::RedundantPercentQ
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  def on_regexp(node); end
  REQUIRES_ESCAPE_OUTSIDE_CHAR_CLASS_CHARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantRegexpCharacterClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  include ::RuboCop::Cop::RangeHelp
  def on_regexp(node); end
end

class RuboCop::Cop::Style::RedundantRegexpEscape
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::RedundantReturn
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSelf
  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  KEYWORDS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  include ::RuboCop::Cop::RangeHelp
  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_send(node); end

  def redundant_nonself_assignment?(param0=T.unsafe(nil), param1, param2); end

  def redundant_self_assignment?(param0=T.unsafe(nil), param1); end
  ASSIGNMENT_TYPE_TO_RECEIVER_TYPE = ::T.let(nil, ::T.untyped)
  METHODS_RETURNING_SELF = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelfAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSort
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def redundant_sort?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSort
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def redundant_sort_by(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RedundantSortBy
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_regexp(node); end
end

class RuboCop::Cop::Style::RegexpLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_resbody(node); end

  def rescue_standard_error?(param0=T.unsafe(nil)); end

  def rescue_without_error_class?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::RescueStandardError
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def chained_send?(param0=T.unsafe(nil)); end

  def define_method?(param0=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(param0=T.unsafe(nil)); end

  def return_node?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ReturnNil
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::AllowedMethods
  include ::RuboCop::Cop::RangeHelp
  def check_node(node); end

  def modifier_if_safe_navigation_candidate(param0=T.unsafe(nil)); end

  def not_nil_check?(param0=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def use_var_only_in_unless_modifier?(node, variable); end
end

class RuboCop::Cop::Style::SafeNavigation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Sample
  def on_send(node); end

  def sample_candidate?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Sample
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SelfAssignment
  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
end

class RuboCop::Cop::Style::SelfAssignment
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def on_begin(node); end
end

class RuboCop::Cop::Style::Semicolon
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Send
  def on_csend(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def custom_fail_methods(param0); end

  def kernel_call?(param0=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleArgumentDig
  def on_send(node); end

  def single_argument_dig?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleArgumentDig
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::SingleLineMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SlicingWithRange
  def on_send(node); end

  def range_till_minus_one?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SlicingWithRange
  extend ::RuboCop::Cop::AutoCorrector
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::SoleNestedConditional
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SoleNestedConditional
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(corrector, node, global_var); end

  def message(global_var); end

  def on_gvar(node); end
end

class RuboCop::Cop::Style::SpecialGlobalVars
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end

  def stderr_puts?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringConcatenation
  def on_send(node); end

  def string_concatenation?(param0=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringConcatenation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringHashKeys
  def on_pair(node); end

  def receive_environments_method?(param0=T.unsafe(nil)); end

  def string_hash_key?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::StringHashKeys
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def on_dstr(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::StringMethods
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::Strip
  include ::RuboCop::Cop::RangeHelp
  def lstrip_rstrip(param0=T.unsafe(nil)); end

  def on_send(node); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Strip
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::StructInheritance
  include ::RuboCop::Cop::RangeHelp
  def on_class(node); end

  def struct_constructor?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::StructInheritance
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def on_array(node); end
end

class RuboCop::Cop::Style::SymbolArray
  extend ::RuboCop::Cop::AutoCorrector
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def on_sym(node); end
end

class RuboCop::Cop::Style::SymbolLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def destructuring_block_argument?(argument_node); end

  def on_block(node); end

  def proc_node?(param0=T.unsafe(nil)); end

  def symbol_proc?(param0=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::SymbolProc
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(corrector, node); end

  def self.move_assignment_inside_condition(corrector, node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def method_name(param0=T.unsafe(nil)); end

  def on_if(node); end

  def only_closing_parenthesis_is_last_line?(condition); end
end

class RuboCop::Cop::Style::TernaryParentheses
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_class(node); end
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def on_module(node); end
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_csend(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  def on_block(node); end
end

class RuboCop::Cop::Style::TrailingCommaInBlockArgs
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  def on_def(node); end
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def on_masgn(node); end
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::TrivialAccessors
  include ::RuboCop::Cop::AllowedMethods
  def looks_like_trivial_writer?(param0=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Style::TrivialAccessors
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::UnlessElse
  include ::RuboCop::Cop::RangeHelp
  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
end

class RuboCop::Cop::Style::UnlessElse
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::UnpackFirst
  def on_send(node); end

  def unpack_and_first_element?(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::VariableInterpolation
  include ::RuboCop::Cop::Interpolation
end

class RuboCop::Cop::Style::VariableInterpolation
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhenThen
  def on_when(node); end
end

class RuboCop::Cop::Style::WhenThen
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhileUntilDo
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::WhileUntilDo
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::LineLengthHelp
  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::WhileUntilModifier
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def on_array(node); end
end

class RuboCop::Cop::Style::WordArray
  extend ::RuboCop::Cop::AutoCorrector
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def file_constant_equal_program_name?(param0=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Style::YodaCondition
  extend ::RuboCop::Cop::AutoCorrector
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def non_polymorphic_collection?(param0=T.unsafe(nil)); end

  def nonzero_length_predicate(param0=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(param0=T.unsafe(nil)); end

  def zero_length_predicate(param0=T.unsafe(nil)); end

  def zero_length_receiver(param0=T.unsafe(nil)); end
  RESTRICT_ON_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  extend ::RuboCop::Cop::AutoCorrector
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def required_minimum_ruby_version(); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Team
  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def external_dependency_checksum(); end

  def forces(); end

  def initialize(cops, config=T.unsafe(nil), options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def investigate(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
end

class RuboCop::Cop::Team
  def self.forces_for(cops); end

  def self.mobilize(cop_classes, config, options=T.unsafe(nil)); end

  def self.mobilize_cops(cop_classes, config, options=T.unsafe(nil)); end

  def self.new(cop_or_classes, config, options=T.unsafe(nil)); end
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(corrector, processed_source, node); end

  def self.correct_for_blockarg_type(corrector, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
end

module RuboCop::Cop::Util
  def self.add_parentheses(node, corrector); end

  def self.args_begin(node); end

  def self.args_end(node); end

  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.comment_lines?(node); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.trim_string_interporation_escape_character(str); end
end

class RuboCop::Cop::Utils::FormatString
  def format_sequences(); end

  def initialize(string); end

  def max_digit_dollar_num(); end

  def named_interpolation?(); end

  def valid?(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
  def annotated?(); end

  def arity(); end

  def begin_pos(); end

  def end_pos(); end

  def flags(); end

  def initialize(match); end

  def max_digit_dollar_num(); end

  def name(); end

  def percent?(); end

  def precision(); end

  def style(); end

  def template?(); end

  def type(); end

  def width(); end
end

class RuboCop::Cop::Utils::FormatString::FormatSequence
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def in_modifier_if?(assignment); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

module RuboCop::Cop::VisibilityHelp
  def visibility_block?(param0=T.unsafe(nil)); end
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::VisibilityHelp
  extend ::RuboCop::AST::NodePattern::Macros
end

class RuboCop::DirectiveComment
  def comment(); end

  def cops(); end

  def initialize(comment); end

  def match?(cop_names); end

  def range(); end
end

class RuboCop::DirectiveComment
end

class RuboCop::Error
end

class RuboCop::Error
end

class RuboCop::ErrorWithAnalyzedFileLocation
  def column(); end

  def cop(); end

  def initialize(cause:, node:, cop:); end

  def line(); end
end

class RuboCop::ErrorWithAnalyzedFileLocation
end

module RuboCop::Ext
end

module RuboCop::Ext::ProcessedSource
  def comment_config(); end

  def disabled_line_ranges(); end
end

module RuboCop::Ext::ProcessedSource
end

module RuboCop::Ext::RegexpNode
  def each_capture(named: T.unsafe(nil)); end

  def parsed_tree(); end
end

module RuboCop::Ext::RegexpNode
  def self.parsed_cache(); end
end

module RuboCop::Ext
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end

  def find_last_file_upwards(filename, start_dir, stop_dir=T.unsafe(nil)); end
end

module RuboCop::FileFinder
  def self.root_level=(level); end

  def self.root_level?(path, stop_dir); end
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::JUnitFormatter
  def classname_attribute_value(file); end

  def finished(_inspected_files); end

  def offenses_for_cop(all_offenses, cop); end

  def relevant_for_output?(options, target_offenses); end
end

class RuboCop::Formatter::JUnitFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::PacmanFormatter
  include ::RuboCop::Formatter::TextUtil
  def cols(); end

  def file_started(_file, _options); end

  def next_step(offenses); end

  def pacdots(number); end

  def progress_line(); end

  def progress_line=(progress_line); end

  def started(target_files); end

  def step(character); end

  def update_progress_line(); end
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count, correctable_count); end

  def started(_target_files); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, correctable_count, rainbow, safe_auto_correct: T.unsafe(nil)); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end

  def valid_literal_value?(); end
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
end

module RuboCop::NameSimilarity
  def self.find_similar_name(target_name, names); end

  def self.find_similar_names(target_name, names); end
end

class RuboCop::AST::NodePattern
end

RuboCop::NodePattern::Builder = RuboCop::AST::NodePattern::Builder

class RuboCop::AST::NodePattern::Compiler
end

RuboCop::NodePattern::Compiler::Debug = RuboCop::AST::NodePattern::Compiler::Debug

class RuboCop::AST::NodePattern::Compiler
end

class RuboCop::AST::NodePattern::Lexer
end

RuboCop::NodePattern::Lexer::Error = RuboCop::AST::NodePattern::LexerRex::ScanError

class RuboCop::AST::NodePattern::Lexer
end

class RuboCop::AST::NodePattern
end

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def display_only_fail_level_offenses_with_autocorrect?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def only_includes_redundant_disable?(); end

  def validate_auto_correct(); end

  def validate_auto_gen_config(); end

  def validate_cache_enabled_for_cache_root(); end

  def validate_compatibility(); end

  def validate_cop_options(); end

  def validate_display_only_failed(); end

  def validate_exclude_limit_option(); end

  def validate_parallel(); end

  def validate_parallel_with_combo_option(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  def self.absolute?(path); end

  def self.hidden_dir?(path); end

  def self.hidden_file?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.maybe_hidden_file?(path); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  def self.windows?(); end
end

RuboCop::ProcessedSource = RuboCop::AST::ProcessedSource

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
end

class RuboCop::ResultCache
  def debug?(); end

  def initialize(file, team, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def path(); end

  def save(offenses); end

  def valid?(); end
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.rubocop_required_features(); end

  def self.rubocop_required_features=(rubocop_required_features); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def aborting=(aborting); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses_by_iteration, loop_start: T.unsafe(nil)); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

module RuboCop::Sorbet
  CONFIG = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Sorbet::Error
end

class RuboCop::Sorbet::Error
end

module RuboCop::Sorbet::Inject
end

module RuboCop::Sorbet::Inject
  def self.defaults!(); end
end

module RuboCop::Sorbet
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

class RuboCop::TargetFinder
  def all_cops_include(); end

  def combined_exclude_glob_patterns(base_dir); end

  def configured_include?(file); end

  def debug?(); end

  def fail_fast?(); end

  def find(args, mode); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def included_file?(file); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path, mode); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_extensions(); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def ruby_filenames(); end

  def ruby_interpreters(file); end

  def stdin?(); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def wanted_dir_patterns(base_dir, exclude_pattern, flags); end
  HIDDEN_PATH_SUBSTRING = ::T.let(nil, ::T.untyped)
end

class RuboCop::TargetFinder
end

class RuboCop::TargetRuby
  def initialize(config); end

  def rubocop_version_with_support(); end

  def source(); end

  def supported?(); end

  def version(); end
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::BundlerLockFile
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::Default
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::RuboCopConfig
end

class RuboCop::TargetRuby::Source
  def initialize(config); end

  def name(); end

  def version(); end
end

class RuboCop::TargetRuby::Source
end

class RuboCop::TargetRuby
  def self.supported_versions(); end
end

RuboCop::Token = RuboCop::AST::Token

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  def self.document_version(); end

  def self.version(debug: T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop::YAMLDuplicationChecker
end

module RuboCop::YAMLDuplicationChecker
  def self.check(yaml_string, filename, &on_duplicated); end
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def blank?(); end

  def ext(newext=T.unsafe(nil)); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def shellescape(); end

  def shellsplit(); end
end

class StringScanner
  def bol?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

class UnboundMethod
  include ::MethodSource::SourceLocation::UnboundMethodExtensions
  include ::MethodSource::MethodExtensions
end

module Unicode
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth
  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Unicode
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

module Zeitwerk
end

class Zeitwerk::Error
end

class Zeitwerk::Error
end

module Zeitwerk::ExplicitNamespace
end

module Zeitwerk::ExplicitNamespace
  extend ::Zeitwerk::RealModName
  def self.cpaths(); end

  def self.mutex(); end

  def self.register(cpath, loader); end

  def self.tracer(); end

  def self.unregister(loader); end
end

class Zeitwerk::GemInflector
  def camelize(basename, abspath); end

  def initialize(root_file); end
end

class Zeitwerk::GemInflector
end

class Zeitwerk::Inflector
  def camelize(basename, _abspath); end

  def inflect(inflections); end
end

class Zeitwerk::Inflector
end

class Zeitwerk::Loader
  include ::Zeitwerk::Loader::Callbacks
  include ::Zeitwerk::RealModName
  def autoloaded_dirs(); end

  def autoloads(); end

  def collapse(*glob_patterns); end

  def collapse_dirs(); end

  def collapse_glob_patterns(); end

  def dirs(); end

  def do_not_eager_load(*paths); end

  def eager_load(); end

  def eager_load_exclusions(); end

  def enable_reloading(); end

  def ignore(*glob_patterns); end

  def ignored_glob_patterns(); end

  def ignored_paths(); end

  def inflector(); end

  def inflector=(inflector); end

  def lazy_subdirs(); end

  def log!(); end

  def logger(); end

  def logger=(logger); end

  def manages?(dir); end

  def mutex(); end

  def mutex2(); end

  def preload(*paths); end

  def preloads(); end

  def push_dir(path, namespace: T.unsafe(nil)); end

  def reload(); end

  def reloading_enabled?(); end

  def root_dirs(); end

  def setup(); end

  def tag(); end

  def tag=(tag); end

  def to_unload(); end

  def unload(); end

  def unloadable_cpath?(cpath); end

  def unloadable_cpaths(); end
end

module Zeitwerk::Loader::Callbacks
  include ::Zeitwerk::RealModName
  def on_dir_autoloaded(dir); end

  def on_file_autoloaded(file); end

  def on_namespace_loaded(namespace); end
end

module Zeitwerk::Loader::Callbacks
end

class Zeitwerk::Loader
  def self.all_dirs(); end

  def self.default_logger(); end

  def self.default_logger=(default_logger); end

  def self.eager_load_all(); end

  def self.for_gem(); end

  def self.mutex(); end

  def self.mutex=(mutex); end
end

class Zeitwerk::NameError
end

class Zeitwerk::NameError
end

module Zeitwerk::RealModName
  def real_mod_name(mod); end
end

module Zeitwerk::RealModName
end

module Zeitwerk::Registry
end

module Zeitwerk::Registry
  def self.autoloads(); end

  def self.inception?(cpath); end

  def self.inceptions(); end

  def self.loader_for(path); end

  def self.loader_for_gem(root_file); end

  def self.loaders(); end

  def self.loaders_managing_gems(); end

  def self.on_unload(loader); end

  def self.register_autoload(loader, realpath); end

  def self.register_inception(cpath, realpath, loader); end

  def self.register_loader(loader); end

  def self.unregister_autoload(realpath); end
end

class Zeitwerk::ReloadingDisabledError
end

class Zeitwerk::ReloadingDisabledError
end

module Zeitwerk
end

class Zlib::Deflate
  def initialize(*_); end
end

class Zlib::GzipReader
  def initialize(*_); end
end

class Zlib::GzipWriter
  def initialize(*_); end
end

class Zlib::Inflate
  def initialize(*_); end
end
