# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class ACL
  def allow_addr?(addr); end

  def allow_socket?(soc); end

  def initialize(list=T.unsafe(nil), order=T.unsafe(nil)); end

  def install_list(list); end
  ALLOW_DENY = ::T.let(nil, ::T.untyped)
  DENY_ALLOW = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ACL::ACLEntry
  def initialize(str); end

  def match(addr); end
end

class ACL::ACLEntry
end

class ACL::ACLList
  def add(str); end

  def match(addr); end
end

class ACL::ACLList
end

class ACL
end

class Addrinfo
  def connect_internal(local_addrinfo, timeout=T.unsafe(nil)); end
end

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

BasicObject::BasicObject = BasicObject

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.new(*args, **kwargs); end
end

class Binding
  def clone(); end

  def irb(); end
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end

  def global_path_appends_ruby_scope?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Index
  include ::Enumerable
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

class Bundler::Molinillo::DependencyGraph
  include ::Enumerable
end

class Bundler::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::RubygemsIntegration::MoreFuture
  def backport_ext_builder_monitor(); end
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(&blk); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

class Bundler::SpecSet
  include ::Enumerable
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
end

class Class
  def json_creatable?(); end
end

class DRb::DRbArray
  def _dump(lv); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbObject
  def ==(other); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
  def self.auto_load(uri); end
end

class DRb::DRbRemoteError
  def initialize(error); end
end

class DRb::DRbServer
  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
end

class DRb::DRbServer
  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

class DRb::DRbUnknown
  def _dump(lv); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  def self.mutex(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

module Diff::LCS
  def self.LCS(seq1, seq2, &block); end

  def self.diff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.lcs(seq1, seq2, &block); end

  def self.patch(src, patchset, direction=T.unsafe(nil)); end

  def self.patch!(src, patchset); end

  def self.sdiff(seq1, seq2, callbacks=T.unsafe(nil), &block); end

  def self.traverse_balanced(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.traverse_sequences(seq1, seq2, callbacks=T.unsafe(nil)); end

  def self.unpatch!(src, patchset); end
end

class Dir
  def children(); end

  def each_child(); end
end

class Dir
  def self.exists?(_); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class ERB::Compiler::Scanner
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class Encoding
  def _dump(*_); end
end

class Encoding::Converter
  def initialize(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def chain(*_); end

  def sum(*_); end
end

class Enumerator
  def +(_); end

  def each_with_index(); end
end

class Enumerator::ArithmeticSequence
  def begin(); end

  def each(&blk); end

  def end(); end

  def exclude_end?(); end

  def last(*_); end

  def step(); end
end

class Enumerator::ArithmeticSequence
end

class Enumerator::Chain
end

class Enumerator::Chain
end

class Enumerator::Generator
  def each(*_, &blk); end

  def initialize(*_); end
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADARCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADARCH
end

class Errno::EBADEXEC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADEXEC
end

class Errno::EBADMACHO
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADMACHO
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

Errno::ECAPMODE = Errno::NOERROR

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDEVERR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EDEVERR
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

Errno::EIPSEC = Errno::NOERROR

class Errno::ELAST
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ELAST
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOPOLICY
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOPOLICY
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPWROFF
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPWROFF
end

Errno::EQFULL = Errno::ELAST

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHLIBVERS
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ESHLIBVERS
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid=(_); end

  def name=(_); end

  def passwd=(_); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::Enumerable
  def self.[](*_); end

  def self.each(&blk); end

  def self.members(); end
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class File
  def self.exists?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::DryRun
  extend ::FileUtils::DryRun
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  include ::FileUtils::LowMethods
end

module FileUtils::NoWrite
  extend ::FileUtils::NoWrite
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::FileUtils::LowMethods
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::FileUtils::StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

module Forwardable
  VERSION = ::T.let(nil, ::T.untyped)
end

module Forwardable
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

module GC
  def garbage_collect(*_); end
end

module GC
  def self.verify_transient_heap_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
  def _deprecated_add_found_dependencies(to_do, dependency_list); end

  def _deprecated_gather_dependencies(); end

  def add_found_dependencies(*args, &block); end

  def gather_dependencies(*args, &block); end
end

class Gem::Exception
  extend ::Gem::Deprecate
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  def self.redirector(); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def present?(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.oct_or_256based(str); end

  def self.strict_oct(str); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package
  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
end

class Gem::Resolver::ActivationRequest
  def others_possible?(); end
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(&blk); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
end

module Gem::Security
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def to_ruby(); end
end

class Gem::Specification
  extend ::Gem::Deprecate
  extend ::Enumerable
  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.remove_spec(spec); end
end

class Gem::SpecificationPolicy
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

Gem::Version::Requirement = Gem::Requirement

module Gem
  def self.default_gems_use_full_paths?(); end

  def self.remove_unresolved_default_spec(spec); end
end

class GraphQL::Analysis::AST::Analyzer
  def on_enter_abstract_node(node, parent, visitor); end

  def on_enter_argument(node, parent, visitor); end

  def on_enter_directive(node, parent, visitor); end

  def on_enter_document(node, parent, visitor); end

  def on_enter_enum(node, parent, visitor); end

  def on_enter_field(node, parent, visitor); end

  def on_enter_fragment_spread(node, parent, visitor); end

  def on_enter_inline_fragment(node, parent, visitor); end

  def on_enter_input_object(node, parent, visitor); end

  def on_enter_list_type(node, parent, visitor); end

  def on_enter_non_null_type(node, parent, visitor); end

  def on_enter_null_value(node, parent, visitor); end

  def on_enter_operation_definition(node, parent, visitor); end

  def on_enter_type_name(node, parent, visitor); end

  def on_enter_variable_definition(node, parent, visitor); end

  def on_enter_variable_identifier(node, parent, visitor); end

  def on_leave_abstract_node(node, parent, visitor); end

  def on_leave_argument(node, parent, visitor); end

  def on_leave_directive(node, parent, visitor); end

  def on_leave_document(node, parent, visitor); end

  def on_leave_enum(node, parent, visitor); end

  def on_leave_field(node, parent, visitor); end

  def on_leave_fragment_spread(node, parent, visitor); end

  def on_leave_inline_fragment(node, parent, visitor); end

  def on_leave_input_object(node, parent, visitor); end

  def on_leave_list_type(node, parent, visitor); end

  def on_leave_non_null_type(node, parent, visitor); end

  def on_leave_null_value(node, parent, visitor); end

  def on_leave_operation_definition(node, parent, visitor); end

  def on_leave_type_name(node, parent, visitor); end

  def on_leave_variable_definition(node, parent, visitor); end

  def on_leave_variable_identifier(node, parent, visitor); end
end

class GraphQL::Backtrace
  def [](*args, &block); end

  def each(*args, &block); end
end

class GraphQL::Define::TypeDefiner
  def self.instance(); end
end

class GraphQL::EnumType::EnumValue
  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def name(); end

  def value(); end

  def value=(value); end
end

class GraphQL::Execution::Interpreter::Arguments
  def [](*args, &block); end

  def each(*args, &block); end

  def each_value(*args, &block); end

  def fetch(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  def each_pair(*args, &block); end

  def size(*args, &block); end
end

class GraphQL::Function
  def self.complexity(new_value=T.unsafe(nil)); end

  def self.deprecation_reason(new_value=T.unsafe(nil)); end

  def self.description(new_value=T.unsafe(nil)); end
end

class GraphQL::Introspection::BaseObject::InvalidNullError
end

class GraphQL::Introspection::BaseObject::InvalidNullError
end

class GraphQL::Introspection::DirectiveLocationEnum::UnresolvedValueError
end

class GraphQL::Introspection::DirectiveLocationEnum::UnresolvedValueError
end

class GraphQL::Introspection::DirectiveType::InvalidNullError
end

class GraphQL::Introspection::DirectiveType::InvalidNullError
end

class GraphQL::Introspection::DynamicFields::InvalidNullError
end

class GraphQL::Introspection::DynamicFields::InvalidNullError
end

class GraphQL::Introspection::EntryPoints::InvalidNullError
end

class GraphQL::Introspection::EntryPoints::InvalidNullError
end

class GraphQL::Introspection::EnumValueType::InvalidNullError
end

class GraphQL::Introspection::EnumValueType::InvalidNullError
end

class GraphQL::Introspection::FieldType::InvalidNullError
end

class GraphQL::Introspection::FieldType::InvalidNullError
end

class GraphQL::Introspection::InputValueType::InvalidNullError
end

class GraphQL::Introspection::InputValueType::InvalidNullError
end

class GraphQL::Introspection::SchemaType::InvalidNullError
end

class GraphQL::Introspection::SchemaType::InvalidNullError
end

class GraphQL::Introspection::TypeKindEnum::UnresolvedValueError
end

class GraphQL::Introspection::TypeKindEnum::UnresolvedValueError
end

class GraphQL::Introspection::TypeType::InvalidNullError
end

class GraphQL::Introspection::TypeType::InvalidNullError
end

class GraphQL::Language::Nodes::Argument
  def initialize_node(name: T.unsafe(nil), value: T.unsafe(nil)); end

  def name(); end

  def value(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Argument
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Directive
  def arguments(); end

  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Directive
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::DirectiveDefinition
  def arguments(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), locations: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def locations(); end

  def merge_argument(node_opts); end

  def merge_location(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::DirectiveDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Document
  def definitions(); end

  def initialize_node(definitions: T.unsafe(nil)); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Document
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::EnumTypeDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_value(node_opts); end

  def name(); end

  def values(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::EnumTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), values: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_value(node_opts); end

  def name(); end

  def values(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::EnumValueDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::EnumValueDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::Field
  def alias(); end

  def arguments(); end

  def directives(); end

  def merge_argument(node_opts); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def name(); end

  def selections(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::Field
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FieldDefinition
  def arguments(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def merge_directive(node_opts); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FieldDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FragmentDefinition
  def directives(); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def name(); end

  def selections(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FragmentDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::FragmentSpread
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::FragmentSpread
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InlineFragment
  def directives(); end

  def initialize_node(type: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def selections(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InlineFragment
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObject
  def arguments(); end

  def initialize_node(arguments: T.unsafe(nil)); end

  def merge_argument(node_opts); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObject
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InputValueDefinition
  def default_value(); end

  def directives(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InputValueDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::NameOnlyNode
  def initialize_node(name: T.unsafe(nil)); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::NameOnlyNode
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def interfaces(); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ObjectTypeExtension
  def directives(); end

  def fields(); end

  def initialize_node(name: T.unsafe(nil), interfaces: T.unsafe(nil), directives: T.unsafe(nil), fields: T.unsafe(nil)); end

  def interfaces(); end

  def merge_directive(node_opts); end

  def merge_field(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ObjectTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::OperationDefinition
  def directives(); end

  def initialize_node(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), selections: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def merge_selection(node_opts); end

  def merge_variable(node_opts); end

  def name(); end

  def operation_type(); end

  def selections(); end

  def variables(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::OperationDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::ScalarTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::ScalarTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::SchemaDefinition
  def directives(); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def mutation(); end

  def query(); end

  def subscription(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::SchemaDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::SchemaExtension
  def directives(); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def mutation(); end

  def query(); end

  def subscription(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::SchemaExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::UnionTypeDefinition
  def directives(); end

  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), description: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::UnionTypeDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::UnionTypeExtension
  def directives(); end

  def initialize_node(name: T.unsafe(nil), types: T.unsafe(nil), directives: T.unsafe(nil)); end

  def merge_directive(node_opts); end

  def name(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::UnionTypeExtension
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::VariableDefinition
  def default_value(); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil)); end

  def name(); end

  def type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::VariableDefinition
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Nodes::WrapperType
  def initialize_node(of_type: T.unsafe(nil)); end

  def of_type(); end

  def visit_method(); end
end

class GraphQL::Language::Nodes::WrapperType
  def self.children_method_name(); end

  def self.children_method_name=(children_method_name); end
end

class GraphQL::Language::Parser
  def _reduce_10(val, _values, result); end

  def _reduce_100(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_112(val, _values, result); end

  def _reduce_114(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_124(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_132(val, _values, result); end

  def _reduce_133(val, _values, result); end

  def _reduce_134(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_137(val, _values, result); end

  def _reduce_138(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_140(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_142(val, _values, result); end

  def _reduce_143(val, _values, result); end

  def _reduce_144(val, _values, result); end

  def _reduce_148(val, _values, result); end

  def _reduce_149(val, _values, result); end

  def _reduce_150(val, _values, result); end

  def _reduce_152(val, _values, result); end

  def _reduce_153(val, _values, result); end

  def _reduce_154(val, _values, result); end

  def _reduce_155(val, _values, result); end

  def _reduce_156(val, _values, result); end

  def _reduce_157(val, _values, result); end

  def _reduce_158(val, _values, result); end

  def _reduce_159(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_160(val, _values, result); end

  def _reduce_161(val, _values, result); end

  def _reduce_162(val, _values, result); end

  def _reduce_163(val, _values, result); end

  def _reduce_164(val, _values, result); end

  def _reduce_165(val, _values, result); end

  def _reduce_166(val, _values, result); end

  def _reduce_167(val, _values, result); end

  def _reduce_168(val, _values, result); end

  def _reduce_169(val, _values, result); end

  def _reduce_170(val, _values, result); end

  def _reduce_171(val, _values, result); end

  def _reduce_172(val, _values, result); end

  def _reduce_173(val, _values, result); end

  def _reduce_174(val, _values, result); end

  def _reduce_175(val, _values, result); end

  def _reduce_176(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_38(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_81(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def initialize(query_string, filename:, tracer: T.unsafe(nil)); end

  def parse_document(); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Parser
  def self.parse(query_string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end

  def self.parse_file(filename, tracer: T.unsafe(nil)); end
end

class GraphQL::Language::Visitor
  def on_argument(node, parent); end

  def on_directive(node, parent); end

  def on_directive_definition(node, parent); end

  def on_directive_location(node, parent); end

  def on_document(node, parent); end

  def on_enum(node, parent); end

  def on_enum_type_definition(node, parent); end

  def on_enum_type_extension(node, parent); end

  def on_enum_value_definition(node, parent); end

  def on_field(node, parent); end

  def on_field_definition(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_object_type_extension(node, parent); end

  def on_input_value_definition(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_interface_type_extension(node, parent); end

  def on_list_type(node, parent); end

  def on_non_null_type(node, parent); end

  def on_null_value(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_object_type_extension(node, parent); end

  def on_operation_definition(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_scalar_type_extension(node, parent); end

  def on_schema_definition(node, parent); end

  def on_schema_extension(node, parent); end

  def on_type_name(node, parent); end

  def on_union_type_definition(node, parent); end

  def on_union_type_extension(node, parent); end

  def on_variable_definition(node, parent); end

  def on_variable_identifier(node, parent); end
end

class GraphQL::NonNullType
  def coerce_input(*args, &block); end

  def coerce_result(*args, &block); end

  def list?(*args, &block); end
end

class GraphQL::Query
  def analyzers(*args, &block); end

  def ast_analyzers(*args, &block); end

  def get_field(*args, &block); end

  def get_type(*args, &block); end

  def internal_representation(*args, &block); end

  def interpreter?(*args, &block); end

  def max_complexity(*args, &block); end

  def max_depth(*args, &block); end

  def possible_types(*args, &block); end

  def root_type_for_operation(*args, &block); end

  def validation_errors(*args, &block); end
end

class GraphQL::Query::Arguments
  def any?(*args, &block); end

  def each(*args, &block); end

  def keys(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Query::Context
  def []=(*args, &block); end

  def interpreter?(*args, &block); end

  def trace(*args, &block); end
end

class GraphQL::Query::Context::FieldResolutionContext
  def [](*args, &block); end

  def []=(*args, &block); end

  def dig(*args, &block); end

  def errors(*args, &block); end

  def execution_strategy(*args, &block); end

  def fetch(*args, &block); end

  def interpreter?(*args, &block); end

  def key?(*args, &block); end

  def namespace(*args, &block); end

  def spawn(*args, &block); end

  def strategy(*args, &block); end

  def to_h(*args, &block); end

  def warden(*args, &block); end
end

class GraphQL::Query::NullContext
  def self.interpreter?(*args, &block); end

  def self.query(*args, &block); end

  def self.schema(*args, &block); end

  def self.warden(*args, &block); end
end

class GraphQL::Query::Result
  def [](*args, &block); end

  def as_json(*args, &block); end

  def context(*args, &block); end

  def keys(*args, &block); end

  def mutation?(*args, &block); end

  def query?(*args, &block); end

  def subscription?(*args, &block); end

  def to_json(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Query::Variables
  def [](*args, &block); end

  def fetch(*args, &block); end

  def key?(*args, &block); end

  def length(*args, &block); end

  def to_h(*args, &block); end
end

class GraphQL::RakeTask
  include ::FileUtils::StreamUtils_
end

class GraphQL::RakeTask
  extend ::FileUtils::StreamUtils_
end

class GraphQL::Schema
  def directive(*args, &block); end

  def error_handler(*args, &block); end

  def inaccessible_fields(*args, &block); end

  def unauthorized_field(*args, &block); end

  def unauthorized_object(*args, &block); end
end

class GraphQL::Schema::Argument
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
end

class GraphQL::Schema::Argument
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

class GraphQL::Schema::Directive
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
end

class GraphQL::Schema::Enum
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema::EnumValue
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
end

class GraphQL::Schema::EnumValue
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
end

class GraphQL::Schema::Field
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
end

class GraphQL::Schema::InputObject
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
  def any?(*args, &block); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def keys(*args, &block); end

  def map(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Schema::InputObject
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

module GraphQL::Schema::Interface::DefinitionMethods
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  include ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

module GraphQL::Schema::Interface
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

module GraphQL::Schema::Member::BaseDSLMethods
  include ::GraphQL::Schema::FindInheritedValue::EmptyObjects
end

class GraphQL::Schema::Member
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
end

class GraphQL::Schema::MiddlewareChain
  def [](*args, &block); end

  def delete(*args, &block); end

  def first(*args, &block); end

  def insert(*args, &block); end
end

class GraphQL::Schema::Object
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::HasArguments::ArgumentObjectLoader
end

class GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
end

class GraphQL::Schema::Scalar
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema::Union
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
end

class GraphQL::Schema
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.execution_strategy_for_operation(*args, &block); end

  def self.id_from_object=(*args, &block); end

  def self.id_from_object_proc(*args, &block); end

  def self.metadata(*args, &block); end

  def self.object_from_id=(*args, &block); end

  def self.object_from_id_proc(*args, &block); end

  def self.redefine(*args, &block); end

  def self.remove_handler(*args, &block); end

  def self.validate(*args, &block); end
end

class GraphQL::StaticValidation::DefaultVisitor
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  def eql?(*args, &block); end

  def hash(*args, &block); end

  def name(*args, &block); end
end

class GraphQL::StaticValidation::FieldsWillMerge::Field
  def self.[](*_); end

  def self.members(); end
end

class GraphQL::StaticValidation::FieldsWillMerge::FragmentSpread
  def self.[](*_); end

  def self.members(); end
end

class GraphQL::StaticValidation::InterpreterVisitor
  include ::GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::RequiredInputObjectAttributesArePresent
  include ::GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  include ::GraphQL::StaticValidation::ArgumentsAreDefined
  include ::GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::FieldsWillMerge
  include ::GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::Language
  include ::GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Error::ErrorHelper
end

module GraphQL::StaticValidation::UniqueDirectivesPerLocation
  def on_enum_type_definition(node, parent); end

  def on_enum_value_definition(node, parent); end

  def on_field(node, parent); end

  def on_field_definition(node, parent); end

  def on_fragment_definition(node, parent); end

  def on_fragment_spread(node, parent); end

  def on_inline_fragment(node, parent); end

  def on_input_object_type_definition(node, parent); end

  def on_input_value_definition(node, parent); end

  def on_interface_type_definition(node, parent); end

  def on_object_type_definition(node, parent); end

  def on_operation_definition(node, parent); end

  def on_scalar_type_definition(node, parent); end

  def on_union_type_definition(node, parent); end
end

class GraphQL::StaticValidation::ValidationContext
  def argument_definition(*args, &block); end

  def dependencies(*args, &block); end

  def directive_definition(*args, &block); end

  def document(*args, &block); end

  def field_definition(*args, &block); end

  def fragments(*args, &block); end

  def object_types(*args, &block); end

  def operations(*args, &block); end

  def parent_type_definition(*args, &block); end

  def path(*args, &block); end

  def schema(*args, &block); end

  def type_definition(*args, &block); end

  def warden(*args, &block); end
end

class GraphQL::Types::Relay::BaseConnection
  def cursor_from_node(*args, &block); end

  def parent(*args, &block); end
end

class GraphQL::Types::Relay::BaseConnection::InvalidNullError
end

class GraphQL::Types::Relay::BaseConnection::InvalidNullError
end

class GraphQL::Types::Relay::BaseEdge::InvalidNullError
end

class GraphQL::Types::Relay::BaseEdge::InvalidNullError
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  def default_relay(new_value); end

  def default_relay?(); end

  def to_graphql(); end
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
end

class GraphQL::Types::Relay::BaseInterface::UnresolvedTypeError
end

class GraphQL::Types::Relay::BaseInterface::UnresolvedTypeError
end

module GraphQL::Types::Relay::BaseInterface
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
end

class GraphQL::Types::Relay::BaseObject::InvalidNullError
end

class GraphQL::Types::Relay::BaseObject::InvalidNullError
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

class GraphQL::Types::Relay::Node::UnresolvedTypeError
end

class GraphQL::Types::Relay::Node::UnresolvedTypeError
end

module GraphQL::Types::Relay::Node
  extend ::GraphQL::Schema::Interface::DefinitionMethods
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::BaseDSLMethods
  extend ::GraphQL::Schema::FindInheritedValue
  extend ::GraphQL::Schema::FindInheritedValue::EmptyObjects
  extend ::GraphQL::Schema::Member::TypeSystemHelpers
  extend ::GraphQL::Schema::Member::HasFields
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::RelayShortcuts
  extend ::GraphQL::Schema::Member::Scoped
  extend ::GraphQL::Schema::Member::HasAstNode
  extend ::GraphQL::Schema::Member::HasUnresolvedTypeError
  extend ::GraphQL::Schema::Member::AcceptsDefinition::AcceptsDefinitionDefinitionMethods
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  extend ::GraphQL::Types::Relay::Node::DefinitionMethods
end

class GraphQL::Types::Relay::PageInfo::InvalidNullError
end

class GraphQL::Types::Relay::PageInfo::InvalidNullError
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
end

class Hash
  def self.try_convert(_); end
end

class HostInfo
  def self.[](*_); end

  def self.members(); end
end

class IO
  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def pathconf(_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def to_bn(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

class JSON::Ext::Parser
  def initialize(*_); end
end

JSON::Parser = JSON::Ext::Parser

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module Kernel
  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def then(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class MonitorMixin::ConditionVariable
  def initialize(monitor); end
end

class Net::BufferedIO
  def write_timeout(); end

  def write_timeout=(write_timeout); end
end

class Net::HTTP
  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def write_timeout(); end

  def write_timeout=(sec); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPEarlyHints
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPEarlyHints
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

Net::HTTPMovedTemporarily = Net::HTTPFound

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPPayloadTooLarge
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPPayloadTooLarge
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPRangeNotSatisfiable
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPRangeNotSatisfiable
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

Net::HTTPRedirectionCode = Net::HTTPRedirection

Net::HTTPRequestURITooLarge = Net::HTTPURITooLong

Net::HTTPResponceReceiver = Net::HTTPResponse

Net::HTTPRetriableCode = Net::HTTPRedirection

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

Net::HTTPServerErrorCode = Net::HTTPServerError

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPURITooLong
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPURITooLong
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::ReadTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class Net::WriteTimeout
  def initialize(io=T.unsafe(nil)); end

  def io(); end
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CLEAN = ::T.let(nil, ::T.untyped)
  CLOBBER = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RAKEVERSION = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Object
  def self.yaml_tag(url); end
end

class OpenSSL::ASN1::ASN1Data
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::BN
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  def self.hkdf(*_); end

  def self.pbkdf2_hmac(*_); end

  def self.scrypt(*_); end
end

class OpenSSL::OCSP::Request
  def signed?(); end
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKey::EC
  EXPLICIT_CURVE = ::T.let(nil, ::T.untyped)
end

class OpenSSL::PKey::EC::Point
  def to_octet_string(_); end
end

module OpenSSL::SSL
  OP_ALLOW_NO_DHE_KEX = ::T.let(nil, ::T.untyped)
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_NO_ENCRYPT_THEN_MAC = ::T.let(nil, ::T.untyped)
  OP_NO_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_NO_TLSv1_3 = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

module OpenSSL::X509
  V_FLAG_NO_CHECK_TIME = ::T.let(nil, ::T.untyped)
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  def ==(other); end
end

class OpenSSL::X509::CRL
  def ==(other); end
end

class OpenSSL::X509::Extension
  def ==(other); end
end

class OpenSSL::X509::Name
  def to_utf8(); end
end

class OpenSSL::X509::Request
  def ==(other); end
end

class OpenSSL::X509::Revoked
  def ==(other); end

  def to_der(); end
end

module OpenSSL
  def self.fips_mode(); end
end

ParseError = Racc::ParseError

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def <<(_); end

  def >>(_); end

  def clone(); end
end

module Psych
  VERSION = ::T.let(nil, ::T.untyped)
end

module Psych
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.remove_type(type_tag); end
end

class RSpec::Core::Bisect::ExampleMinimizer::ExampleRange
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Bisect::ExampleSetDescriptor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Configuration::Readers
  def default_color=(default_color); end

  def default_color?(); end

  def default_path?(); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_exit_code=(error_exit_code); end

  def error_exit_code?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def order=(*args, &block); end

  def ordering_registry(*args, &block); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def register_ordering(*args, &block); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def start_time=(start_time); end

  def start_time?(); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def tty=(tty); end

  def tty?(); end
end

class RSpec::Core::Example
  def execution_result(); end

  def file_path(); end

  def full_description(); end

  def location(); end

  def pending(); end

  def skip(); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def <<(*a, &b); end

  def ===(*a, &b); end

  def >>(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def update_inherited_metadata(*a, &b); end

  def yield(*a, &b); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods
  include ::RSpec::Mocks::ArgumentMatchers
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
  include ::RSpec::Matchers
end

class RSpec::Core::ExampleGroup
  def self.context(*args, &example_group_block); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.fspecify(*all_args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_has_behavior(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.pending(*all_args, &block); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def max_line_count(); end

  def source(); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assoc(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_hash(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MockingAdapters::RSpec
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def gets(*args, &block); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def reopen(*args, &block); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

module RSpec::Core::SharedContext
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::ShellEscape
  def self.escape(shell_command); end
end

class RSpec::Core::Time
  def self.now(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def body_tokens(); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_identical_to(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be_diffed_as(*args, &block); end

  def be_falsy(*args, &block); end

  def be_identical_string(*expected, &block_arg); end

  def changing(*args, &block); end

  def containing_exactly(*args, &block); end

  def covering(*args, &block); end

  def ending_with(*args, &block); end

  def eq_to(*args, &block); end

  def eql_to(*args, &block); end

  def equal_to(*args, &block); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def having_attributes(*args, &block); end

  def including(*args, &block); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def raising(*args, &block); end

  def responding_to(*args, &block); end

  def satisfying(*args, &block); end

  def starting_with(*args, &block); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
end

class RSpec::Matchers::BuiltIn::Be
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end
end

class RSpec::Mocks::AllowanceTarget
  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

module RSpec::Mocks::AnyInstance::Chain::Customizations
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::AnyInstance::Recorder
  include ::T::CompatibilityPatches::RSpecCompatibility::RecorderExtensions
end

class RSpec::Mocks::AnyInstanceAllowanceTarget
  def not_to(matcher, *_args); end

  def to(matcher, &block); end

  def to_not(matcher, *_args); end
end

class RSpec::Mocks::AnyInstanceExpectationTarget
  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

module RSpec::Mocks::ExampleMethods
  def allow(target); end

  def allow_any_instance_of(klass); end

  def expect_any_instance_of(klass); end

  def receive(method_name, &block); end

  def receive_message_chain(*messages, &block); end

  def receive_messages(message_return_value_hash); end
end

module RSpec::Mocks::ExampleMethods::ExpectHost
  def expect(target); end
end

module RSpec::Mocks::ExpectationTargetMethods
  def not_to(matcher, &block); end

  def to(matcher, &block); end

  def to_not(matcher, &block); end
end

class RSpec::Mocks::Matchers::HaveReceived
  def at_least(*args); end

  def at_most(*args); end

  def exactly(*args); end

  def once(*args); end

  def ordered(*args); end

  def thrice(*args); end

  def time(*args); end

  def times(*args); end

  def twice(*args); end

  def with(*args); end
end

class RSpec::Mocks::Matchers::Receive
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_wrap_original(*args, &block); end

  def and_yield(*args, &block); end

  def at_least(*args, &block); end

  def at_most(*args, &block); end

  def exactly(*args, &block); end

  def never(*args, &block); end

  def once(*args, &block); end

  def ordered(*args, &block); end

  def thrice(*args, &block); end

  def time(*args, &block); end

  def times(*args, &block); end

  def twice(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::Matchers::ReceiveMessageChain
  def and_call_original(*args, &block); end

  def and_raise(*args, &block); end

  def and_return(*args, &block); end

  def and_throw(*args, &block); end

  def and_yield(*args, &block); end

  def with(*args, &block); end
end

class RSpec::Mocks::MethodDouble
  include ::T::CompatibilityPatches::RSpecCompatibility::MethodDoubleExtensions
end

module RSpec::Mocks::MinitestIntegration
  include ::RSpec::Mocks::ExampleMethods::ExpectHost
end

class RSpec::Mocks::Proxy::SpecificMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::EncodedString
  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def lines(*args, &block); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Support::RubyFeatures
  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end

  def self.supports_taint?(); end
end

class RSpec::Support::Source::File
  def self.expand_path(*_); end

  def self.read(*_); end
end

class RSpec::Support::Source::Location
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Support::WithKeywordsWhenNeeded
  def self.class_exec(klass, *args, &block); end
end

module RSpec::Support
  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_mocks(f); end

  def self.require_rspec_support(f); end
end

module RSpec
  def self.context(*args, &example_group_block); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.shared_context(name, *args, &block); end

  def self.shared_examples(name, *args, &block); end

  def self.shared_examples_for(name, *args, &block); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::Parser
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

module Rake::AltSystem
  def self.backticks(_); end
end

module Rake::Cleaner
  extend ::FileUtils::StreamUtils_
end

module Rake::DSL
  include ::FileUtils::StreamUtils_
end

class Rake::EarlyTime
  def self.instance(); end
end

class Rake::FileList
  def &(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chain(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def difference(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def fetch(*args, &block); end

  def fill(*args, &block); end

  def filter(*args, &block); end

  def filter!(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def permutation(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_h(*args, &block); end

  def to_set(*args, &block); end

  def transpose(*args, &block); end

  def union(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
end

module Rake::FileUtilsExt
  include ::FileUtils::StreamUtils_
  def cd(*args, &block); end

  def chdir(*args, &block); end

  def chmod(*args, &block); end

  def chmod_R(*args, &block); end

  def chown(*args, &block); end

  def chown_R(*args, &block); end

  def copy(*args, &block); end

  def cp(*args, &block); end

  def cp_lr(*args, &block); end

  def cp_r(*args, &block); end

  def install(*args, &block); end

  def link(*args, &block); end

  def ln(*args, &block); end

  def ln_s(*args, &block); end

  def ln_sf(*args, &block); end

  def makedirs(*args, &block); end

  def mkdir(*args, &block); end

  def mkdir_p(*args, &block); end

  def mkpath(*args, &block); end

  def move(*args, &block); end

  def mv(*args, &block); end

  def remove(*args, &block); end

  def rm(*args, &block); end

  def rm_f(*args, &block); end

  def rm_r(*args, &block); end

  def rm_rf(*args, &block); end

  def rmdir(*args, &block); end

  def rmtree(*args, &block); end

  def ruby(*args, &block); end

  def safe_unlink(*args, &block); end

  def sh(*args, &block); end

  def symlink(*args, &block); end

  def touch(*args, &block); end
end

module Rake::FileUtilsExt
  extend ::FileUtils::StreamUtils_
end

class Rake::FtpUploader
  def self.connect(path, host, account, password); end
end

class Rake::LateTime
  def self.instance(); end
end

class Rake::MakefileLoader
  include ::FileUtils::StreamUtils_
end

class Rake::SshDirPublisher
  include ::FileUtils::StreamUtils_
end

class Rake::SshFilePublisher
  include ::FileUtils::StreamUtils_
end

class Rake::TaskLib
  include ::FileUtils::StreamUtils_
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

module Rake
  extend ::FileUtils::StreamUtils_
end

module RakefileDefinitions
  include ::FileUtils::StreamUtils_
end

class Random
  def self.bytes(_); end
end

class Range
  def %(_); end

  def entries(); end

  def to_a(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.fire_update!(key, val, mkconf=T.unsafe(nil), conf=T.unsafe(nil)); end

  def self.ruby(); end
end

module RubyRunner
  include ::FileUtils::StreamUtils_
end

class RubyVM::AbstractSyntaxTree::Node
  def pretty_print_children(q, names=T.unsafe(nil)); end
end

module RubyVM::MJIT
end

module RubyVM::MJIT
  def self.enabled?(); end

  def self.pause(*_); end

  def self.resume(); end
end

class RubyVM
  def self.resolve_feature_path(_); end
end

ScanError = StringScanner::Error

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton
  def self.__init__(klass); end
end

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def shellescape(); end

  def shellsplit(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class StringScanner
  def bol?(); end

  def initialize(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Struct
  def filter(*_); end
end

Struct::Group = Etc::Group

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class TracePoint
  def __enable(_, _1); end

  def eval_script(); end

  def instruction_sequence(); end

  def parameters(); end
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::FTP
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::File
  def check_password(user); end

  def check_user(user); end

  def check_userinfo(user); end

  def set_userinfo(v); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class URI::File
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::MailTo
  def initialize(*arg); end
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  def initialize(opts=T.unsafe(nil)); end
end

class URI::RFC3986_Parser
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

module URI::Util
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::URI::Escape
  def self.get_encoding(label); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

